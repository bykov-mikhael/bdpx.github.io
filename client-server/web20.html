<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8">
<meta http-equiv="content-type" content="text/html; charset=utf-8"/>
<meta name="description" content="Web 2.0 AJAX"/>
<meta name="viewport" content="width=device-width"/>
<link rel="stylesheet" href="/styles.css" type="text/css">
<title>Web 2.0 AJAX</title>
</head>
<body>

<h1>Web 2.0 и Ajax</h1>

<div id="Table of Contents1" dir="ltr">
<p><b><a href="#__RefHeading___Toc284672317">ГЛОБАЛЬНАЯ КОМПЬЮТЕРНАЯ СЕТЬ – ИНТЕРНЕТ</a></b></p>
<p><b><a href="#__RefHeading___Toc284672318">WEB 2.0</a></b></p>
<p><b><a href="#__RefHeading___Toc284672319">ОБЗОР ТЕХНОЛОГИЙ6</a></b></p>
<p><a href="#__RefHeading___Toc284672320">RSS7</a></p>
<p><a href="#__RefHeading___Toc284672321">JSON8</a></p>
<p><a href="#__RefHeading___Toc284672322">SVG8</a></p>
<p><a href="#__RefHeading___Toc284672323">XPath9</a></p>
<p><a href="#__RefHeading___Toc284672324">Canvas9</a></p>
<p><a href="#__RefHeading___Toc284672325">Компоненты WEB2.09</a></p>
<p><a href="#__RefHeading___Toc284672326">1.Веб-службы9</a></p>
<p><a href="#__RefHeading___Toc284672327">2.Веб-синдикация10</a></p>
<p><a href="#__RefHeading___Toc284672328">3.Теги11</a></p>
<p><a href="#__RefHeading___Toc284672329">4.Mash-up — сервисы11</a></p>
<p><a href="#__RefHeading___Toc284672330">Примеры веб 2.0:11</a></p>
<p><a href="#__RefHeading___Toc284672331">Недостатки Веб 2.012</a></p>
<p><a href="#__RefHeading___Toc284672332">Будущее web2.012</a></p>
<p><a href="#__RefHeading___Toc284672333">Технология AJAX для создания современных веб-сайтов13</a></p>
<p><a href="#__RefHeading___Toc284672334">Запрос к серверу из сценария15</a></p>
<p><a href="#__RefHeading___Toc284672335">Вспомним DOM16</a></p>
<p><a href="#__RefHeading___Toc284672336">Что же нового?17</a></p>
<p><a href="#__RefHeading___Toc284672337">Что получает пользователь18</a></p>
<p><a href="#__RefHeading___Toc284672338">Сервер остается сервером19</a></p>
<p><a href="#__RefHeading___Toc284672339">Недостатки Аякса20</a></p>
<p><a href="#__RefHeading___Toc284672340">Синхронная и асинхронная модель в AJAX22</a></p>
<p><a href="#__RefHeading___Toc284672341">Особенности асинхронной модели23</a></p>
<p><b><a href="#__RefHeading___Toc284672342">Dom-model</a></b></p>
<p><a href="#__RefHeading___Toc284672343">Основные понятия27</a></p>
<p><a href="#__RefHeading___Toc284672344">Зачем нужна модель DOM30</a></p>
<p><a href="#__RefHeading___Toc284672345">Модель DOM в окружающем мире31</a></p>
<p><a href="#__RefHeading___Toc284672346">Клиент и сервер32</a></p>
<p><a href="#__RefHeading___Toc284672347">Использование модели DOM на сервере32</a></p>
<p><a href="#__RefHeading___Toc284672348">Использование модели DOM у клиента33</a></p>
<p><b><a href="#__RefHeading___Toc284672349">JavaScript33</a></b></p>
<p><a href="#__RefHeading___Toc284672350">Обзор языка35</a></p>
<p><a href="#__RefHeading___Toc284672351">Общие сведения об объектах36</a></p>
<p><a href="#__RefHeading___Toc284672352">Базовые определения37</a></p>
<p><a href="#__RefHeading___Toc284672353">Размещение кода JavaScript на HTML-странице</a></p>
<p><a href="#__RefHeading___Toc284672354">Объекты, методы и свойства</a></p>
<p><a href="#__RefHeading___Toc284672355">Объекты</a></p>
<p><a href="#__RefHeading___Toc284672356">Методы</a></p>
<p><a href="#__RefHeading___Toc284672357">Свойства</a></p>
<p><b><a href="#__RefHeading___Toc284672358">XMLHTTP</a></b></p>
<p><a href="#__RefHeading___Toc284672359">История</a></p>
<p><a href="#__RefHeading___Toc284672360">Методы класса XMLHttpRequest</a></p>
<p><a href="#__RefHeading___Toc284672361">Свойства класса XMLHttpRequest</a></p>
<p><a href="#__RefHeading___Toc284672362">Ошибки, вызываемые классом XMLHttpRequest</a></p>
<p><a href="#__RefHeading___Toc284672363">Пример использования</a></p>
</div>

<h1>
<br><br>
</h1>
<h1 style="font-weight: normal; page-break-before: always">
</h1>
<h2 style="font-style: normal; font-weight: normal"><a name="__RefHeading___Toc284672317"></a>
ГЛОБАЛЬНАЯ КОМПЬЮТЕРНАЯ СЕТЬ – ИНТЕРНЕТ</h2>
<p>
<br>
</p>
<p>
<i>Интернет</i>
– это глобальная компьютерная сеть,
объединяющая многие локальные,
региональные и корпоративные сети и
включающая сотни миллионов компьютеров.</p>
<p>
Основу, «каркас»
Интернета составляют более 700 миллионов
серверов, постоянно подключенных к
сети.</p>
<p>
К серверам Интернета
могут подключаться сотни миллионов
пользователей с помощью локальных
сетей, коммутируемых или выделенных
телефонных линий.</p>
<p>
Интернет считается
последним и крупнейшим техническим
достижением двадцатого века. Благодаря
ему оказалось возможным соединить сотни
миллионно компьютеров, разбросанных
по всему свету.</p>
<p>
Интернет обеспечил
плавный переход от века массового
производства, века ядерного и космического
к веку информационному. Последствия
этого перехода сегодня ощущают на себе
все отрасли промышленности, культуры
и науки.</p>
<p>
Саморазвитие
Интернета происходит путем его расширения
за счет включения се новых и новых
компонентов. Этот процесс напоминает
ветвление живого растительного организма,
только в его основе лежат не естественные
процессы обмена веществ, а экономические
процессы обмена ресурсами.</p>
<p>
Интернет выполняет
де основные функции: информационную и
коммуникационную.</p>
<p>
<i>Информационная
функция</i><b>
</b>позволяет
потребителям быстро получать затребованную
информацию. Это могут быть научные
знания, книги, статьи, сообщения, рисунки,
видеоматериалы и многое другое.</p>
<p>
Информационная
функция Интернета способствует бурному
проникновению в коммерцию. Немалая
экономия на непродуктивных издержках
позволяет снижать цену на товары,
увеличивать объемы продаж и, тем самым,
увеличивать прибыль, часть от которой
поступает в распоряжение Интернета.
Это введет к еще более быстрому развитию
служб Сети.</p>
<p>
<i>Коммуникационная
функция</i>
Интернета позволяет людям общаться.
Она развивается за счет создания в
Интернете служб, аналогичных традиционным
средствам общения, но превосходя их по
возможностям.</p>
<p>
Так, например,
электронная почта объединяет возможности
обычной почты и приближает их к
возможностям прямого телефонного
общения за счет скорости обмена
сообщениями.</p>
<p>
В Интернете
существует Интернет-телефония, позволяющая
людям разговаривать, как по обычному
телефону, но не нести при этом значительных
расходов на междугороднюю и международную
связь.</p>
<p>
Разумеется,
информационная и коммуникационная
функции Интернета во многом пересекаются.
Так, многие профессионалы используют
возможности коммуникации для оперативного
решения технических вопросов, получения
справочной информации, обсуждения
специальных проблем.</p>
<p>
Технология WWW
позволяет создавать ссылки, которые
реализуют переходы не только внутри
исходного документа, но и на любой другой
документ, находящийся на данном компьютере
и на любой документ любого компьютера,
подключенного к Интернету.</p>
<p>
В 1989 году Тим
Бернерс-Ли предложил свой проект
гипертекстовой системы (см. рис.), согласно
которой нажатие на ссылку вызывает
переход на требуемый документ или
фрагмент документа.</p>
<p>
В качестве указателей
ссылок, то есть объектов, активизация
которых вызывает переход на другой
документ, могут использоваться на только
фрагменты текста, но и графические
изображения. 
</p>
<p>
Серверы Интернета,
реализующие WWW-технологию, называются
Web-серверами, а документы, реализованные
по технологии WWW, называются Web-страницами.

</p>
<p>
Создание Web-страниц
осуществляется с помощью языка разметки
гипертекста (Hyper Text Markup Language - HTML). Основа
используемой в HTML технологии состоит
в том, что в обычный текстовый документ
вставляются управляющие символы (тэги).
В результате текстовый документ в
браузере выглядит как Web-страница.</p>
<p>
Базовым кирпичиком
для WWW является компьютер с установленным
на нём ВЕБ-сервером подключённый к сети,
то есть к другим компьютерам. ВЕБ-сервер
– программа, запускаемая на подключённом
к сети компьютере, и использующей
протокол HTTP для передачи данных. 
</p>
<p>
В простейшем виде
такая программа получает по сети
HTTP-запрос на определённый ресурс, находит
соответствующий файл на локальном
жёстком диске и отправляет его по сети
запросившему компьютеру. Более сложные
веб-серверы способны динамически
формировать ресурсы в ответ на HTTP-запрос.

</p>
<p>
Для идентификации
ресурсов во Всемирной паутине используются
единообразные идентификаторы ресурсов
URI ( Uniform Resource Identifier). Для определения
местонахождения ресурсов в сети
используются единообразные локаторы
ресурсов URL (Uniform Resource Locator). 
</p>
<p>
Такие URL-локаторы
сочетают в себе технологию идентификации
URL и систему доменных имён DNS (Domain Name
System) — доменное имя (или непосредственно
IP-адрес в числовой записи) входит в
состав URL для обозначения компьютера
(точнее — одного из его сетевых
интерфейсов), который исполняет код
нужного веб-сервера. 
</p>
<p>
Для просмотра
информации, полученной от веб-сервера,
на клиентском компьютере применяется
специальная программа — веб-браузер. 
</p>
<p>
Основная функция
веб-браузера — отображение гипертекста.
Гипертекст – это текст, размеченный
языком гипертекстовой разметки HTML,
после HTML-разметки получившийся гипертекст
помещается в файл, такой HTML-файл является
самым распространённым ресурсом
Всемирной паутины. 
</p>
<p>
После того, как
HTML-файл становится доступен веб-серверу,
его начинают называть «веб-страницей».
Набор веб-страниц образует веб-сайт. В
гипертекст веб-страниц добавляются
гиперссылки. 
</p>
<p>
Гиперссылки,
основанные на технологии URL, помогают
пользователям Всемирной паутины легко
перемещаться между ресурсами (файлами)
вне зависимости от того, находятся
ресурсы на локальном компьютере или на
удалённом сервере. 
</p>
<h2><a name="__RefHeading___Toc284672318"></a>
WEB
2.0</h2>
<p>
<br>
</p>
<p>
Казалось бы, не
так давно Интернет родился, охватил
планету, превратился в Web и уже сумел
стать &quot;обыденностью&quot; для сотен
миллионов людей. Однако сегодняшняя
работа в Интернете настоятельно требует
расширения интерактивности и открытости,
и это ведет к изменению способов
использования сети сетей. И вот уже
&quot;нынешний&quot; Интернет и &quot;прежний&quot;
имеют различия. &quot;Новый&quot; Интернет
уже получил название Web 2.0, за которым
скрывается философия переосмысления
Интерне та и находящаяся в непрерывном
развитии система концепций, касающихся
его архитектуры, стандартов и приложений.
В Web 2.0 изменяются и правила функционирования
онлайновых моделей, моделей в сфере
бизнеса и много чего еще. Появление же
термина Web 2.0 принято связывать со статьей
Тима O’Рейли &quot;What Is Web 2.0&quot;, впервые
опубликованной на русском языке в
журнале &quot;Компьютерра&quot; в октябре
2005 г. В ней изобретатель нового термина
Тим О’Рейли привязал появление большого
числа web-сайтов, объединенных некоторыми
общими принципами, с общей тенденцией
развития интернет-сообщества и назвал
это явление Web 2.0, в противовес &quot;старому&quot;
Web 1.0.Следует добавить, что новая концепция
родилась на совместном мозговом штурме
издательства O’Reilly Media и компании
MediaLive International, после чего в Сети появилась
&quot;Конференция Web 2.0&quot;, и интернет-сообщество
разделилось на приверженцев и критиков
нового термина. Критики, к примеру,
утверждают, что Web 2.0 является лишь новым
рекламным ходом и маркетинговым понятием,
пришедшим на смену понятию &quot;семантический
Интернет&quot; и обещающим то же самое, о
чем уже объявлялось ранее при запуске
первоначального проекта Web 1.0. В общем,
одни приняли новую концепцию, другие
полагают, что это бессмысленный
маркетинговый термин. Однако, несмотря
на ведущиеся споры, специалисты обычно
выделяют несколько основных аспектов
нового явления.</p>
<p>
Что же такое Web
2.0? Web 2.0 - это популярное определение
новой концепции Интернета, которая
только начинает формировать новые
принципы вашей работы и взаимодействия
с информацией в сети. 
</p>
<p>
Web 2.0 - это не какое-то
определенное программное обеспечение
или зарегистрированная торговая марка
от Microsoft или Google, а &quot;горячее словечко&quot;,
описывающее набор подходов к использованию
сети новыми и очень новаторскими
способами.</p>
<p>
Понятие &quot;Web
2.0&quot; относится к технологиям, позволяющим
данным стать независимыми от того, кто
их произвел, или от сайта, на котором
они впервые появились. Оно относится к
тому, каким путем можно подразделить
информацию на единицы или &quot;кирпичики&quot;,
свободно перетекающие с сайта на сайт
- часто даже так, как не предвидел (и
изначально не подразумевал) их
производитель. 
</p>
<p>
Концепция Web
2.0 позволяет сетевым пользователям
одновременно получать информацию из
большого количества разных сайтов и
доставлять ее на свой собственный сайт
для того, чтобы найти ей новое применение.
Однако это вовсе не означает кражу чужой
работы или пиратское распространение
информации для своих собственных целей.
Наоборот, Web
2.0 - это результат концепции открытого
кода, совместного пользования идеями,
на которых был построен Интернет. Эта
концепция делает данные более связанными
друг с другом. Это позволяет строить
новые информационные и деловые возможности
на основе уже существующей информации
и данных. 
</p>
<p>
Web
2.0 позволяет данным работать в качестве
самостоятельной субстанции, которую
каждый может изменять или перемешивать
с любой целью. Когда данные становятся
самостоятельным организмом, сеть
перестает быть просто набором сайтов
и становится настоящей паутиной (web)
сайтов, которые могут взаимодействовать
друг с другом и коллективно обрабатывать
информацию. Web
2.0 построен на таких технологиях, как,
например, AJAX,
JSON,
SVG,
RSS,
XPath,
Canvas.
Рассмотрим эти технологии более подробно
в следующей главе.</p>
<h2 style="font-style: normal; font-weight: normal"><a name="__RefHeading___Toc284672319"></a>
ОБЗОР ТЕХНОЛОГИЙ</h2>
<p>
<br>
</p>
<p>
Web 2.0 базируется
на нескольких старых, но по новому
осмысленных технологиях:</p>
<ul>
<li><p>
AJAX</p>
<li><p>
JSON</p>
<li><p>
SVG</p>
<li><p>
RSS</p>
<li><p>
XPath</p>
<li><p>
Canvas</p>
</ul>
<h4 class="western"><a name="__RefHeading___Toc284672320"></a>
RSS</h4>
<p>
RSS
— семейство XML-форматов,
предназначенных для описания лент
новостей, анонсов статей, изменений в
блогах и т. п. Информация из различных
источников, представленная в формате
RSS,
может быть собрана, обработана и
представлена пользователю в удобном
для него виде специальными
программами-агрегаторами.</p>
<p>
Обычно с помощью
RSS
2.0 даётся краткое описание новой
информации, появившейся на сайте, и
ссылка на её полную версию. Интернет-ресурс
в формате RSS
называется RSS-каналом,
RSS-лентой
или RSS-фидом.</p>
<p>
Многие современные
браузеры, почтовые клиенты и
Интернет-пейджеры умеют работать с
RSS-лентами,
среди них Safari,
Maxthon,
Miranda,
Mozilla
Firefox,
Mozilla
Thunderbird,
Opera,
Opera
mini,
Microsoft
Internet
Explorer
(начиная с 7-й версии). Кроме того,
существуют специализированные приложения
(RSS-агрегаторы),
собирающие и обрабатывающие информацию
RSS-каналов.
Также очень популярны веб-агрегаторы,
представляющие собой сайты по сбору и
отображению RSS-каналов,
такие как Яндекс.Лента, Google
Reader,
Новотека и Bloglines.</p>
<p>
Из-за существования
нескольких различных версий формата
RSS-каналов
программы-агрегаторы должны уметь
работать со всеми вариантами, что создаёт
некоторые трудности их разработчикам.</p>
<p>
Проблемы совместимости
возникают также при вставке в RSS-описания
небольших HTML-фрагментов,
которые в одних случаях оформляются
как CDATA
узлы, а в других — как HTML-кодированные
PCDATA
узлы. Существуют проблемы с различными
форматами представления дат и метаданных,
таких как частота обновления.</p>
<h4 class="western"><a name="__RefHeading___Toc284672321"></a>
JSON

</h4>
<p>
JSON
(англ. JavaScript
Object
Notation)
— текстовый формат обмена данными,
основанный на JavaScript
и обычно используемый именно с этим
языком. Как и многие другие текстовые
форматы, JSON
легко читается людьми.</p>
<p>
Несмотря на
происхождение от JavaScript
(точнее, от подмножества языка стандарта
ECMA-262
1999 года), формат считается языконезависимым
и может использоваться практически с
любым языком программирования. Для
многих языков существует готовый код
для создания и обработки данных в формате
JSON.</p>
<p>
Практическая
польза использования JSON
открывается при использовании технологии
AJAX.
Формат JSON
является более кратким и удобочитаемым
по сравнению с XML,
является «родным» для Javascript.
Кроме того, в JSON-код
возможна вставка вполне работоспособных
функций.</p>
<h4 class="western"><a name="__RefHeading___Toc284672322"></a>
SVG</h4>
<p>
SVG—
язык разметки масштабируемой векторной
графики, созданный Консорциумом Всемирной
паутины (W3C)
и входящий в подмножество расширяемого
языка разметки XML,
предназначен для описания двухмерной
векторной и смешанной векторно/растровой
графики в формате XML.
Поддерживает как неподвижную, так
анимированную и интерактивную графику
— или, в иных терминах, декларативную
и скриптовую. Это открытый стандарт,
является рекомендацией консорциума
W3C,
— организации, разработавшей такие
стандарты, как HTML
и XHTML.
В основу SVG
легли языки разметки VML
и PGML.</p>
<h4 class="western"><a name="__RefHeading___Toc284672323"></a>
XPath</h4>
<p>
XPath
(XML
Path
Language)
- язык запросов к элементам XML-документа.</p>
<p>
Он был разработан
для организации доступа к частям
документа XML
в файлах трансформации XSLT,
и является стандартом консорциума W3C.</p>
<h4 class="western"><a name="__RefHeading___Toc284672324"></a>
Canvas</h4>
<p>
Canvas
— это элемент HTML5,
который предназначен для создания
bitmap
изображения при помощи JavaScript.</p>
<p>
На сегодняшний
день canvas
чаще используется для построения
графиков, простой анимации и игр в
веб-браузерах. Группа WHATWG
предлагает использовать canvas
как стандарт для создания графики в
новых поколениях веб-приложений</p>
<p>
Ці технології
дозволили винести веб на якісно новий
рівень,однак потрібно усвідомлювати,
що самі по собі дані технології не є
революційними, революцію Web
2.0 зробили методики використання даних
технологій.</p>
<p>
<br>
</p>
<h3><a name="__RefHeading___Toc284672325"></a>
Компоненты WEB2.0</h3>
<p>
<br>
</p>
<h4 class="western"><a name="__RefHeading___Toc284672326"></a>
1.Веб-службы</h4>
<p>
Веб-службы — это
программы, доступ к которым осуществляется
через Веб (то есть протокол HTTP), а обмен
данными происходит в формате XML или JSON
или REST. В результате программное
обеспечение может использовать веб-службы
вместо того чтобы самостоятельно
реализовывать требуемый функционал
(например, проверить введенный в форме
почтовый адрес). В отличие от обычных
динамических библиотек, такой подход
обладает рядом плюсов:</p>
<ul>
<li><p>
Веб-служба находится
на серверах компании, которая её создала.
Поэтому в любой момент пользователю
доступна самая свежая версия данных и
ему не приходится заботиться об
обновлениях и вычислительных мощностях,
требуемых для выполнения операции.</p>
<li><p>
Инструменты для
работы с HTTP и XML есть в любом современном
языке программирования, поэтому
веб-службы переходят в разряд
платформонезависимых.</p>
</ul>

<p>Веб-службы используются для решения определенных трудоемких задач.
В качестве примера можно привести, например Гугл-карты (Google Maps API), которые можно легко встраивать на сайт.
</p>

<h4 class="western"><a name="__RefHeading___Toc284672327"></a>2. Веб-синдикация</h4>

<p>Одновременное распространение информации в том числе
аудио- и видео- на различные страницы
или web-сайты, как правило, с использованием
технологий RSS. Принцип заключается в
распространении заголовков материалов
и ссылки на них (например, последние
сообщения форумов, и т. п.). Первоначально
эта технология использовалась на
новостных ресурсах и в блогах, но
постепенно сфера применения расширилась.</p>

<p>
Это массовое,
автоматическое дублирование материала,
опубликованного в одном месте на
различных сайтах. Эта технология вышла
из новостных сервисов и «Живого Журнала»
и быстро вошла в нашу жизнь, как удобная
концепция распространения материала
в едином формате RSS.</p>
<h4 class="western"><a name="__RefHeading___Toc284672328"></a>
3. Теги</h4>
<p>
Ключевые слова,
описывающие рассматриваемый объект,
либо относящие его к какой-либо категории.
Это своего рода метки, которые присваиваются
объекту, чтобы определить его место
среди других объектов. С понятием меток
тесно связано понятие фолксономии —
термина, о котором широко заговорили
именно в связи с ростом сервисов Веб
2.0, таких как Flickr, del.icio.us, и, в дальнейшем,
Wink.</p>
<p>
Появление и быстрое
распространение блогов тоже вписывается
в концепцию Веб 2.0, создавая так называемую
«редактируемую Паутину» (writable web).</p>
<p>
Возможность
пометить документ ключевыми словами
существует и в языке HTML (англ. keywords),
однако этот способ был полностью
скомпрометирован широким его использованием
в целях поискового спама.</p>

<h4 class="western"><a name="__RefHeading___Toc284672329"></a>4. Mash-up — сервисы</h4>

<p>
Веб mash-up (дословный
перевод — «смешение») — сервис, который
полностью или частично использует в
качестве источников информации другие
сервисы, предоставляя пользователю
новую функциональность для работы. В
результате такой сервис может становиться
также новым источником информации для
других веб mash-up сервисов. Таким образом
образуется сеть зависимых друг от друга
сервисов, интегрированных друг с другом.</p>
<p>
Например, сайт по
поиску недвижимости с интегрированными
картами Google Maps в итоге представляет
собой новый, более удобный сервис, с
помощью которого каждый пользователь
может сразу увидеть все предлагаемые
для продажи дома на карте</p>
<h4 class="western"><a name="__RefHeading___Toc284672330"></a>
Примеры веб 2.0:</h4>
<ol>
<li><p>
Википедия –
свободная энциклопедия</p>
<li><p>
Google Earth - Google-карты</p>
<li><p>
Flickr - онлайн-фотоальбом</p>
<li><p>
delicious - Служба
закладок</p>
<li><p>
Netvibes - Персональний
рабочий стол</p>
<li><p>
Digg.com – Ресурс
новостей</p>
<li><p>
UcoZ - Веб хостинг</p>
</ol>
<p>
<br>
</p>
<h3><a name="__RefHeading___Toc284672331"></a>
Недостатки Веб
2.0</h3>
<p>
<br>
</p>
<p>
Использование
сервисов сторонних компаний наряду с
достоинствами приносит и определённые
проблемы. Среди них:</p>
<ul>
<li><p>
зависимость от
наличия постоянного соединения (исчезает
связь — информация становится недоступной
или неудобной в использовании);</p>
<li><p>
зависимость сайтов
от решений сторонних компаний, зависимость
качества работы сервиса от качества
работы многих других компаний;</p>
<li><p>
слабая
приспособленность нынешней инфраструктуры
к выполнению сложных вычислительных
задач в браузере;</p>
<li><p>
уязвимость
конфиденциальных данных, хранимых на
сторонних серверах, для злоумышленников
(известны случаи хищения личных данных
пользователей, массовых взломов учётных
записей блогов).</p>
</ul>
<p>
Фактически сайт
эпохи Веб 2.0 на первый взгляд интерактивен
и дружелюбен, позволяет себя легко
настраивать. Однако сбор статистики о
пользователях, их предпочтениях и
интересах, личной жизни, карьере, круге
друзей могут помочь владельцу сайта
манипулировать сообществом. По самым
пессимистичным прогнозам многочисленные
сайты Веб 2.0 вкупе с другими современными
технологиями дают прообраз тоталитарной
системы «Большого брата».</p>
<p>
<br>
</p>
<h3><a name="__RefHeading___Toc284672332"></a>
Будущее
web2.0</h3>
<p>
<br>
</p>
<p>
Google
предоставляет все больше и больше
бесплатных веб-служб, что значительно
упрощает разработчикам их работу,
позволяя значительно снижать бюджеты
на сложных порталах. Например, еще 4 года
назад социальная сеть «Мир тесен» просто
не смогла бы быть создана, т.к. она
построена на связке социальности и
картографии (тогда просто не было
адекватных технологий), а сейчас
разработчикам даже не пришлось
реализовывать картографический сервис
— они взяли уже готовый удобный
инструментарий у Google.</p>
<p>
Теги, так
распространенные для связи текстового
контента, уже скоро начнут находить
свое применения в видео. Сейчас, если
взять тот же youtube,
видео связывается на уровне самих
роликов. Следующим шагом в развитии
тегирования будет расстановка тегов
на конкретные объекты внутри видео,
например, на конкретного человека или
его часы (см. технологию «гипервидео»),
что позволит связывать и находить,
например одинаковые объекты в различных
роликах.</p>
<p>
Как видите,
использование технологии web2.0
довольно широко и не привязано только
к социальным сетям или ajax-интерфейсам.
Динамичное развитие этой концепции, а
так же ее грамотное использование
позволяет очень быстро создавать
успешные проекты. Главное — быть
оригинальным и делать полезные,
востребованные инструменты для аудитории.</p>
<p>
<br>
</p>
<h3><a name="__RefHeading___Toc284672333"></a>
Технология
AJAX
для создания современных веб-сайтов</h3>
<p>
<br>
</p>
<p>
В покере есть такая
начальная комбинация карт - туз и валет.
Ее называют «AJAX».
Если она выпадает при раздаче, то шансы
на выигрыш очень велики. Существует
одноименная компьютерная технология,
которая обещает стать козырной картой
в колоде любого сайта.</p>
<p>
На заре развития
Web
сама возможность доступа к связанным
гиперссылками документам казалась
чудом, поэтому пользователи готовы были
терпеливо ожидать загрузки очередной
страницы хоть вечность. К тому же такое
неудобство считалось временным. Уже
скоро, надеялись если не все, то, по
крайней мере, многие, появятся скоростные
каналы и время отклика удаленной машины
станет практически таким же, как и
локальной.</p>
<p>
Однако шли годы,
возможность обращения к серверу на
другом континенте становилась привычной,
а надежды на ускорение отклика таковыми
и оставались. Пропускная способность
линий связи действительно росла, но еще
быстрее увеличивался средний размер
документа. Если раньше Web-страница
содержала только текст и максимум
одну-две картинки, то сейчас среднее
количество изображений исчисляется
десятками. В угоду внешнему виду прибегают
даже к графическому представлению
заголовков – мера, которая еще десять
лет назад была немыслимой. Внедренные
в страницу видео- и аудиофрагменты также
не способствуют ее быстрой загрузке. В
результате пользователю, активизировавшему
ссылку, все так же приходится ожидать,
когда на экране браузера появится новая
страница, и придумывать себе на это
время занятие.</p>
<p>
Но даже если на
некоторых сайтах принципиально не
используются изображения и мультимедийные
данные, это вовсе не означает, что они
всегда будут загружаться с максимальной
скоростью. Причина – в неравномерной
нагрузке на различные участки Всемирной
Сети. Из-за этого страница, пересылаемая
за доли секунды, может долго ожидать
своей очереди на маршрутизаторе,
поскольку тот в данный момент испытывает
пиковую нагрузку.</p>
<p>
Одним словом,
задержки, связанные с передачей информации
по Сети, с годами не исчезли и в дальнейшем
ситуация вряд ли принципиально улучшится.
Чтобы найти выход или хотя бы определить,
где его искать, надо прежде всего понять
суть проблемы. Как ни странно, она состоит
не в том, что активизация ссылки не
приводит к немедленному получению
результата. Гораздо хуже, что в течение
времени, необходимого для загрузки,
старая страница уже недоступна, а новая
еще не получена, поэтому пользователю
приходится прерывать работу и ждать.
Как показали исследования, подобный
режим существенно снижает производительность
труда. Кроме того, часто бывает, что
новый сайт отличается от старого лишь
в мелочах. На месте остаются элементы
навигации, колонтитулы, а заменяется
лишь небольшой фрагмент текста или
одно-два изображения. Возникает резонный
вопрос: почему бы не копировать по Сети
лишь ту часть документа, которую
действительно нужно обновить, и нельзя
ли на время загрузки дополнительной
информации предоставить пользователю
возможность продолжать работу с текущей
страницей? Ответ на него дает новая
концепция Ajax,
объединяющая несколько давно известных
технологий.</p>
<p>
<br>
</p>
<h4><a name="__RefHeading___Toc284672334"></a>
Запрос к серверу из сценария</h4>
<p>
<br>
</p>
<p>
До недавнего
времени вся работа в Web
строилась по принципу полной замены
текущего документа. При активизации
гипертекстовой ссылки или формы браузер
передавал запрос серверу, который
возвращал ответ в виде HTML-документа.
Ситуация изменилась с появлением объекта
XMLHttpRequest,
доступного из JavaScript-сценариев.</p>
<p>
Объект XMLHttpRequest
берет на себя одну из функций браузера,
а именно формирование и передачу запроса
Web-серверу,
и воспользоваться ею довольно просто.
Сначала следует открыть запрос (метод
open()),
указав характеристики заголовка, а
затем передать его (send()).
Принципиальный вопрос – нужно ли теперь
ждать ответа? Если бы дело обстояло так,
то объект XMLHttpRequest
был бы совершенно бесполезен. Согласитесь,
пользователю ведь все равно, кто
«отключит» интерактивные возможности
документа – браузер или JavaScript-сценарий.
К счастью, в методе open()
предусмотрен специальный параметр –
флаг асинхронного выполнения. Если его
значение равно true,
метод send()
практически сразу же вернет управление
сценарию, и в то время, пока запрос будет
«путешествовать» по направлению к
серверу, а затем ответ проходить тот же
путь в обратном направлении, пользователь
сможет продолжить работу с документом.
Конечно, новая информация, которая
должна поступить в ответе, будет некоторое
время недоступна, но тут уж ничего не
поделаешь – пауза неизбежна. Зато
текущая страница останется в полном
распоряжении пользователя.</p>
<p>
Что же произойдет
при получении ответа? Очевидно, управление
должно перейти к функции обратного
вызова (подобный подход не нов и вряд
ли его стоит здесь обсуждать), задать
которую позволяет свойство onready
statechange
того же объекта XMLHttpRequest.
С помощью свойства readyState
мы проверяем состояние процесса обработки
запроса (значение 4 свидетельствует о
его окончании) и при необходимости
извлекаем данные из свойств responseText
или responseXML.</p>
<h4><a name="__RefHeading___Toc284672335"></a>
Вспомним DOM</h4>
<p>
<br>
</p>
<p>
Итак, принципиально
задача решена: нам удалось загрузить
новые данные, не прерывая работу
пользователя с текущей страницей. Однако
для практического применения этого
мало. Полученные данные нужно как-то
включить в состав документа, уже
отображающегося на экране. К счастью,
это возможно, – подходящий механизм
давно отработан и широко известен: надо
воспользоваться структурой DOM.
При этом от свойства responseText
лучше отказаться, так как его применение
потребует дополнительного синтаксического
разбора. Гораздо полезнее responseXML,
в котором информация изначально
представляется в совместимом с DOM
виде. Таким образом, в структуре текущего
документа необходимо выбрать узел, в
состав которого следует включить
возвращенные данные, и вызвать метод
replaceChild(),
заменив старое и ненужное поддерево
новым, прочитанным из responseXML
объекта XMLHttpRequest.</p>
<p>
Остались сущие
мелочи – задать внешний вид полученных
данных посредством каскадных таблиц
стилей. Эту задачу многократно решал
каждый, кто имеет хотя бы небольшой опыт
создания Web-узлов.</p>
<p>
Выполнив упомянутые
выше действия, мы получим не что иное,
как Ajax-приложение.
Несмотря на предельную простоту оно,
тем не менее, отражает все особенности,
характерные для инфраструктуры Ajax.
Во-первых, и это самое главное, запрос
передается серверу в асинхронном режиме
(отсюда первая буква в имени Ajax:
«a»
– asynchronous).
Во-вторых, инициатором запроса выступает
JavaScript-сценарий
(«ja»
– JavaScript).
Теперь совсем не обязательно размещать
на странице гипертекстовые ссылки.
Запрос может быть сформирован в ответ
на попадание курсора мыши в некоторую
область или по истечении заданного
времени (в общем, его можно «привязать»
к любому событию). И, в-третьих, серверу
совсем не обязательно передавать в
ответ на запрос целый документ. Достаточно,
если браузер получит лишь фрагмент, в
котором пользователь в данный момент
нуждается. Посредством DOM
мы включаем его в состав текущей страницы
и формируем внешний вид с помощью правил
CSS.
Ну а чтобы не нарушалась структура,
например, чтобы не встречались открывающие
дескрипторы без закрывающих (как
известно, существующие браузеры очень
лояльны к подобным ошибкам), целесообразно
вообще отказаться от HTML
– гораздо большего доверия заслуживает
формат XML
(отсюда и последняя буква: «x»
– XML).
К сожалению, не хватило для обозначения
структуры DOM и каскадных таблиц стилей,
но очевидно, что без них не обойтись.
Ведь полученные данные надо как-то
включить в состав документа, и удобнее
всего сделать это именно средствами
DOM. Кроме того, в отличие от HTML для
элементов XML не предусмотрены правила
отображения по умолчанию, и придать им
требуемый внешний вид можно только
посредством стилей (CSS или же XSL).</p>
<p>
<br>
</p>
<h4><a name="__RefHeading___Toc284672336"></a>
Что же нового?</h4>
<p>
<br>
</p>
<p>
Традиционно новый
подход к созданию приложений и инструмент,
позволяющий реализовать его на практике,
появляются практически одновременно
и идут рука об руку. Какой же инструмент
претворяет идею Ajax
в жизнь? Объект XMLHttpRequest
был разработан задолго до Ajax.
Язык JavaScript
не намного моложе HTML.
XML
и CSS
также широко известны.</p>
<p>
Как ни странно, ни
одну базовую технологию для Ajax
создавать не пришлось, но именно эта
особенность и является одним из главных
преимуществ данной концепции. Платформу
для выполнения Ajax-приложений
можно собрать из готовых компонентов,
необходимо лишь, чтобы браузер, применяемый
для просмотра документов, поддерживал
объект XMLHttpRequest.
Но это уже забота пользователя – если
речь идет не о корпоративной, а о Всемирной
Сети, разработчики Web-приложений
никак не могут влиять на выбор клиентских
программ.</p>
<p>
<br>
</p>
<h4><a name="__RefHeading___Toc284672337"></a>
Что получает пользователь</h4>
<p>
<br>
</p>
<p>
Инициировав
загрузку очередного фрагмента,
пользователь может продолжать работу,
ни на минуту не отвлекаясь. Все действия
по передаче данных происходят «за
сценой», незаметно для него. И лишь после
получения ответа сервера он увидит, что
одна из частей страницы обновилась.
Вероятно, он будет как-то оповещен об
этом – аудио или визуальным способом,
но это уже задача Web-дизайнера,
который волен распорядиться очередным
инструментом наилучшим образом.</p>
<p>
Однако предоставляя
пользователю новые возможности,
клиентская программа не может не
измениться сама. Если раньше в
«классических» Web-приложениях
вся обработка осуществлялась на стороне
сервера, то в Ajax
такой подход неприемлем. Если каждое
решение будет приниматься на сервере,
то практически безразлично, в каком
режиме передаются запросы: асинхронном
или синхронном, в любом случае до
получения ответа придется приостановить
работу. Выход заключается в повышении
«уровня интеллекта» клиентской программы,
которая должна обеспечивать интерактивное
взаимодействие с пользователем, лишь
изредка обращаясь к серверу. А это
неминуемо приведет к увеличению объема
клиентского кода – JavaScript-сценарии
в составе документа становятся все
сложнее, и для их создания приходится
затрачивать больше времени и усилий.</p>
<p>
Существует еще
одна особенность Ajax-приложений.
Поскольку с сервера загружаются не
целые документы, а их фрагменты,
динамически отображаемые посредством
DOM,
время работы пользователя с одной
страницей многократно возрастает. Это
хорошо видно даже на примере простого
приложения, основные этапы создания
которого были рассмотрены выше. И если
при классическом Web-взаимодействии
незначительные ошибки бывают некритичны
(все равно через несколько минут
пользователь запросит новую страницу),
то в Ajax-приложении
требования к качеству документов
существенно повышаются. Как всегда,
чтобы обеспечить пользователям комфортные
условия, программистам приходится
работать интенсивнее и брать на себя
дополнительную ответственность.</p>
<h4><a name="__RefHeading___Toc284672338"></a>
Сервер остается сервером</h4>
<p>
<br>
</p>
<p>
С точки зрения
требований к серверной части Ajax-программы
мало отличаются от классических
Web-приложений.
Код на стороне сервера должен обрабатывать
клиентские запросы, при необходимости
обеспечивать взаимодействие с базой
данных, формировать ответ, – одним
словом, выполнять совершенно привычные
действия. Тот факт, что вместо документов
клиенту передаются лишь их отдельные
фрагменты, вряд ли окажет существенное
влияние на общую архитектуру. Учитывая,
что Ajax-клиент
берет на себя дополнительные обязанности,
можно было бы ожидать некоторого
упрощения серверного кода, но это вряд
ли произойдет. Как говорится, природа
не терпит пустоты, и как только появляется
новая возможность, тут же возникает и
потребность в дополнительных функциях.</p>
<p>
Несмотря на
относительную новизну Ajax
как концепции, примеры успешных проектов
уже доступны в Глобальной Сети. Например,
в службе GMail
реализовано автоматическое обновление
информации о поступивших письмах
независимо от действий, которые в этот
момент выполняет пользователь. На основе
Ajax
созданы также Google
Suggest
и Google
Maps.
Нетрудно заметить, что именно Google
на сегодняшний день является бесспорным
лидером по применению Ajax
и главным апологетом этой концепции,
однако и другие компании стараются идти
в ногу со временем. В частности, примеру
Google
уже в ближайшем будущем собираются
последовать mail.ru
и еще ряд онлайновых служб.</p>
<p>
Так что же ожидает
Ajax?
Разделит ли данная концепция участь
многих модных новинок, попадающих в
поле зрения программистов лишь для
того, чтобы вскоре оказаться навсегда
забытыми? Ответ, видимо, должен быть
отрицательным. И пользователи, и
разработчики осознают недостатки
классических Web-приложений
и будут приветствовать любое решение,
способное их устранить. Если же Ajax
и уступит место, то только той технологии,
которая позволит достичь еще большей
эффективности. А пока многие ведущие
специалисты, коллективы и известные
компании взяли курс на Ajax
и в обозримом будущем свернуть с него
вряд ли захотят.</p>
<p>
<br>
</p>
<h4><a name="__RefHeading___Toc284672339"></a>
Недостатки Аякса</h4>
<p>
<br>
</p>
<p>
Любая технология
всегда имеет не только плюсы, но и минусы.
Ниже перечисленно наиболее существенные
недостатки AJAX
и возможные методы их устранения. 
</p>
<ul>
<li><p>
<i>Поисковая
оптимизация </i>
</p>
</ul>
<p>
Главной проблемой
страниц на Аяксе является их «невкусность»
для поисковиков, поэтому такие страницы
очень плохо ими «съедаются», ведь
поисковик не умеет переходить по ссылкам
JavaScript.
Огромное количество пользователей
могут пройти мимо твоего сайта, даже
если на нем есть требуемый контент.
Следовательно, его нужно сделать
доступным другим способом, хотя бы самым
банальным – смастерить страничку «Карта
сайта» с полным списком страниц. 
</p>
<ul>
<li><p>
<i>Кроссбраузерность
</i>
</p>
</ul>
<p>
У пользователей
есть плохое качество - они пользуются
разными браузерами. Казалось бы, нет
проблем – пиши код на HTML,
CSS
и JavaScript,
который соответствует стандартам, и
все. Но не тут-то было - разные браузеры
поддерживают стандарты неодинаково.
Что ж, ставим себе несколько самых
популярных браузеров (причем необходимо
поставить еще и их разнообразные версии)
и тестируем наши веб-странички. 
</p>
<ul>
<li><p>
<i>Кнопка «Назад»
</i>
</p>
</ul>
<p>
По данным
исследователей, кнопка браузера «Назад»
является вторым по популярности средством
навигации после перехода по ссылке. То
есть пользователь всегда рассчитывает
на возможность вернуться на одну страницу
назад. Веб-странички, которые созданы
с использованием Аякса, такую возможность
не поддерживают, потому что их содержание
создается «на лету». Чтобы как-то это
исправить, можно запрограммировать
соответствующую логику на JavaScript
и сделать ссылку «Назад», щелчок на
которую позволит пользователю перейти
на предыдущую страницу. Второй вариант,
более универсальный и чаще всего легче
реализуемый, – использовать невидимый
IFRAME,
который будет накапливать историю
переходов. 
</p>
<ul>
<li><p>
<i>Избранное </i>
</p>
</ul>
<p>
Твоя страничка на
Аяксе настолько понравилась посетителю
сайта, что он решил кинуть ее в «Избранное»
(или в «Закладки», если посетитель -
лисовод). Но у него ничего не получится,
так как у группы страничек на Аяксе
всегда адрес первой из них. Справиться
с проблемой опять же можно двумя
способами: программингом и хаком.
Программерское решение заключается в
том, чтобы каждая сгенерированная
страница имела свой адрес и ссылку
«Добавить в Избранное», которая будет
реализовывать нужную логику. Второй
способ - использовать ссылку на подраздел,
который идет в адресе страницы после
знака диеза «#». Дело в том, что с помощью
JavaScript
эту часть адреса можно изменять. Таким
образом, этот хак может частично решить
и проблему кнопки «Назад». 
</p>
<ul>
<li><p>
<i>Неопределенное
время ответа </i>
</p>
</ul>
<p>
Время ответа
сервера на запрос не определено - может
пройти несколько секунд, а может -
несколько минут. И пользователь начинает
сильно нервничать, грызть ногти и наконец
закрывает страничку - ведь браузер никак
не отображает, что там что-то происходит
:). Чтобы не доводить пользователя до
невроза, нужно вставить на страничку
хотя бы надпись «Идет загрузка», а лучше
- анимированное графическое изображение,
которое будет показывать, что она жива.</p>
<p>
<br>
</p>
<h4><a name="__RefHeading___Toc284672340"></a>
Синхронная и асинхронная модель в AJAX</h4>
<p>
<br>
</p>
<p>
В синхронной модели
браузер отправляет запрос на сервер и
висит, ждет, пока тот совершит всю
необходимую работу. Сервер выполняет
запросы к базе данных, заворачивает
ответ в необходимый формат и выводит
его. Браузер. получив ответ, вызывает
функцию показа.</p>
<p>
Все процессы
выполняются последовательно, один за
другим.</p>
<p>
Сетевые задержки
включены во время ожидания, обозначенное
на схеме серым цветом. 
</p>
<p>Пользователь не может заниматься чем-то другим на этой же странице, пока происходит синхронный обмен данными.
</p>

<p>В асинхронной модели запрос отсылается. Когда запрос
выполнился- запускается заранее
подготовленная программистом функция
- показа сообщения сервера.</p>
<p>
Здесь сервер сразу
же уведомляет браузер о том, что запрос
принят в обработку и освобождает его
для дальнейшей работы. Когда ответ будет
готов - сервер перешлет его, и на браузере
будет вызвана соответствующая функция
показа, но пока этот ответ формируется
и пересылается - браузер свободен.</p>
<p>
Асинхронная модель
характеризуется почти мгновенной
реакцией на действия пользователя, так
что создается впечатление удобного и
быстрого приложения.</p>

<h4><a name="__RefHeading___Toc284672341"></a>Особенности асинхронной модели</h4>


<ul>
<li><p>Сложность в реализации</p>
<ol>
<li><p>Недостаточные возможности браузера (javascript)</p>
<li><p>Асинхронная модель сложнее для отладки</p>
</ol>
<li><p>Race conditions </p>
<ol>
<li><p>Неопределена последовательность выполнения</p>
<li><p>Можно делать много одновременных задач (<q>удочек</q>), но задача, начатая первой, может окончиться последней.</p>
</ol>
<li><p>Реакция тут же, но неизвестно, какой будет результат. Усложнена обработка ошибок</p>
<ol>
<li><p>Ошибок коммуникации - разрыв связи, и т.п.</p>
<li><p>Пользовательских ошибок - например, не хватило привилегий</p>
</ol>
<li><p>Контроль целостности (bugproof)</p>
<ol>
<li><p>Например, редактор отправил асинхронный запрос на удаление ветки дерева. Добавление в нее нужно отключить, пока не придет ответ сервера.
Если вдруг не хватило привелегий, то операция не удалась.</p>
</ol>
<li><p>
Интерактивность</p>
<li><p>
Быстрый интерфейс</p>
</ul>

<h2 style="font-style: normal; font-weight: normal"><a name="__RefHeading___Toc284672342"></a>Dom-model</h2>

<p>
Объектная модель
документа DOM &quot;выросла&quot; из объектной
модели Dynamic HTML, но этот рост правильнее
назвать революцией, чем эволюцией.
Объектная модель DHTML позволяет обращаться
к отдельным объектам HTML-документа и
модифицировать их. К каждому тэгу HTML
можно обратиться с помощью его атрибутов
id или name. Каждый объект экспонирует свои
индивидуальные свойства, методы и
события. Свойства можно использовать
для получения и изменения локальных
атрибутов объекта, методы - для оперирования
объектом, а события - для выполнения
предопределенных действий.</p>
<p>
Объектная модель
DOM оказывается намного более общей по
сравнению с объектной моделью DHTML. Она
предоставляет модель для всего документа,
а не только для отдельных тэгов HTML.
Модель DOM представляет документ в виде
дерева. Каждый узел дерева соответствует
тэгу HTML или текстовому элементу (textual
entry) внутри тэга HTML. Древовидная структура
точно описывает весь HTML-документ, включая
взаимосвязи (relationships), или отношения,
между тэгами и текстовыми элементами
документа. Отношения имеют тип child (дочь,
или потомок), parent (родитель, или предок)
и sibling (родственник, или сосед, а буквально
- брат или сестра). Первые два отношения
определяют направление по вертикали
(parent - вверх, child - вниз), а третье - по
горизонтали.</p>
<p>
Модель DOM позволяет
проходить (navigate) по дереву документа
вверх и вниз, а также по горизонтали. С
помощью отношений child, parent и sibling можно
перейти из любого места дерева документа
в любое другое место</p>
<p>
Модель DOM позволяет
оперировать деревом документа, т.е.
создавать (create) новые узлы, удалять
(delete) существующие узлы и перемещать
(move) узлы по дереву. Семантика этих
операций точно соответствует их смыслу:
они добавляют новые тэги, удаляют
существующие тэги и перемещают тэги по
документу.</p>
<p>
Пусть наш документ
имеет вид:</p>
<p>
&lt;!DOCTYPE HTML PUBLIC
&quot;-//W3C//DTD HTML 4.0//EN&quot;&gt;</p>
<p>
&lt;HTML&gt;</p>
<p>
&lt;HEAD&gt;</p>
<p>
&lt;TITLE&gt;Моя домашняя
страница&lt;/TITLE&gt;</p>
<p>
&lt;/HEAD&gt;</p>
<p>
&lt;BODY&gt;</p>
<p>
&lt;H1&gt;Моя
домашняя страница&lt;/H1&gt;</p>
<p>
&lt;P&gt;Добро
пожаловать!&lt;/P&gt;</p>
<p>
&lt;/BODY&gt;</p>
<p>
&lt;/HTML&gt;</p>

<p>Тогда мы можем представить его в виде следующего дерева.
Корнем этого дерева является элемент HTML, который имеет двух детей - HEAD и BODY. Элемент HEAD является отцом
элемента TITLE, а элемент BODY - отцом элементов
H1 и P (два последних элемента называются
братьями, причем H1 является старшим
братом, а P - младшим). Все элементы дерева
являются потомками корня, а тот является
их предком. При этом все элементы и
тексты, образующие их содержимое,
являются узлами дерева документа.</p>
<p>
Каждый элемент
данного дерева соответствует элементу
HTML и, следовательно, имеет тег(и),
содержимое и набор атрибутов. Для
перехода к объектной модели документа
остается сделать единственный шаг:
назвать все элементы дерева объектами,
а их атрибуты сделать доступными для
чтения и для изменения из сценариев и
аплетов. В результате дерево элементов
HTML-документа становится динамически
управляемым; более того, теперь мы можем
легко добавлять к каждому элементу
новые свойства, помимо стандартных
атрибутов HTML.</p>
<p>
Именно такой подход
был положен в основу динамической модели
HTML обозревателей Microsoft, а затем принят
за основу стандартов W3C, получивших
название объектная модель документа
(Document Object Model или DOM). При этом W3C расширил
понятие DOM на любые XML-документы,
рассматривая HTML DOM как специализированный
частный случай с дополнительными
возможностями. Таким образом, DOM - это
модель HTML- и XML-документов, независимая
от платформы и языка программирования,
которая определяет:</p>
<ul>
<li><p>
интерфейсы и
объекты, которые используются для
представления документа и манипулирования
им;</p>
<li><p>
семантику этих
интерфейсов и объектов, включая их
атрибуты и реакцию на события;</p>
<li><p>
взаимосвязи между
этими интерфейсами и объектами</p>
</ul>
<p>
На сегодняшний
день W3C стандартизовал DOM первого и
второго уровней (DOM 1 и DOM 2); в стадии
рабочего проекта находится DOM 3. Эти
аббревиатуры соответственно обозначают
следующее:</p>
<ul>
<li><p>
DOM 1 описывает
базовое представление XML- и HTML-документов
в виде деревьев объектов;</p>
<li><p>
DOM 2 расширяет
базовые интерфейсы DOM 1 и добавляет к
ним поддержку событий и стилей;</p>
<li><p>
DOM 3 описывает
загрузку и синтаксический анализом
документов, а также их отображение и
форматирование.</p>
</ul>
<p>
Рассмотрим DOM 2 (и
содержащуюся в нем DOM 1). DOM 2 состоит из
следующих групп взаимосвязанных
интерфейсов:</p>
<ul>
<li><p>
Core - базовые
интерфейсы, определяющие представление
любого XML-документа в виде дерева;</p>
<li><p>
View - интерфейсы,
описывающие возможные отображения
документа;</p>
<li><p>
Event - интерфейсы,
определяющие порядок генерации и
обработки событий;</p>
<li><p>
Style - интерфейсы,
определяющие применение к документам
таблиц стилей;</p>
<li><p>
Traversal &amp; Range -
интерфейсы, определяющие прохождение
дерева документа и манипулирование
областями его содержимого;</p>
<li><p>
HTML - интерфейсы,
определяющие представление HTML-документа
в виде дерева.</p>
</ul>

<h3><a name="__RefHeading___Toc284672343"></a>Основные понятия</h3>

<p>DOM 2 Core представляет
XML-документы в виде деревьев, состоящих
из узлов, которые, в свою очередь, также
являются объектами и реализуют более
специализированные интерфейсы. Одни
типы узлов могут иметь детей, т. е. сами
являться поддеревьями, другие являются
листьями, т. е. детей не имеют. В следующей
таблице сведены все возможные типы
узлов абстрактного документа; для
каждого типа узлов перечислены те узлы,
которые могут быть его детьми. О понятиях,
соответствующих перечисленным узлам.</p>

<table>
<tr>
<td width="175">
<p>Интерфейс</p>
</td>
<td width="110">
<p>Описание</p>
</td>
<td width="309">
<p>Дети</p>
</td>
</tr>
<tr>
<td width="175">
<p>Document</p>
</td>
<td width="110">
<p>Документ</p>
</td>
<td width="309">
<p>Element
(не
более
одного),
ProcessingInstruction, Comment,DocumentType (не
более
одного)</p>
</td>
</tr>
<tr>
<td width="175">
<p>DocumentFragment</p>
</td>
<td width="110">
<p>Фрагмент
документа</p>
</td>
<td width="309">
<p>Element, ProcessingInstruction, Comment, Text, CDATASection, EntityReference</p>
</td>
</tr>
<tr>
<td width="175">
<p>DocumentType</p>
</td>
<td width="110">
<p>Тип
документа</p>
</td>
<td width="309">
<p>детей
не имеет</p>
</td>
</tr>
<tr>
<td width="175">
<p>EntityReference</p>
</td>
<td width="110">
<p>Ссылка
на раздел</p>
</td>
<td width="309">
<p>Element,
ProcessingInstruction, Comment, Text, CDATASection,EntityReference</p>
</td>
</tr>
<tr>
<td width="175">
<p>Element</p>
</td>
<td width="110">
<p>Элемент</p>
</td>
<td width="309">
<p>Element, ProcessingInstruction, Comment, Text, CDATASection,EntityReference</p>
</td>
</tr>
<tr>
<td width="175">
<p>Attr</p>
</td>
<td width="110">
<p>Атрибут</p>
</td>
<td width="309">
<p>Text,
EntityReference</p>
</td>
</tr>
<tr>
<td width="175">
<p>ProcessingInstruction</p>
</td>
<td width="110">
<p>Директива
XML</p>
</td>
<td width="309">
<p>детей
не имеет</p>
</td>
</tr>
<tr>
<td width="175">
<p>Comment</p>
</td>
<td width="110">
<p>Комментарий</p>
</td>
<td width="309">
<p>детей
не имеет</p>
</td>
</tr>
<tr>
<td width="175">
<p>Text</p>
</td>
<td width="110">
<p>Текст</p>
</td>
<td width="309">
<p>детей
не имеет</p>
</td>
</tr>
<tr>
<td width="175">
<p>CDATASection</p>
</td>
<td width="110">
<p>Секция
CDATA</p>
</td>
<td width="309">
<p>детей
не имеет</p>
</td>
</tr>
<tr>
<td width="175">
<p>Entity</p>
</td>
<td width="110">
<p>Раздел</p>
</td>
<td width="309">
<p>Element, ProcessingInstruction, Comment, , CDATASection,EntityReference</p>
</td>
</tr>
<tr>
<td width="175">
<p>Notation</p>
</td>
<td width="110">
<p>Нотация</p>
</td>
<td width="309">
<p>детей
не имеет</p>
</td>
</tr>
</table>

<p>Таблица Структура дерева документа</p>

<p>Кроме того, DOM 2
Core содержит спецификацию интерфейсов
NodeList (упорядоченные списки узлов,
доступных по номеру в списке) и NamedNodeMap
(неупорядоченные списки узлов, доступных
по своему имени). Эти объекты являются
живыми, т. е. любое изменение документа
автоматически влечет изменение всех
связанных с ним списков.</p>
<p>
Интерфейсы Text,
Comment и CDATASection являются потомками
интерфейса CharacterData.</p>
<p>
Следует подчеркнуть,
что DOM 2 Core содержит два набора интерфейсов,
каждый из которых обеспечивает полный
доступ ко всем элементам документа.
Первый набор представляет
объектно-ориентированный подход со
следующей иерархией наследования:
документ - составляющие его элементы -
их атрибуты и текстовое содержимое. При
таком рассмотрении дерева документа
мы говорим о иерархии объектов. Второй
подход построен по принципу &quot;все есть
узлы (Nodes)&quot;. Здесь все составляющие
документа рассматриваются как равноправные
узлы его дерева, и мы можем говорить
только о иерархии узлов. Таким образом,
DOM 2 по своей сути является избыточной,
но предоставляет нам возможность в
зависимости от задачи рассматривать
документ тем или иным способом.</p>
<p>
Все интерфейсы
DOM 2 Core подразделяются на основные
(fundamental) и дополнительные (extended). Основными
являются
интерфейсы
DOMException, DOMImplementation, DocumentFragment, Document, Node,
NodeList, NamedNodeMap, CharacterData, Attr, Element,Text и
Comment. Эти
интерфейсы должны поддерживаться всеми
реализациями DOM, как для XML-, так и для
HTML-документов. Дополнительные интерфейсы
ориентированы на XML-документы, поэтому
реализации DOM для HTML могут их не
поддерживать. К
ним
относятся
CDATASection, DocumentType, Notation, Entity, EntityReference и
ProcessingInstruction.</p>
<p>
В целях независимости
от языка и платформы DOM определяет
следующие типы:</p>
<ul>
<li><p>
DOMString-текстовая
строка, состоящая из символов Unicode в
формате UTF-16. В JavaScript и в Java реализуется
типом String.</p>
<li><p>
DOMTimeStamp-дата и
время в приемлемом для конкретного
языка формате. Например, в JavaScript это
будет объект Date, а в Java - целое число
типа long, содержащее количество
миллисекунд.</p>
</ul>

<h3><a name="__RefHeading___Toc284672344"></a>Зачем нужна модель DOM</h3>

<p>В качестве метода
доступа к файлам XML всегда следует
выбирать модель DOM. По сравнению с такими
доступными механизмами генерации
документов XML, как запись непосредственно
в поток, этот метод имеет ряд преимуществ:</p>
<ol>
<li><p>
Модель DOM гарантирует
правильную грамматику и правильное
оформление документов. 
</p>
</ol>
<p>
DOM трансформирует
текстовый файл в абстрактное представление
дерева узлов. Это позволяет полностью
избежать таких проблем, как незакрытые
или неправильно вложенные теги. Работая
с документом XML при помощи этого метода,
разработчик должен беспокоиться не о
текстовом выражении документа, а только
о связях типа родитель-потомок и об
относящейся к этому информации. Кроме
того, DOM предотвращает создание
неправильных связей родитель-потомок
в документе.</p>
<ol start="2">
<li><p>
Модель DOM абстрагирует
содержание от грамматики. 
</p>
</ol>
<p>
Созданное моделью
DOM дерево узлов - это логическое
представление содержания файла XML,
показывающее, какая информация в нем
представлена и как ее фрагменты
соотносятся друг с другом, вне
непосредственной связи с грамматикой
XML. Информация дерева узлов используется
для обновления реляционной базы данных
или для создания страницы HTML, и разработчики
при этом не должны вникать в специфику
языка XML.</p>
<ol start="3">
<li><p>
Модель DOM упрощает
внутреннее манипулирование документом.

</p>
</ol>
<p>
Задача разработчика,
использующего модель DOM для модификации
внутренней структуры файла XML, упрощается
по сравнению с работой тех, кто для этой
цели применяет традиционные механизмы
манипулирования файлами. Как уже было,
описано DOM позволяет легко добавить
элемент в середину документа. Кроме
того, такие глобальные операции, как
удаление из документа всех элементов
с конкретным именем тега, могут быть
выполнены с помощью пары команд, а не
&quot;метода грубой силы&quot;, предполагающего
полное сканирование всего файла и
удаление ненужных тегов.</p>
<ol start="4">
<li><p>
Модель DOM напоминает
структуры иерархических и реляционных
баз данных. 
</p>
</ol>
<p>
Способ, используемый
DOM для представления связей между
элементами данных, напоминает метод
представления этой информации в
современных иерархических и реляционных
базах данных. С помощью этой модели
упрощается процесс обмена данными между
файлом XML и базой данных. Использование
модели DOM для построения иерархической
структуры документа позволяет легко
передавать информацию между системами.</p>
<p>
<br>
</p>
<h3><a name="__RefHeading___Toc284672345"></a>Модель DOM в окружающем мире</h3>

<p>
Компания Netscape в
версии 4.7 своего браузера еще не предлагает
встроенной поддержки DOM, но при наличии
библиотек ActiveX или Java DOM можно обращаться
к документам XML и работать с ними у
клиента с помощью языков Java и JavaScript.
Следующие версии браузера Netscape включает
встроенную поддержку XML и XSL.</p>
<p>
В браузерах Internet
Explorer 5 и выше находятся встроенные
библиотеки DOM и поддержка XSL. Для сценариев
на стороне клиента доступно множество
объектов для работы с XML-документом,
самые важные из них, объекты XMLDOMDocument,
XMLDOMNode, XMLDOMNodeList, XMLDOMParseError представляющие
интерфейс для доступа ко всему документу,
отдельным его узлам и поддеревьям,
предоставляющие необходимую для отладки
информацию о произошедших ошибках
анализатора соответственно.</p>
<p>
Объект XMLDOMNode,
реализует базовый DOM интерфейс Node,
предназначен для манипулирования с
отдельным узлом дерева документа. Его
свойства и методы позволяют получать
и изменять полную информацию о текущем
узле - его тип (является ли текущий узел
элементом, комментарием, текстом и
т.д.), название, полное название (вместе
с Namespace префиксом), его содержимое, список
дочерних элементов и т.д. 
</p>
<p>
Объект XMLDOMDocument
представляет верхний уровень объектной
иерархии и содержит методы для работы
с документом: его загрузки, анализа,
создания в нем элементов, атрибутов,
комментариев и т.д. Многие свойства и
методы этого объекта реализованы также
в классе Node, т.к. документ может быть
рассмотрен как корневой узел с вложенными
в него поддеревьями. 
</p>
<p>
Объект XMLDOMNodeList
представляет собой список узлов -
поддеревья и содержит методы, при помощи
которых можно организовать процедуру
обхода дерева. 
</p>
<p>
Объект XMLDOMParserError
объект позволяет получить всю необходимую
информацию об ошибке, произошедшей в
ходе разбора документа. Все свойства
этого объекта доступны только для
чтения.</p>

<h3><a name="__RefHeading___Toc284672346"></a>Клиент и сервер</h3>

<p>Все приложения DOM и XML можно разделить на две группы:
устанавливаемые на сервере (или в таком
контролируемом окружении, как системы
типа клиент/сервер) и устанавливаемые
у клиента.</p>

<h3><a name="__RefHeading___Toc284672347"></a>Использование модели DOM на сервере</h3>

<p>Поскольку разработчики Интернет -приложений имеют
значительно больший контроль над
программным обеспечением, устанавливаемым
на их серверах, первые приложения DOM,
как правило, были нацелены именно на
эту область. Модель DOM позволяет
существенно упростить обмен данными
между различными деловыми системами,
а также предоставляют идеальный механизм
для архивирования и извлечения данных.</p>

<h3><a name="__RefHeading___Toc284672348"></a>Использование модели DOM у клиента</h3>

<p>В настоящее время
становится все более важно, чтобы
документ можно было читать различными
клиентами. Эти клиенты могут визуализировать
документ по-разному, в зависимости от
типа клиента и назначения файла.
Пользовательский браузер с помощью
модели DOM изучит дерево узлов документа
и отобразит необходимую клиенту
информацию. 
</p>
<p>
По мере интеграции
модели DOM в основные браузеры станет
возможно с помощью манипуляций документами
XML у клиента добиваться более эффективного
взаимодействия с пользователями.
Структурированную информацию можно
собирать у клиента и отправлять на
сервер за одну транзакцию, а не с помощью
нескольких обращений к формам, находящимся
на различных страницах HTML.</p>
<p>
Таким образом,
Объектная модель документа DOM представляет
собой нейтральный к платформе и языку
интерфейс, который позволяет скриптам
обращаться к содержанию, структуре и
стилю Web-документа и изменять их. Она
определяет логическую структуру
документов и включает в себя модель для
объединения стандартного набора объектов
HTML- и XML-документов и интерфейс для
доступа и манипулирования ими.</p>
<p>
Главное достоинство
DOM - возможность обращаться ко всем
элементам документа для обновления их
содержания и стиля. Работая совместно
с объектной моделью Dynamic HTML (DHTML),
реализованной в броузерах четвертого
поколения, модель DOM расширяет возможности
авторов создавать сложные документы и
данные и управлять ими. Многие задачи,
которые сложно или даже невозможно
решить в модели DHTML, например перемещение
объекта из одной части документа в
другую, легко реализуются с помощью
методов DOM.</p>

<h2 style="font-style: normal; font-weight: normal"><a name="__RefHeading___Toc284672349"></a>JavaScript</h2>

<p>Язык программирования JavaScript был разработан Бренданом Эйком (Brendan Eich) в Netscape Communications как язык сценариев
для обозревателей Netscape Navigator, начиная с версии 2.0. В дальнейшем к развитию этого языка подключилась корпорация
Microsoft, чьи обозреватели Internet Explorer
поддерживают JavaScript, начиная с версии
3.0. Версия Microsoft получила название JScipt,
поскольку JavaScript является зарегистрированной
маркой фирмы Netscape. В 1996 г. ECMA приняла
решение о стандартизации этого языка,
и в июне 1997 г. была принята первая версия
стандарта под названием ECMAScript (ECMA-262). В
апреле 1998 г. этот стандарт был принят
ISO в качестве международного под номером
ISO/IEC 16262. Мы в последующем изложении
основываемся на третьей версии стандарта
ECMA (декабрь 1999 г.), но используем название
JavaScript, а не ECMAScript по двум причинам:</p>
<ul>
<li><p>
Это название
является исторически первым, и под ним
данный язык наиболее известен широкому
кругу пользователей. 
</p>
<li><p>
Соответствующий
тип MIME, а именно &quot;text/javascript&quot;,
распознается всеми обозревателями,
которые поддерживают сценарии на данном
языке, в отличие от JScript или ECMAScript. 
</p>
</ul>
<p>
JavaScript - это
объектно-ориентированный язык
программирования, предназначенный для
написания сценариев, работающих как на
стороне клиента, так и на стороне сервера.
Поэтому он не является &quot;полноценным&quot;
языком программирования, а ориентирован
на использование возможностей той
среды, в которой сценарии исполняются.</p>
<p>
Веб-обозреватель,
работающий на компьютере-клиенте,
обеспечивает среду, в которой JavaScript
имеет доступ к объектам, которые
представляют собой окна, меню, диалоги,
текстовые области, фреймы, куки и
ввод-вывод в Веб-страницу. Кроме того,
обозреватель позволяет присоединить
сценарии на языке JavaScript к таким событиям,
как загрузка и выгрузка страниц и
графических образов, нажатие клавиш и
движение мыши, выбор текста и пересылка
форм. При этом программный код сценариев
только реагирует на события и поэтому
не нуждается в главной программе. Набор
объектов, предоставляемых обозревателем,
известен под названием Document Object Model
(DOM).</p>
<p>
Веб-сервер
обеспечивает иную среду, в которой
объектами являются запросы к базам
данных, клиенты, файлы и механизмы
блокировки и совместного использования
данных. Совместное использование
сценариев и на стороне клиента, и на
стороне сервера позволяет распределить
вычисления между ними и обеспечить
желаемый пользовательский интерфейс
для Веб-приложения.</p>

<h3><a name="__RefHeading___Toc284672350"></a>Обзор языка</h3>

<p>JavaScript - это язык программирования, основанный на объектах: и языковые средства, и
возможности среды представляются объектами, а сценарий (программа) на JavaScript - это набор взаимодействующих объектов.
Объект JavaScript - это неупорядоченный набор свойств,
каждое из которых имеет нуль или более
атрибутов, которые определяют, как это
свойство может использоваться. Например,
если атрибуту свойства ReadOnly
(неизменяемый) присвоено значение true
(истина), то все попытки программно
изменить значение этого свойства будут
безрезультатны. Свойства - это контейнеры,
которые содержат другие объекты,
примитивные значения и методы. Примитивное
значение - это элемент любого из встроенных
типов: Undefined,
Null,
Boolean,
Number
и String;
объект - это элемент еще одного встроенного
типа Object;
метод - функция, ассоциированная с
объектом через свойство.</p>
<p>
JavaScript
содержит
несколько
встроенных
объектов,
таких,
как
Global, Object, Error, Function, Array, String, Boolean, Number,
Math, Date, RegExp. Кроме
того, JavaScript
содержит набор встроенных операций,
которые, строго говоря, не обязательно
являются функциями или методами, а такжн
набор встроенных операторов, управляющих
логикой выполнения программ. Синтаксис
JavaScript
в основном соответствует синтаксису
языка Java,
но упрощен в сравнении с ним, чтобы
сделать язык сценариев легким для
изучения. Так, к примеру, декларация
переменной не содержит ее типа, свойства
также не имеют типов, а декларация
функции может стоять в тексте программы
после ее вызова.</p>

<h3><a name="__RefHeading___Toc284672351"></a>Общие сведения об объектах</h3>

<p>Язык JavaScript, в отличие от языков Java и C++,
не содержит классов объектов в строгом
смысле слова. Вместо этого он поддерживает
конструкторы, которые создают объекты
путем выделения для них памяти и
инициализации всех или некоторых их
свойств. Все конструкторы являются
объектами, но не все объекты являются
конструкторами. Каждый конструктор
имеет свойство prototype,
которое используется для реализации
наследования, основанного на прототипах,
и разделяемых свойств. Объекты создаются
путем вызова конструктора в операции
new;
например new
String(&quot;Это
строка&quot;) создает новый объект String.
Результат вызова конструктора без new
зависит от конструктора. Так, String(&quot;Это
строка&quot;) создает примитивную строку,
а не объект.</p>
<p>
JavaScript
поддерживает наследование, основанное
на прототипах. С каждым конструктором
связан соответствующий прототип, и
каждый объект, созданный конструктором,
содержит неявную ссылку на этот прототип
(называемый прототипом объекта). Прототип,
в свою очередь, может содержать ссылку
на свой прототип и так далее. Так
образуется цепочка прототипов. Ссылка
на свойство объекта - это ссылка на
первый прототип в цепочке прототипов
объекта, который содержит свойство с
данным именем. Иными словами, если данный
объект имеет свойство с данным именем,
то используется ссылка на это свойство;
если нет, то исследуется прототип этого
объекта и т. д.</p>
<p>
В объектно-ориентированных
языках, основанных на классах объектов,
текущее состояние реализуется экземплярами
классов, методы реализуются классами,
а наследование - структурой и поведением.
В JavaScript
текущее состояние и методы реализуются
объектами, а структура и поведение
наследуются. Все объекты, которое явно
содержат свойство, которое содержит их
прототип, разделяют это свойство и его
значение. В отличие от языков, основанных
на классах, свойства могут динамически
добавляться к объектам путем присвоения
им значений. В частности, конструкторы
не обязаны присваивать значения всем
или некоторым свойствам создаваемого
объекта.</p>
<p>
<br>
</p>

<h3><a name="__RefHeading___Toc284672352"></a>Базовые определения</h3>

<p>После краткого описания языка JavaScript
дадим неформальные определения его основных понятий.</p>

<table>
<tr>
<td width="131">
<p>Тип</p>
</td>
<td width="478">
<p>Набор
значений данных.</p>
</td>
</tr>
<tr>
<td width="131">
<p>Примитивное
значение </p>
</td>
<td width="478">
<p>Элемент
одного
из
типов
Undefined, Null, Boolean, Number или
String. Примитивные
значения - это данные, которые
представляются непосредственно и на
самом нижнем уровне реализации языка.</p>
</td>
</tr>
<tr>
<td width="131">
<p>Объект</p>
</td>
<td width="478">
<p style="text-indent: 1.25cm">
Элемент типа
Object; является неупорядоченным набором
свойств, каждое из которых может быть
примитивным значением, объектом или
функцией. Свойство, являющееся функцией,
называется методом.</p>
</td>
</tr>
<tr>
<td width="131">
<p>Конструктор</p>
</td>
<td width="478">
<p>Функция,
которая создает и инициализирует
объекты. Каждый конструктор имеет
соответствующий прототип, который
используется для наследования и
разделения свойств.</p>
</td>
</tr>
<tr>
<td width="131">
<p>Прототип</p>
</td>
<td width="478">
<p>Объект,
который используется в JavaScript для
реализации наследования структуры,
состояния и поведения. Когда конструктор
создает объект, последний содержит
неявную ссылку на прототип конструктора,
позволяющий разрешать ссылки на
свойства данного объекта. Свойства
прототипа разделяются всеми объектами,
созданными на его основе.</p>
</td>
</tr>
<tr>
<td width="131">
<p>Объект
языка</p>
</td>
<td width="478">
<p>Любой
объект, который поддерживается
реализацией языка JavaScript, а не средой
исполнения сценариев. Часть объектов
языка являются встроенными; другие
создаются в процессе выполнения
сценария.</p>
</td>
</tr>
<tr>
<td width="131">
<p>Встроенный
объект</p>
</td>
<td width="478">
<p style="text-indent: 1.25cm">
Любой объект,
который поддерживается реализацией
языка JavaScript независимо от среды
исполнения и существующий на момент
начала исполнения сценария. Все
встроенные объекты являются объектами
языка.</p>
</td>
</tr>
<tr>
<td width="131">
<p>Объект
среды</p>
</td>
<td width="478">
<p>Любой
объект, который не является объектом
языка, а поддерживается средой
исполнения сценариев.</p>
</td>
</tr>
<tr>
<td width="131">
<p>Неопределенное
значение</p>
</td>
<td width="478">
<p>Примитивное
значение, которое означает, что
переменной не присвоено никакого
значения.</p>
</td>
</tr>
<tr>
<td width="131">
<p>Тип
Undefined</p>
</td>
<td width="478">
<p>Этот
тип состоит из единственного значения
undefined, которое является неопределенным.</p>
</td>
</tr>
<tr>
<td width="131">
<p>Нулевое
значение</p>
</td>
<td width="478">
<p>Примитивное
значение, которое означает нулевую,
пустую или несуществующую ссылку.</p>
</td>
</tr>
<tr>
<td width="131">
<p>Тип
Null</p>
</td>
<td width="478">
<p>Этот
тип состоит из единственного значения
null, которое является нулевым.</p>
</td>
</tr>
<tr>
<td width="131">
<p>Логическое
значение</p>
</td>
<td width="478">
<p>Примитивное
значение типа Boolean, означающее истину
или ложь.</p>
</td>
</tr>
<tr>
<td width="131">
<p>Тип
Boolean</p>
</td>
<td width="478">
<p>Тип,
состоящий ровно из двух значений: true
(истина) и false (ложь).</p>
</td>
</tr>
<tr>
<td width="131">
<p>Логический
объект</p>
</td>
<td width="478">
<p>Элемент
типа Object, который является экземпляром
встроенного логического объекта.
Иными словами, логический объект
создается выражением new Boolean(value), где
value - логическое значение. Результирующий
объект имеет неявное (безымянное)
свойство типа Boolean.</p>
</td>
</tr>
<tr>
<td width="131">
<p>Строковое
значение</p>
</td>
<td width="478">
<p>Элемент
типа String. Предсталяет собой строку
символов, т . е. упорядоченный массив
из нуля или более символов Unicode (т. е.
16-битовых целых чисел без знака).</p>
</td>
</tr>
<tr>
<td width="131">
<p>Тип
String</p>
</td>
<td width="478">
<p>Этот
тип состоит из всех возможных строковых
значений.</p>
</td>
</tr>
<tr>
<td width="131">
<p>Строковый
объект</p>
</td>
<td width="478">
<p>Элемент
типа Object, который является экземпляром
встроенного строкового объекта. Иными
словами, строковый объект создается
выражением new String(value), где value - строковое
значение. Результирующий объект имеет
неявное (безымянное) свойство типа
String.</p>
</td>
</tr>
<tr>
<td width="131">
<p>Числовое
значение</p>
</td>
<td width="478">
<p>Элемент
типа Number. Является непосредственным
представлением числа.</p>
</td>
</tr>
<tr>
<td width="131">
<p>Тип
Number</p>
</td>
<td width="478">
<p>Тип,
состоящий из всех возможных числовых
значений. Точнее говоря, это набор
64-битовых числовых значений формата
IEEE 754, включающий специальные значения
NaN (не число), положительная бесконечность
и отрицательная бесконечность.</p>
</td>
</tr>
<tr>
<td width="131">
<p>Числовой
объект</p>
</td>
<td width="478">
<p>Элемент
типа Object, который является экземпляром
встроенного числового объекта. Иными
словами, числовой объект создается
выражением new Number(value), где value - числовое
значение. Результирующий объект имеет
неявное (безымянное) свойство типа
Number.</p>
</td>
</tr>
<tr>
<td width="131">
<p>Бесконечность</p>
</td>
<td width="478">
<p>Примитивное
значение Infinity, являющееся элементом
типа Number.</p>
</td>
</tr>
<tr>
<td width="131">
<p>NaN</p>
</td>
<td width="478">
<p>Примитивное
значение NaN (не число), являющееся
элементом типа Number.</p>
</td>
</tr>
</table>
<p>
<br>
</p>
<h3><a name="__RefHeading___Toc284672353"></a>
Размещение
кода JavaScript
на HTML-странице</h3>

<p>
Выполнение программы
зависит от того, когда и как интерпретатор
получает управление. Что, в свою очередь,
зависит от функционального применения
кода. В общем случае можно выделить
четыре способа функционального применения
JavaScript:</p>

<ul>
<li><p>гипертекстовая ссылка (схема URL);</p>
<li><p>обработчик события (в атрибутах, отвечающих событиям);</p>
<li><p>подстановка (entity);</p>
<li><p>вставка (контейнер &lt;SCRIPT&gt;).</p>
</ul>

<h3><a name="__RefHeading___Toc284672354"></a>Объекты, методы и свойства</h3>

<h4 class="western"><a name="__RefHeading___Toc284672355"></a>Объекты</h4>

<p>Объект (object) - это какой-либо предмет. Подобно тому,
как в реальном мире все одушевленные и
неодушевленные предметы являются
объектами (машины, собаки и пр.), объектами
считаются и составляющие компьютерного
мира. 
</p>

<p>Что касается JavaScript, его объекты находятся внутри
браузера. Это, в частности, окно браузера,
формы и их части, например кнопки и
текстовые окна. В JavaScript также имеется
собственная группа встроенных объектов,
к которым относятся массивы, данные и
т.д. Сейчас вам не обязательно фиксировать
на этом внимание, поскольку все эти
объекты будут рассмотрены позже. Пока
вы должны усвоить лишь необходимые
определения. 
</p>
<p>Именно благодаря
наличию объектов язык JavaScript считается
объектно-ориентированным. Язык организован
вокруг объектов, а не действий, или,
иначе говоря, ориентирован на данные,
а не на логику. При объектно-ориентированном
программировании первоочередное
внимание уделяется объектам, с которыми
производятся некоторые манипуляции, а
не логическим правилам, необходимым
для таких манипуляций. Преимуществом
такого подхода является не только
облегчение программирования (или
написания сценария), но и в то, что каждое
действие можно выполнить разными
способами.</p>
<h4 class="western"><a name="__RefHeading___Toc284672356"></a>Методы</h4>

<p>Метод (method) - это
действия, которые может выполнять
объект. В реальном мире у объектов тоже
имеются какие-либо методы. Машины ездят,
собаки лают, доллар покупается и т.д. В
нашем случае alert() является методом
объекта Window, то есть объект Window может
выдавать пользователю какое-либо
предупреждение в окне сообщений.
Примерами других методов являются
открытие и закрытие окон, нажатие кнопок.
Здесь речь идет о трех методах: open(),
close() и click(). Обратите внимание на круглые
скобки. Они означают, что методы, в
отличие от свойств, используются.</p>

<h4 class="western"><a name="__RefHeading___Toc284672357"></a>Свойства</h4>

<p>У всех объектов
имеются свойства (properties). Если вы и далее
будете следовать аналогии с объектами
реального мира, то обнаружите, что все
предметы обладают какими-то свойствами:
у машин есть колеса, а у собаки - шерсть.
Что касается JavaScript, то у такого объекта,
как браузер, имеется название и номер
версии.</p>

<h2 style="font-style: normal; font-weight: normal"><a name="__RefHeading___Toc284672358"></a>XMLHTTP</h2>

<p>В интерактивности
- статические html сайты - это прошлое.
Динамические с использованием CGI (или
модулей сервера, например Apache) и баз
данных, когда сервер при отправки формы
формирует страницу и показывает ее
после обновления - чуть современней, но
все же во многих областях, где требуется
практически сопостовимая с десктопными
приложениями интерактивность - так же
угасают. На смену приходят интерактивные
функциональные программы, в полной мере
взаимодействующие с пользователем;
информация, полученная от сервера
практически мгновенно отображается на
экране без перезагрузке страницы. Речь
идет  об AJAX'e, что в расшифровке &quot;асинхронный
JavaScript и XML&quot; (термин ввел Джесс Гарретт).
А если более подробно, то - &quot;асинхронный
JavaScript + CSS + DOM + XMLHttpRequest&quot;.Рассмотрим
XMLHttpRequest.</p>
<p>
XMLHTTP
(XMLHttpRequest,
XHR)
— набор API,
используемый в языках JavaScript,
JScript,
VBScript
и им подобных для пересылки различных
данных (XML,
XHTML,
JSON
и т.д.) по HTTP-протоколу
между браузером и веб-сервером. Позволяет
осуществлять HTTP-запросы к удаленному
серверу без необходимости перезагружать
страницу.</p>
<p>
XMLHTTP является
важной составляющей технологии AJAX
(Asynchronous JavaScript And XML), используется многими
сайтами для создания динамичных, быстро
реагирующих на запросы пользователя
приложений. Например XMLHTTP используется
такими сайтами как Gmail, Google Suggest, MSN Virtual
Earth. XMLHTTP работает только с файлами,
находящимися на том же домене, что и
использующая XMLHTTP страница. Как и в
случае JavaScript, это сделано в целях
безопасности (cross-site scripting).</p>
<p>
Кроме пересылки
XML, через XMLHTTP можно обмениваться данными
формы и просто текстовыми строками.</p>
<h3><a name="__RefHeading___Toc284672359"></a>
История</h3>
<p>
<br>
</p>
<p>
Впервые был
реализован компанией Microsoft, появившись
в Internet Explorer 5.0 в виде объекта ActiveX,
доступного через JScript, VBScript, или другие
скриптовые языки, поддерживающиеся
браузером. Программисты проекта Mozilla
затем разработали совместимую версию,
называющуюся XMLHttpRequest в Mozilla 1.0. В дальнейшем
эта возможность также была реализована
компаниями Apple начиная с Safari 1.2, родственным
браузером Konqueror, компанией Opera Software
начиная с Opera 8.01, и, вероятно, другими.</p>

<h3><a name="__RefHeading___Toc284672360"></a>Методы класса XMLHttpRequest</h3>

<table>
<tr>
<td>
<p>Метод</p>
</td>
<td>
<p>Описание</p>
</td>
</tr>
<tr>
<td>
<ol>
<li><p>abort()</p>
</ol>
</td>
<td>
<p>Отменяет
текущий запрос, удаляет все заголовки,
ставит текст ответа сервера в null.</p>
</td>
</tr>
<tr>
<td>
<ol start="2">
<li><p>getAllResponseHeaders()</p>
</ol>
</td>
<td>
<p>
Возвращает полный
список HTTP-заголовков в виде строки.
Заголовки разделяются знаками пересноса
(CR+LF).</p>
<p>
Если флаг ошибки
равен true, возвращает пустую строку.</p>
<p>Если
статус 0 или 1, вызывает ошибку
INVALID_STATE_ERR.</p>
</td>
</tr>
<tr>
<td>
<ol start="3">
<li><p>getResponseHeader(headerName)</p>
</ol>
</td>
<td>
<p>
Возвращает
значение указанного заголовка.</p>
<p>
Если флаг ошибки
равен true, возвращает null.</p>
<p>
Если фзаголовок
не найден, возвращает null.</p>
<p>Если
статус 0 или 1, вызывает ошибку
INVALID_STATE_ERR.</p>
</td>
</tr>
<tr>
<td>
<ol start="4">
<li><p>open(method,
URL, async, userName, password)</p>
</ol>
</td>
<td>
<p>
Определяет метод,
URL
и другие опциональные параметры
запроса;</p>
<p>
параметр async
определяет, происходит ли работа в
асинхронном режиме.</p>
<p>Последние
три параметра необязательны.</p>
</td>
</tr>
<tr>
<td>
<ol start="5">
<li><p>send(content)</p>
</ol>
</td>
<td>
<p>Отправляет
запрос на сервер.</p>
</td>
</tr>
<tr>
<td>
<ol start="6">
<li><p>setRequestHeader(label,value)</p>
</ol>
</td>
<td>
<p>Добавляет HTTP-заголовок к запросу.</p>
</td>
</tr>
<tr>
<td>
<ol start="7">
<li><p>overrideMimeType(mimeType)</p>
</ol>
</td>
<td>
<p>
Позволяет указать
mime-type
документа, если сервер его не передал
или передал неправильно.</p>
<p>Внимание:
метод отсутствует в Internet
Explorer!</p>
</td>
</tr>
</table>

<h3><a name="__RefHeading___Toc284672361"></a>Свойства класса XMLHttpRequest</h3>

<table>
<tr>
<td>
<p>Свойство</p>
</td>
<td>
<p>Тип</p>
</td>
<td>
<p>Описание</p>
</td>
</tr>
<tr>
<td>
<p>onreadystatechange</p>
</td>
<td>
<p>EventListener</p>
</td>
<td>
<p>Обработчик
события, которое происходит при каждой
смене состояния объекта. Имя должно
быть записано в нижнем регистре.</p>
</td>
</tr>
<tr>
<td>
<p>readyState</p>
</td>
<td>
<p>unsigned
short</p>
</td>
<td>
<p>Текущее
состояние объекта (0 — не инициализирован,
1 — открыт, 2 — отправка данных, 3 —
получение данных и 4 — данные загружены)</p>
</td>
</tr>
<tr>
<td>
<p>responseText</p>
</td>
<td>
<p>DOMString</p>
</td>
<td>
<p>
Текст ответа на
запрос.</p>
<p>Если
статус не 3 или 4, возвращает пустую
строку.</p>
</td>
</tr>
<tr>
<td>
<p>responseXML</p>
</td>
<td>
<p>Document</p>
</td>
<td>
<p>
Текст ответа на
запрос в виде XML, который затем может
быть обработан посредством DOM.</p>
<p>Если
статус не 4, возвращает null.</p>
</td>
</tr>
<tr>
<td>
<p>status</p>
</td>
<td>
<p>unsigned
short</p>
</td>
<td>
<p>HTTP-статус в виде числа (404 — «Not Found», 200 — «OK» и т. д.)</p>
</td>
</tr>
<tr>
<td>
<p>statusText</p>
</td>
<td>
<p>DOMString</p>
</td>
<td>
<p>
Статус в виде
строки («Not Found», «OK» и т. д.).</p>
<p>Если
статус не распознан, браузер пользователя
должен вызвать ошибку INVALID_STATE_ERR.</p>
</td>
</tr>
</table>
<p>
<br>
</p>
<h3><a name="__RefHeading___Toc284672362"></a>
Ошибки, вызываемые
классом XMLHttpRequest</h3>
<ul>
<li><p>
SECURITY_ERR-вызывается
при попытке совершить запрос, запрещённый
настройками безопасности в браузере
пользователя.</p>
<li><p>
NETWORK_ERR-вызывается
при ошибке сети (во время синхронного
запроса).</p>
<li><p>
ABORT_ERR-вызывается
при прерывании пользователем запроса
(во время синхронного запроса).</p>
</ul>
<p>
<br>
</p>
<h3><a name="__RefHeading___Toc284672363"></a>Пример использования</h3>

<p>План работы с объектом XMLHttpRequest можно представить следующим образом:</p>
<p>Создание экземпляра объекта XMLHttpRequest</p>
<p>
Установка обработчика
события</p>
<p>
Открытие соединения
и отправка запроса.</p>
<p>
Создание экземпляра
объекта XMLHttpRequest.</p>
<p>
На этой стадии
необходима отдельная реализация для
разных браузеров. Конструкция создания
объекта отличается: в IE 5 - IE 6 она
реализована через ActiveXObject, а в остальных
браузерах (IE 7, Mozilla, Opera, Netscape и Safari) — как
встроенный объект типа XMLHttpRequest.</p>
<p>
Вызов для ранних
версий Internet Explorer выглядит так:</p>
<p>
var req = new
ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);</p>
<p>
В более поздних
версиях Internet Explorer (до IE7) рекомендуется
использовать:</p>
<p>
var req = new
ActiveXObject(&quot;Msxml2.XMLHTTP&quot;);</p>
<p>
В остальных
браузерах:</p>
<p>
var req = new
XMLHttpRequest();</p>
<p>
То есть, для
обеспечения кросс-браузерности кода,
нужно лишь проверять наличие объектов
window.XMLHttpRequest и window.ActiveXObject, и, в зависимости
от того, какой есть, тот и применять.</p>
<p>
<br>
</p>
<p>
В качестве
универсального решения предлагается
использование такой функции:</p>
<p>
function createRequestObject()</p>
<p>
{</p>
<p>
    if (window.XMLHttpRequest)
{</p>
<p>
        try {</p>
<p>
            return new
XMLHttpRequest();</p>
<p>
        } catch (e){}</p>
<p>
    } else if
(window.ActiveXObject) {</p>
<p>
        try {</p>
<p>
            return new
ActiveXObject('Msxml2.XMLHTTP');</p>
<p>
        } catch (e){</p>
<p>
          try {</p>
<p>
              return new
ActiveXObject('Microsoft.XMLHTTP');</p>
<p>
          } catch (e){}</p>
<p>
        }</p>
<p>
    }</p>
<p>
    return null;</p>
<p>
}</p>
<p>
Установка обработчика
событий, открытие соединения и отправка
запросов</p>
<p>
<br>
</p>
<p>
Эти
вызовы
выглядят
так:</p>
<p>
req.onreadystatechange =
processReqChange;</p>
<p>
req.open(&lt;&quot;GET&quot;|&quot;POST&quot;|...&gt;,
&lt;url&gt;, &lt;asyncFlag&gt;);</p>
<p>
<br>
</p>
<p>
После определения
всех параметров запроса его остается
только отправить. Делается это функцией
send(). Если необходимо передать на сервер
POST-данные, их надо подставить в качестве
параметра для этой функции. POST-данные
должны быть свернуты в URL-escaped строку
(кодировка UTF-8) и добавлен заголовок
req.setRequestHeader (&quot;Content-Type&quot;,
&quot;application/x-www-form-urlencoded&quot;);. Другими
словами эта строка будет иметь вид,
который мы привыкли видеть в командной
строке браузера, при передаче данных
методом GET. При отправке GET-запроса для
версии без ActiveX необходимо указать
параметр null, в остальных случаях можно
не указывать никаких параметров. Не
будет ошибкой, если для GET всегда будет
указан параметр null:</p>
<p>
req.send(null);</p>
<p>
После этого начинает
работать вышеуказанный обработчик
событий. Он — фактически основная часть
программы. В обработчике обычно происходит
перехват всех возможных кодов состояния
запроса и вызов соответствующих действий,
а также перехват возможных ошибок.
Пример кода с этими двумя функциями:</p>


<p>
var req;</p>
<p>
 
</p>
<p>
function loadXMLDoc(url)</p>
<p>
{</p>
<p>
    req = null;</p>
<p>
    if (window.XMLHttpRequest)
{</p>
<p>
        try {</p>
<p>
            req = new
XMLHttpRequest();</p>
<p>
        } catch (e){}</p>
<p>
    } else if
(window.ActiveXObject) {</p>
<p>
        try {</p>
<p>
            req = new
ActiveXObject('Msxml2.XMLHTTP');</p>
<p>
        } catch (e){</p>
<p>
            try {</p>
<p>
                req = new
ActiveXObject('Microsoft.XMLHTTP');</p>
<p>
            } catch (e){}</p>
<p>
        }</p>
<p>
    }</p>
<p>
 
</p>
<p>
    if (req) {</p>
<p>
        req.onreadystatechange
= processReqChange;</p>
<p>
        req.open(&quot;GET&quot;,
url, true);</p>
<p>
        req.send(null);</p>
<p>
    }</p>
<p>
}</p>
<p>
 
</p>
<p>
function processReqChange()</p>
<p>
{</p>
<p>
  try
{ // Важно!</p>
<p>
    // только при
состоянии &quot;complete&quot;</p>
<p>
    if
(req.readyState == 4) {</p>
<p>
        //
для
статуса
&quot;OK&quot;</p>
<p>
        if
(req.status == 200) {</p>
<p>
            //
обработка
ответа</p>
<p>
        }
else {</p>
<p>
            alert(&quot;Не
удалось получить данные:\n&quot; +</p>
<p>
                req.statusText);</p>
<p>
        }</p>
<p>
    }</p>
<p>
  }</p>
<p>
  catch( e ) {</p>
<p>
      // alert('Caught
Exception: ' + e.description);</p>
<p>
      // В связи с
багом XMLHttpRequest в Firefox приходится отлавливать
ошибку</p>
<p>
      //
Bugzilla Bug 238559 XMLHttpRequest needs a way to report networking
errors</p>
<p>
      //
https://bugzilla.mozilla.org/show_bug.cgi?id=238559</p>
<p>
  }</p>
<p>
}</p>

</body>
</html>
