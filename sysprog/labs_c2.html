<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8">
<meta http-equiv="content-type" content="text/html; charset=utf-8"/>
<meta name="description" content="Системное программирование, лабораторные работы"/>
<meta name="viewport" content="width=device-width"/>
<link rel="stylesheet" href="/styles.css" type="text/css">
<title>Задания лабораторных работ</title>
</head>
<body>

<h1>Задания лабораторных работ по дисциплине <q>Системное программирование</q></h1>
<p>Цель - знакомство с принципами работы Windows API.
<p>Среда разработки курсовой работы - любой компилятор C/C++ для ОС Windows версии 2000 года или позже.
Рекомендуется: <dfn>bcc32</dfn> (компилятор Borland для командной строки).
 
<ol><dfn>Список лабораторных работ.</dfn>

<li>Написать программу, которая перекодирует входной текстовый файл,
содержащий английские, русские и украинские буквы в кодировке <dfn>Windows-1251</dfn>,
и прочие символы, в html-файл, содержащий текстовое представление UNICODE-кодировки символов.
Например символ апострофа <dfn>&#39;</dfn> должен быть выведен в новый файл как <dfn>&amp#39;</dfn>
потому что его UNICODE значение 39, а русская буква <dfn>&#1072;</dfn> будет представлена как <dfn>&amp#1072;</dfn>.
При просмотре полученной html-страницы результат не должен зависеть от настроек кодировки клиента.
Символы из набора ASCII (коды 0 - 127), кроме апострофа и кавычек <dfn>не</dfn> перекодировать.
Использовать функцию <dfn>MultiByteToWideChar</dfn>.

<li>Написать две программы: главную и дочернюю.
Главная программа должна запускать дочернюю и ожидать ее завершения.
Использовать функции <dfn>CreateProcess</dfn> и <dfn>WaitForSingleObject</dfn>.

<li>Написать программу, главный поток которой запускает несколько дополнительных потоков.
Реализовать обмен сообщениями между главным и побочными потоками с помощью передачи сообщений.
Использовать функции <dfn>CreateThread</dfn>, <dfn>PostThreadMessage</dfn>, <dfn>GetMessage</dfn>.
Как минимум, вторичные потоки должны с помощью сообщений уведомлять главный поток
о своей готовности к работе и о завершении своего выполнения.

<li>Написать программу, главный поток которой запускает несколько дополнительных потоков.
Реализовать критическую секцию кода, которую все потоки проходят строго последовательно и поочередно.
Использовать функции <dfn>CreateThread</dfn>, <dfn>InitializeCriticalSection</dfn>,
<dfn>DeleteCriticalSection</dfn>, <dfn>EnterCriticalSection</dfn>, <dfn>LeaveCriticalSection</dfn>.
Как минимум, в критическую секцию кода нужно поместить печать сообщения -
какой поток зашел в критическую секцию и подсчет числа посещений этой секции кода.

<li>Написать две программы: исполняемая программа (<dfn>exe</dfn>) и динамическую библиотеку (<dfn>dll</dfn>).
В динамической библиотеке реализовать хотя бы одну экспортируемую функцию.
Можно использовать или директивы компилятора <dfn>__declspec</dfn>,
или файлы компоновщика для определения модуля <dfn>*.def</dfn>.
В исполняемой программе нужно статически (или динамически) импортировать
функцию-пример из <dfn>dll</dfn> и вызвать ее. Дополнительное требование: экспорт/импорт функций
не должен зависеть от применяемого компилятором декорирования имен (name mangling),
чтобы функции вашей DLL могли использовать программы,
написанные на других языках (или созданные другими компиляторами).

<li>Написать программу, главный поток которой запускает несколько дополнительных потоков.
Реализовать собственный слот <dfn>TLS</dfn> для работы с приватной памятью потока.
Использовать функции <dfn>TlsAlloc</dfn>, <dfn>TlsFree</dfn>, <dfn>TlsGetValue</dfn>, <dfn>TlsSetValue</dfn>.
Как минимум, главный поток должен порождать/уничтожать слот TLS,
а все потоки (и главный в том числе) - помещать и извлекать данные из слота TLS.
Программа должна убедительно демонстрировать, что данные, помещаемые в слот TLS,
а затем извлекаемые из него, уникальны для конкретного потока и не пересекаются
с данными других потоков (используйте, например, идентификаторы потоков).

<li>Написать программу, которая: резервирует диапазон виртуальных адресов размером 200 MB,
выделяет из этого диапазона блок адресов размером 8 MB, которому выделяется физическая память,
производит запись данных в этот блок и затем запрещает запись.
Программа должна убедительно демонстрировать, что в адресном пространстве процесса появился 
диапазон адресов размером 200 MB, а в нем блок размером 8 MB, закрытый для записи.
Для этого использовать функцию <dfn>VirtualQuery</dfn>. Затем программа освобождает физическую память и
освобождает резервирование адресного диапазона.
Использовать функции <dfn>VirtualAlloc</dfn>, <dfn>VirtualProtect</dfn>, <dfn>VirtualFree</dfn>.

<li>Написать две программы.
Первая программа создает проекцию файла в памяти и выделяет для нее блок адресов размером 8 MB.
Вторая программа подключается к уже существующей проекции, записывает в нее данные,
и отключается от проекции.
Первая программа читает данные из проекции, выводит их на печать, закрывает проекцию.
Использовать функции <dfn>CreateFileMapping</dfn>, <dfn>OpenFileMapping</dfn>,
<dfn>MapViewOfFile</dfn>, <dfn>UnmapViewOfFile</dfn>, <dfn>CloseHandle</dfn>.
Должно быть убедительно продемонстрировано, что второй программе удалось
записать данные в блок разделяемой памяти, и что первая программа получила эти данные.

</ol>

<p>Архив с <a href='sysprex.zip'>примерами</a> использования (необходимо приспособить (переделать) для своих целей).

</body>
</html>
