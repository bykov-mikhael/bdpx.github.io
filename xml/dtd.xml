<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="ru">
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8"/>
<meta name="description" content="Технологии XML: DTD"/>
<meta name="viewport" content="width=device-width"/>
<link rel="stylesheet" href="/styles.css" type="text/css" />
<title>Определение типа документа - DTD</title>
</head>
<body>

<h1>Определение структуры и типа документа: Document Type Definition (DTD)</h1>

<p>Цель лабораторной работы:</p>
<ol>
<li>Познакомиться DTD определениями типа XML документов.</li>
<li>Научиться описывать структуру XML документов.</li>
</ol>

<h1>Определение типа документа - DTD</h1>

<p>
Документ считается действительным, если включает определение типа документа (document type definition, DTD) или XML-схему (XSD),
причем сам документ не противоречит этой схеме (определению DTD). Определение DTD (схема документа) задает корректный синтаксис. 
</p>

<p>Можно сказать, что XML документы состоят из элементов и атрибутов.
В DTD описываются и некоторые другие объекты, опредеделения которых смотрите ниже, но документы всегда
поддерживают эти две основные концепции.</p>

<p>По отношению к документу DTD могут быть <dfn>внутренние</dfn> и <dfn>внешние</dfn>.
Внутренние DTD описываются в непосредственно в файле XML документа вот так:</p>

<div class="lang-xml"><![CDATA[
<?xml version="1.0" ?>
<!DOCTYPE queue [
        ...
]>
<queue>
<message to="aaa@bbb.cc" from="ccc@bbb.aa" subj="subject of ...">
       Text of mail message ...
          ...
</message>
]]></div>

<p>Строка &lt;!<b>DOCTYPE</b> queue [ называется <dfn>определением типа документа</dfn>. За ключевым словом <dfn>DOCTYPE</dfn> должно следовать имя корневого элемента XML документа (в примере - <b>queue</b>).
    Далее, в квадратных скобках следует список <dfn>элементов</dfn>, <dfn>атрибутов</dfn> и <dfn>сущностей</dfn> - именно из этих компонентов состоит XML документ. Заканчивает
    DTD последовательность ]&gt;. </p>
  <p>DTD может также
    располагаться и во внешнем файле. Внешние DTD делятся на системные (SYSTEM) и
    общедоступные (PUBLIC). В любом случае файл DTD должен иметь расширение <dfn>.dtd</dfn>.
    Связывание системного DTD и XML документа выглядит следующим образом: </p>

<div class="lang-xml"><![CDATA[
<?xml version="1.0" ?>
<!DOCTYPE queue SYSTEM "./dtd/msg_queue.dtd">
 
<queue>
        ...
</queue>
]]></div>

<p>В данном случае анализатору указывается, что DTD находится во внешнем файле, по адресу <q>./dtd/msg_queue.dtd</q>.
</p>
<p>Существует ряд общеизвестных DTD, как разновидность внешних, разработанных для определенных целей.
В случае использования такого DTD его объявление будет иметь несколько другой вид:</p>

<div class="lang-xml"><![CDATA[
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
 "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd" >
]]></div>

<p>На то, что DTD является общеизвестным, указывает ключевое слово <dfn>PUBLIC</dfn>.
Рассмотрим поподробнее строку <q>-//W3C//DTD XHTML 1.1//EN</q>.
Если DTD является стандартом ISO, то данная строка начинается словом ISO.
Если DTD не является стандартом ISO, но используемый стандарт был принят группой стандартизации, то DTD начинается со знака (+).
Если же но не был принят официально группой стандартизации, то объявление следует начинать со знака (-).
Далее, с разделителем (//) следуют владелец данного DTD, имя DTD и язык.
Из приведенного примера видно, что используется DTD, не стандартизованное официально,
принадлежащее компании <dfn>W3C</dfn>, с именем <dfn>XHTML 1.1</dfn>.
</p>

<p>Приведем несколько доводов в пользу внешних DTD:</p>
<ul>
<li>Внешние DTD могут быть общеизвестными (public).</li>
<li>Внешние DTD позволяют отделить структуру от содержания. Вы можете изменить и расширить правила словаря, не открывая содержания XML документов.</li>
<li>Можно однажды написанное DTD использовать во множестве документов.</li>
</ul>

<p>Далее в уроке подробно рассматриваются элементы DTD.</p>

<h2>Сущности</h2>

<p>В языке XML есть возможность продекларировать фрагменты содержания, а затем ссылаться на них при
    необходимости, что позволяет сэкономить время и силы разработчикам.
    Объявляя сущность в DTD мы определяем ее имя и содержание, на которое она ссылается.
    Ссылаясь на сущность, мы заставляем анализатор заменить ссылку на содержимое сущности. Сущности бывают</p>
  <ul>
    <li><dfn>анализируемыми</dfn> (parsed entity) - содержимое сущности анализируется, т.е, например, при встрече в нем ссылок на другие
      сущности, они так же замещаются их содержимым; разметка внутри таких сущностей так же интерпретируется.</li>
    <li><dfn>неанализируемыми</dfn> (unparsed entity) - это не обязательно текст в XML формате, или совсем не текст (графика или другое мультимедиа содержание).</li>
  </ul>

<p>Ниже приведен пример
    объявления и использования анализируемых сущностей <b>author</b> и <b>copyright</b><i>
    (обратите внимание: сущность <b>copyright</b> ссылается на <b>author</b>)</i>:</p>

<div class="lang-xml"><![CDATA[
<?xml version="1.0"?>
<!DOCTYPE lesson [
    <!ENTITY author "Иванов Иван Иванович">
    <!ENTITY copyright "2023, Odessa, &author;">
]>

<lesson>
    <theme>Document Type Definition - DTD</theme>
    <author> &author; </author>
    В данном уроке мы с вами рассмотрим ...
    ...
    <copyright> &copyright; </copyright>
</lesson>
]]></div>

<p>Строка &lt;!<b>ENTITY</b> author &quot;Иванов Иван Иванович&quot;&gt;
объявляет сущность author со значением <q>Иванов Иван Иванович</q>.
Ссылка на сущность выглядит как символьная подстановка в HTML: <i>&amp;author;</i>.
При разборе документа анализатор встретит ссылку на сущность и заменит ее на значение сущности.
В итоге документ примет следующий вид:
</p>

<div class="lang-xml"><![CDATA[
<?xml version="1.0"?>
<!DOCTYPE lesson [
    <!ENTITY author "Иванов Иван Иванович">
    <!ENTITY copyright "2023, Odessa, &author;">
]>
 
<lesson>
        <theme>Document Type Definition - DTD</theme>
        
        <author>Иванов Иван Иванович</author>
        В данном уроке мы с вами рассмотрим ...
        ...
        <copyright>2023, Odessa, Иванов Иван Иванович</copyright>
</lesson>
]]></div>

<p>Из приведенного рисунка видно, что ссылка на сущность <i>&amp;author;</i> была замененна ее содержимым <q>Иванов Иван Иванович</q>, причем и в
    <q>теле</q> другой сущности - <i>&amp;copyright;</i>. Анализируемые сущности могут также содержать и разметку.</p>

<h3>Внешние сущности</h3>

<p>Текст замещения может содержаться во внешнем файле, тогда объявление сущности будет выглядеть так:</p>

<div class="lang-xml"><![CDATA[<!DOCTYPE doc [
  <!ENTITY license SYSTEM "./files/license.txt"
  ...
]>

<license>
    &license;
</license>
]]></div>

<p>Вместо ключевого слова <dfn>SYSTEM</dfn> может быть использованно слово <dfn>PUBLIC</dfn>, в случае, если речь идет об
    общедоступной сущности (см. системные и общедоступные DTD).
 </p>

<p>В XML существует ряд предопределенных сущностей, служащих для преодоления ограничений, связанных с
    синтаксисом языка. Перечень их приведен в таблице ниже:</p>

<table>
      <tr>
        <th>Символ</th>
        <th>Ссылка на сущность</th>
      </tr>
      <tr>
        <td>&gt;</td>
        <td>&amp;lt;</td>
      </tr>
      <tr>
        <td>&lt;</td>
        <td>&amp;gt;</td>
      </tr>
      <tr>
        <td>&amp;</td>
        <td>&amp;amp;</td>
      </tr>
      <tr>
        <td>&quot;</td>
        <td>&amp;quot;</td>
      </tr>
      <tr>
        <td>' (апостроф)</td>
        <td>&amp;apos;</td>
      </tr>
</table>

<p>Таким образом, для вывода текста </p>
  <pre>if ((a &lt; b)&amp;&amp;(с &gt; 150)) { ... }</pre>
  <p>нужно использовать следующий код:</p>
  <pre>if ((a <i>&amp;lt;</i> b)<i>&amp;amp;&amp;amp;</i>(с <i>&amp;gt;</i> 150)) { ... }</pre>
  <p>Кроме того, на любой
    символ можно сослаться по его коду в таблице символов. Например, символу '&lt;'
    соответствует ссылка '<b><i>&amp;#60</i></b>' (десятичный код) или '<b><i>&amp;#x3C</i></b>'
    (16ричный код);</p>

<h3>Параметрические сущности</h3>

<p>Данный подвид сущностей
    относится к анализируемым и предназначен для использования строго внутри DTD.
    Они дают возможность ссылаться на часто встречающиеся в DTD конструкции, что
    впоследствии позволяет их быстро редактировать. Для объявления таких сущностей
    испольхуется ключевое слово <b>ENTITY</b>, знак %, имя и значение сущности.</p>

<div class="lang-xml"><![CDATA[
<!ENTITY % peopleParams
   "name CDATA #REQUIRED age CDATA #IMPLIED country CDATA #REQUIRED">
]]></div>

<p>Демонстрация ссылки на
    такого рода сущность потребует знаний других элементов DTD, поэтому их описание
    приведено ниже.</p>

<h3>Неанализируемые сущности и нотации</h3>

<p>Нотации (<b>NOTATION</b>)
    описывают содержание, разработанное не на языке XML. Используются они для того,
    чтобы объявить конкретный класс данных и связать его с внешней программой. Эта
    внешняя программа становится обработчиком объявленного класса данных. Например,
    связав с документом изобржение в формате <b>JPEG</b>, разработчик желает, чтобы
    программа приняла и визуализировала двоичные данные в этом формате. Ниже
    представлены примеры объявления нотаций: </p>

<div class="lang-xml"><![CDATA[
<!NOTATION doc  SYSTEM "winword.exe">
<!NOTATION jpeg SYSTEM "c:\Program Files\ACDSee\acdsee.exe">
]]></div>

<p>Где же используются нотации? Например, для объявления двоичных сущностей:
</p>

<div class="lang-xml"><![CDATA[
<!ENTITY photo SYSTEM "images/myphoto.jpg" NDATA jpeg>
]]></div>

<p>На то, что сущность является неанализируемой, двоичной указывает ключевое слово <b>NDATA</b> - <i>notation data, данные нотации</i>, за которым следует имя объявленной ранее нотации.
</p>

<h2>Элементы</h2>

<p>&quot;Сердцем и душой&quot; документа XML является элемент. В DTD типы элементы объявляются при
    помощи ключевого слова <b>ELEMENT</b>:</p>

<div class="lang-xml"><![CDATA[
<!ELEMENT message (#PCDATA)>
...
]]></div>

<p>За ключевым словом <b>ELEMENT</b> должно следовать имя элемента (message), затем, спецификация содержания (<b>#PCDATA</b> - анализируемые символьные данные). Существуют следующие варианты описания
    содержания элементов: </p>

<ul>
    <li><b>EMPTY</b></li>
    <li><b>ANY</b></li>
    <li><b>(#PCDATA)</b></li>
    <li><b>(модель содержания)</b></li>
</ul>

<h3>EMPTY</h3>

<p>При помощи ключевого слова <b>EMPTY</b> описываются элементы с пустым содержанием. Такие элементы не могут
    содержать текст или порожденные (дочерние) элементы, но могут иметь атрибуты.
    Например:</p>

<div class="lang-xml"><![CDATA[
<!ELEMENT logo EMPTY>
...
<logo src="./images/logo.gif" address="http://company.com"/>
]]></div>

<p>Подобные элементы наверняка встречались вам и ранее в курсе HTML. Например:</p>

<div class="lang-xml"><![CDATA[
<br />
<img src="./images/logo.gif" />
]]></div>

<h3>#PCDATA - анализируемые символьные данные</h3>

<p>Такая спецификация содержания элемента указывает на то, что элемент может содержать только текст
    (возможно, со ссылками на сущности - это и делает его анализируемым...). В
    содержимом таких элементов недопустимо использование других элементов:</p>

<div class="lang-xml"><![CDATA[
<!ELEMENT author (#PCDATA)>
...
<!-- корректная конструкция -->
<author>Автор: &author;</author>
<!-- некорректная конструкция (содержит элемент <b>) -->
<author><b>Автор:</b> &author;</author>
]]></div>

<h3>ANY</h3>
<p>Данный тип содержания полностью соответствует значению слова: ANY - любой.
Элемент может содержать анализируемые текстовые данные (#PCDATA) вперемешку с дочерними элементами.
Например:</p>

<div class="lang-xml"><![CDATA[
<!ELEMENT lesson ANY>
...
<lesson>
    Название: <title>Использование DTD</title>
    Автор: <author>&author;</author>
    ...
]]></div>

<h3>Чисто элементное содержание</h3>

<p>Иногда возникает необходимость задать структуру элемента, содержащего некоторые дочерние
    элементы, более жестко, чем это позволяет тип <b>ANY</b>. В таком случае нам
    прийдется воспользоваться некоторыми спецсимволами для описания <b>модели
    содержания</b> элементов:</p>

<table>
<tr>
<th>Символ</th>
<th>Значение</th>
</tr>
<tr>
<td>|</td>
<td><p>Задает выбор одного варианта из нескольких возможных: </p>
          <div>
            <pre>&lt;!<b>ELEMENT</b> elem (<b>a|b|c</b>)&gt;</pre>
          </div>
          <p>означает, что описываемый элемент (<b>elem</b>) может содержать или элемент <b>a</b>,
            или элемент <b>b</b>, или элемент <b>c</b>. </p></td>
</tr>
<tr>
<td>,</td>
<td><p>Указывает, что перечисленные элементы должны следовать в заданном порядке: </p>
          <div>
            <pre>&lt;!<b>ELEMENT</b> elem (<b>a,b,c</b>)&gt;</pre>
          </div>
          <p>означает, что описываемый элемент содержит элемент <b>a</b>, затем элемент <b>b</b> и, наконец, элемент <b>c</b>. </p></td>
</tr>
<tr>
<td>?</td>
<td><p>Указывает, что перечисленные элементы необязательны, но, если присутствуют, должны использоваться только 1 раз: </p>
          <div>
            <pre>&lt;!<b>ELEMENT</b> elem (<b>a,(b|c)?</b>)&gt;</pre>
          </div>
          <p>означает, что описываемый элемент содержит элемент <b>a</b>, затем необязательный
            элемент <b>b</b> или необязательный элемент <b>c</b>. </p></td>
</tr>
<tr>
<td>*</td>
<td><p>Указывает, что перечисленные элементы могут повторяться неограниченное количество раз, или ни разу: </p>
          <div>
            <pre>&lt;!<b>ELEMENT</b> elem (<b>a*</b>)&gt;</pre>
          </div>
          <p>означает, что описываемый элемент может быть пустым, или содержать несколько элементов <b>a</b>. </p></td>
</tr>
<tr>
<td>+</td>
<td><p>Указывает, что перечисленные элементы могут повторяться неограниченное количество раз (минимум 1 раз): </p>
      <div>
        <pre>&lt;!<b>ELEMENT</b> elem (<b>a*</b>)&gt;</pre>
      </div>
      <p>означает, что описываемый элемент может содержать один или более элементов <b>a</b>. </p></td>
</tr>
<tr>
<td>()</td>
<td>Скобки служат, как вы уже наверное догадались, для группировки элементов.</td>
</tr>
</table>

<h3>Смешанное содержание</h3>

<p>Когда необходимо указать в качестве содержания элемента набор определенных дочерних элементов и символьных данных используют следующий подход:</p>
    
<div class="lang-xml"><![CDATA[<!DOCTYPE formated-text [
  <!ELEMENT strong    (#PCDATA)>
  <!ELEMENT emphasis  (#PCDATA)>
  <!ELEMENT title     (#PCDATA)>
  <!ELEMENT paragraph (#PCDATA|strong|emphasis)*>
  <!ELEMENT section   (title,paragraph+)>
]>
]]></div>

<p>Обратите внимание на описание элемента <b>paragrapg</b>:
он может содержать неограниченную (возможно, пустую) последовательность элементов <b>strong</b> или <b>emphasis</b> или символьные данные.
Ниже приводится пример применения этих элементов:</p>

<div class="lang-xml"><![CDATA[
<section>
  <title>Смешанное содержание</title>
    <paragraph>
      Как следует из самого названия, смешанное содержание 
      (<emphasis>mixed content</emphasis>) является сочетанием
      элементного содержания и символьных данных.
      ...
    </paragraph>
    ...
</section>
]]></div>

<h2>Атрибуты</h2>

<p>По существу, атрибуты
    обеспечивают дополнительную информацию об элементах XML и их содержании. Если
    элемент является пустым, то атрибуты несут дополнительное содержание. Если в
    элементе есть содержание, атрибуты, как правило, описывают его.</p>

<p>В DTD атрибуты описываются
    при помощи деклрации &quot;&lt;!<b>ATTLIST</b> &quot; (список атрибутов).
    Следом за ключевым словом <b>ATTLIST</b> следует имя элемента, к которому
    применяется список атрибутов, а затем 0 или более определений атрибутов. Каждое
    определение атрибута состоит из имени атрибута, его типа и характеристики:</p>

<div class="lang-xml"><![CDATA[<!ATTLIST элемент
    атрибут тип характеристика
    атрибут тип характеристика
    ... >]]></div>

<p>Значения характеристики атрибутов приведены в таблице ниже:</p>

<table>
<tr>
<th>Характеристика</th>
<th>Значение</th>
</tr>
<tr>
<td>#REQUIRED</td>
<td>Атрибут должен присутствовать в каждом экземпляре элемента в документе, является обязательным.</td>
</tr>
<tr>
<td>#IMPLIED</td>
<td>Атрибут может присутствовать, но необязателен.</td>
</tr>
<tr>
<td>#FIXED + значение по умолчанию</td>
<td>Атрибут всегда должен иметь только значение, предлагаемое по умолчанию; если атрибут
    не указан, значение по умолчанию все равно предполагается анализатором.</td>
</tr>
<tr>
<td>значение по умолчанию</td>
<td>Если атрибут не приведен, значение по умолчанию предполагается анализатором. Если
    атрибут имеется, у него может быть другое значение.</td>
</tr>
</table>

<p>В XML определено несколько типов для атрибутов.
По существу, атрибуты всегда имеют строковое значение, однако различают 3 категории типов атрибутов XML:
</p>
<ul>
<li>строковые атрибуты (string attributes) - произвольная строка</li>
<li>маркированные атрибуты (tokenized attributes) - строка определенного вида</li>
<li>перечислимые атрибуты (enumerated attributes) - список значений</li>
</ul>

<table>
<tr>
<th>Тип</th>
<th>Категория</th>
<th>Значение</th>
</tr>
<tr>
<td>CDATA</td>
<td>строковый</td>
<td>Символьные данные (строка). Атрибуты данного типа могут принимать любое значение. </td>
</tr>
<tr>
<td>ID</td>
<td>маркированный</td>
<td>Имя, уникальное для данного документа. Значение атрибута данного типа всегда
должно быть корректным именем: начинаться с буквы или символа подчеркивания,
за которым следует последовательность 0 или более букв, цифр или знаков
подчеркивания. Если 2 или более элементов имеют одинаковый ID, документ
считается недействительным (invalid). </td>
</tr>
<tr>
<td>IDREF</td>
<td>маркированный</td>
<td>Ссылка на некоторый элемент, с атрибутом ID, который имеет то же значение, что и
атрибут IDREF. Если элемент с указанным ID в документе отсутствует, документ
считается недействительным. </td>
</tr>
<tr>
<td>IDREFS</td>
<td>маркированный</td>
<td>Несколько атрибутов IDREF, разделенных пустыми пространствами. </td>
</tr>
<tr>
<td>ENTITY</td>
<td>маркированный</td>
<td>Имя заранее определенной сущности. Если в DTD не определенна указанная сущность, документ считается недействительным </td>
</tr>
<tr>
<td>ENTITYES</td>
<td>маркированный</td>
<td>Несколько имен сущностей (ENTITY), разделенных пустыми пространствами. </td>
</tr>
<tr>
<td>NMTOKEN</td>
<td>маркированный</td>
<td>Имя. Данный атрибут, как и ID, должен быть корректным именем, но его уникальность не требуется. </td>
</tr>
<tr>
<td>NMTOKENS</td>
<td>маркированный</td>
<td>Неколько имен NMTOKEN, разделенных пустыми пространствами. </td>
</tr>
<tr>
<td>NOTATION</td>
<td>маркированный</td>
<td>Принимает одно из набора имен, указывающих на типы нотаций в определении DTD (см. ENTITY). </td>
</tr>
<tr>
<td>[список значений]</td>
<td>перечислимый</td>
<td>Принимает одно из серии значений, явным образом определенных пользователем.</td>
</tr>
</table>

<p>Давайте на примере проектирования DTD книжного кталога рассмотрим описание атрибутов в DTD. Пусть
    основными элементами книжного каталога являются <b>book</b> и <b>author</b>.
    Именно на их примере мы и рассмотрим описание атрибутов.</p>

<h3>CDATA</h3>
<p>Примером строкового атрибута может быть, например, название книги:</p>

<div class="lang-xml"><![CDATA[Описание в DTD:
<!DOCTYPE books [
    <!ELEMENT book EMPTY>
    <!ATTLIST book
        title CDATA #REQUIRED>
]>

<!-- Применение в XML: -->
<book title="XML для начинающих" />
]]></div>

<h3>ID</h3>

<p>Разовьем далее описание атрибутов элемента <b>book</b>.
Каждая книга в каталоге должна иметь уникальный код.
Это можно задать в DTD следующим образом:</p>

<div class="lang-xml"><![CDATA[
Описание в DTD:
<!DOCTYPE books [
    <!ELEMENT book EMPTY>
    <!ATTLIST book
        code  ID    #REQUIRED
        title CDATA #REQUIRED>
]>

<!-- Применение в XML: -->
<book title="XML для начинающих" code="BK_5676" />
]]></div>

<p>Теперь, если найдется две книги в каталоге, имеющие одинаковое значение атрибута <b>code</b>, документ будет недействительным.</p>

<h3>IDREF</h3>

<p>Теперь представим
    следующую ситуацию: авторы книг описываются отдельными элементами, каждый автор
    имеет уникальный идентификатор. В этом случае для связи книг с их авторами
    можно использовать атрибут типа <b>IDREF</b>:</p>
    
<div class="lang-xml"><![CDATA[Описание в DTD:
<!DOCTYPE books [
    <!ELEMENT author EMPTY>
    <!ELEMENT book EMPTY>
    <!ATTLIST author
        id     ID    #REQUIRED
        name   CDATA #REQUIRED
        email  CDATA #IMPLIED>
    <!ATTLIST book
        code   ID    #REQUIRED
        title  CDATA #REQUIRED
        author IDREF #REQUIRED>
]>

<!-- Применение в XML: -->

<author id="AV_5698" name="Иванов И.И." />
<author id="AV_7655" name="Петров П.П." />

<book code="BK_5676"
         title="XML для начинающих"
         author="AV_7655" />
]]></div>

<p>В данном примере у
    элемента <b>book</b> есть атрибут <b>author_id</b> типа <b>IDREF</b>, который
    может принимать значения, соответствующие существующему уникальному
    идентификатору автора. Обратите внимние: практически все атрибуты в примере
    объявленны с директивой <b>#REQUIRED</b> - обязательный, кроме атрибута <b>email</b> элемента <b>author</b> - он является необязательным - <b>#IMPLIED</b> (эта
    информация не критична, у автора может и не быть адреса электронной почты, или
    он по каким либо причинам отказался его предоставить).</p>

<h3>IDREFS</h3>

<p>В рассмотренном выше
    примере каждая книга может иметь только одного автора. Однакожизненый опыт
    показывает, что существует множество книг, написанных в соавторстве (2, 3 и
    более авторов). Как адаптировать наше DTD к такому случаю? Здесь целесообразно
    применить атрибут типа <b>IDREFS</b>, дающий возможность указать несколько ID,
    разделенных пустыми пространствами:</p>


<div class="lang-xml"><![CDATA[Описание в DTD:
<!DOCTYPE books [
    <!ELEMENT author EMPTY>
    <!ELEMENT book EMPTY>
    <!ATTLIST author
        id     ID    #REQUIRED
        name   CDATA #REQUIRED
        email  CDATA #IMPLIED> 
    <!ATTLIST book
        code      ID     #REQUIRED
        title     CDATA  #REQUIRED
        authors   IDREFS #REQUIRED>
]>

<!-- Применение в XML: -->
<author id="AV_5698" name="Иванов И.И." />
<author id="AV_9812" name="Сидоров В.П." />
<author id="AV_7655" name="Петров П.П." />

<book code="BK_5676"
         title="XML для начинающих"
         authors="AV_7655 AV_5698" />
<book code="BK_5677"
         title="XML для профессионалов"
         authors="AV_9898 AV_9812" />
]]></div>

<p>В данном примере ссылка на несуществующий ID автора AV_9898, делающая документ в целом недействительным.</p>

<h3>NMTOKEN</h3>

<p>Атрибут данного типа
    должен быть корректным именем. По синтаксису он единтичен ID, но не обязан быть
    уникальным в документе, или IDREF, но не должен ссылаться на действительный ID.
    В примере DTD книжного каталога это может быть название категории, к которой
    принадлежит книга (например: <b>markup</b> - разметка, <b>programming</b> -
    программирование и т.д.):</p>

<div class="lang-xml"><![CDATA[Описание в DTD:
<!DOCTYPE books [
    <!ELEMENT author EMPTY>
    <!ELEMENT book EMPTY>
     <!ATTLIST author
        id     ID    #REQUIRED
        name   CDATA #REQUIRED
        email  CDATA #IMPLIED> 
   <!ATTLIST book
        code      ID      #REQUIRED
        title     CDATA   #REQUIRED
        authors   IDREFS  #REQUIRED>
        category  NMTOKEN #REQUIRED>
]>

Применение в XML:
<author id="AV_5698" name="Иванов И.И." />
<author id="AV_9812" name="Сидоров В.П." />
<author id="AV_7655" name="Петров П.П." />
<author id="AV_6789" name="Горбачев М.С." />

<book code="BK_7644"
         title="Язык Разметки Гипертекста"
         category="markup"
         authors="AV_7655 AV_5698" />
<book code="BK_3245"
         title="C++ для профессионалов"
         category="programming"
         authors="AV_9812" />
<book code="BK_3245"
         title="Серверные сценарии - ASP"
         category="server side scripting"
         authors="AV_6789" />
]]></div>


<p>Ошибка, сделанная в примере: <q>server side scripting</q> не является корректным <b>именем</b> с точки зрения анализатора XML.</p>

<h3>Список значений</h3>

<p>Атрибуты данного типа принимают одно из указанного списка значений.
Переделаем наш пример так, чтобы категория, к которой принадлежит книга, была перечислимой:</p>

<div class="lang-xml"><![CDATA[Описание в DTD:
<!DOCTYPE books [
    <!ELEMENT author EMPTY>
    <!ELEMENT book EMPTY>
     <!ATTLIST author
        id     ID    #REQUIRED
        name   CDATA #REQUIRED
        email  CDATA #IMPLIED> 
   <!ATTLIST book
        code      ID      #REQUIRED
        title     CDATA   #REQUIRED
        authors   IDREFS  #REQUIRED>
        category  ("common"|"markup"|"programming"|"scripting") "common">
]>

Применение в XML:
<author id="AV_5698" name="Иванов И.И." />
<author id="AV_9812" name="Сидоров В.П."/>
<author id="AV_5566" name="Орлов П.П." />
<author id="AV_6789" name="Горбачев М.С."/>

<book code="BK_7644"
         title="Язык Разметки Гипертекста"
         category="markup"
         authors="AV_7655 AV_5698" />
<book code="BK_3245"
         title="C++ для профессионалов"
         category="programming"
         authors="AV_9812" />
<book code="BK_6677"
         title="Бизнес и компьютер"
         authors="AV_5566" />]]></div>

<p>В данном примере атрибут <b>category</b> принимает значения из заданного списка.
Кроме того, значением по умолчанию для данного атрибута является <b><q>common</q></b> (выделен в коде зеленым фоном).
Таким образом, если атрибут <b>category</b> не указан, значение по умолчанию будет подставленно анализатором.
Если значение атрибута <b>category</b> не входит в указанный список, документ будет считаться недействительным.
</p>

<h3>Параметрические сущности (продолжение)</h3>

<p>Параметрические сущности
    используются для сокращения и упрощения записи часто встречающихся в DTD
    фрагментов. Представим себе следующую ситуацию: в нашем каталоге могут содержаться
    как книги, так и периодические издания (журналы, газеты). И у одних и у вторых
    есть такие атрибуты, как код, название, год издания, типография и т.п. в таком
    случае DTD примет следующий вид (DTD приводится в сокращенном виде):</p>


<div class="lang-xml"><![CDATA[
<!DOCTYPE catalog [
...
<!ELEMENT book    EMPTY>
<!ELEMENT magazin EMPTY>
<!ATTLIST book
    code      ID     #REQUIRED
    title     CDATA  #REQUIRED
    year      CDATA  #REQUIRED
    publisher CDATA  #REQUIRED
    category  ("common"|"markup"|"programming"|"scripting") "common"
    authors   IDREFS #REQUIRED>
<!ATTLIST magazin
    code      ID     #REQUIRED
    title     CDATA  #REQUIRED
    year      CDATA  #REQUIRED
    publisher CDATA  #REQUIRED
    number    CDATA  #REQUIRED>
]>
]]></div>

<p>Ну, например, так. Как видно из примера в списках атрибутов для книги и журнала присутствуют
    повторяющиеся элементы (<b>code</b>, <b>title</b>, ...). Оптимизировать данное
    объявление можно путем создания и использования такой параметрической сущности:</p>

<div class="lang-xml"><![CDATA[
<!ENTITY % commonParams
       "code      ID     #REQUIRED
        title     CDATA  #REQUIRED
        year      CDATA  #REQUIRED
        publisher CDATA  #REQUIRED">

<!ELEMENT book    EMPTY>
<!ELEMENT magazin EMPTY>
<!ATTLIST book
        %commonParams;
        category  ("common"|"markup"|"programming"|"scripting") "common"
        authors   IDREFS #REQUIRED>
<!ATTLIST magazin
        %commonParams;
        number    CDATA  #REQUIRED>
]]></div>

<p>Необходимо отметить, что параметрические сущности могут использоваться только во внешних DTD.</p>

<p>Недостатки DTD:</p>
<ul>
<li>невозможность определения типа значения</li>
<li>DTD не является диалектом XML, что усложняет его обработку средствами XML</li>
</ul>

<h2>W3C парсеры для XML.</h2>

<p>Проблемой при валидации (проверка правильности XML документа согласно схеме) является тот факт,
что соответствие документов их схемам некоторые броузеры не проверяют.
В связи с этим возникает необходимость использовать возможности DOM (Document Object Model) для проверки правильности.
</p>

<p>Проверить правильность файла <q>my.xml</q> относительно DTD можно командой</p>

<pre>xmllint --noout --dtdvalid my.dtd my.xml</pre>

<h2>Задание на лабораторную работу</h2>

<p>Необходимо для XML документа, созданого в первой лабораторной работе, определить его струткуру с помощью DTD (внешней).
Осуществить проверку соответствия документа описанию его структуры.
</p>

<p>Проверку можно осуществить с помощью специального валидатора, о котором рассказано Выше..
</p>

<p>Для демонстрации правильности DTD необходимо проверить не только прохождение валидации,
но и ее непрохождение (т.е. смоделировать несолько ошибок, которые явно указывают на то или иное описание в DTD).
</p>

<p><b>Отчет</b> должен содержать: титульный лист, тему, цель работы, xml документ, внешний DTD,
протоколы валидации: 1 - нормальной валидации xml документа и не менее 4-5 - демонстрирующих (специально сделанные) ошибки в xml документе.
</p>

</body>
</html>
