<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="ru">
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8"/>
<meta name="description" content="C++ STL"/>
<meta name="viewport" content="width=device-width"/>
<link rel="stylesheet" type="text/css" href="/styles.css" />
<title>Лабораторная работа №8</title>
</head>
<body>

<h1>Лабораторная работа №8:<br/>Стандартная библиотека шаблонов (STL)</h1>

<p>Цель работы: изучить правила работы со стандартными шаблонами в С++.
</p>

<h2>Теоретические сведения</h2>

<p>Стандартная библиотека шаблонов (STL) (англ. Standard Template Library) — набор согласованных обобщённых алгоритмов, контейнеров, средств доступа к их содержимому и различных вспомогательных функций в C++.
</p>
<p>Стандартная библиотека шаблонов до включения в стандарт C++ была сторонней разработкой, в начале — фирмы HP, а затем SGI. Стандарт языка не называет её «STL», так как эта библиотека стала неотъемлемой частью языка, однако многие люди до сих пор используют это название, чтобы отличать её от остальной части стандартной библиотеки (потоки ввода/вывода (iostream), подраздел Си и др.).
</p>
<p>Проект под названием STLPort, основанный на SGI STL, осуществляет постоянное обновление STL, iostream и строковых классов. Некоторые другие проекты также занимаются разработкой частных применений стандартной библиотеки для различных конструкторских задач. Каждый производитель компиляторов C++ обязательно поставляет какую-либо реализацию этой библиотеки, так как она является очень важной частью стандарта и широко используется. Архитектура STL была разработана Александром Степановым и Менгом Ли.
</p>
<p>В библиотеке выделяют пять основных компонентов:
</p>

<ul>
<li>Контейнер (англ. container) — хранение набора объектов в памяти.</li>
<li>Итератор (англ. iterator) — обеспечение средств доступа к содержимому контейнера.</li>
<li>Алгоритм (англ. algorithm) — определение вычислительной процедуры.</li>
<li>Адаптер (англ. adaptor) — адаптация компонентов для обеспечения различного интерфейса.</li>
<li>Функциональный объект (англ. functor) — сокрытие функции в объекте для использования другими компонентами.</li>
</ul>

<p>Такое разделение позволяет уменьшить количество компонентов. Например, вместо написания отдельной функции поиска элемента для каждого типа контейнера обеспечивается единственная версия, которая работает с каждым из них, пока соблюдаются основные требования.
</p>

<h2>Контейнеры</h2>

<p>Контейнеры библиотеки STL можно разделить на четыре категории: последовательные, ассоциативные, контейнеры-адаптеры и псевдоконтейнеры.
</p>

<table>
<caption>Последовательные контейнеры</caption>
<tr>
<td>vector</td>
<td>C-подобный динамический массив произвольного доступа с автоматическим изменением размера при добавлении/удалении элемента. Доступ по индексу за . Добавление-удаление элемента в конец vector занимает амортизированное  время, та же операция в начале или середине vector — . Стандартная быстрая сортировка за . Поиск элемента перебором занимает . Существует специализация шаблона vector для типа bool, которая требует меньше памяти за счёт хранения элементов в виде битов, однако она не поддерживает всех возможностей работы с итераторами.
</td>
</tr>
<tr>
<td>list</td>
<td>Двусвязный список, элементы которого хранятся в произвольных кусках памяти, в отличие от контейнера vector, где элементы хранятся в непрерывной области памяти. Поиск перебором медленнее, чем у вектора из-за большего времени доступа к элементу. Доступ по индексу за . В любом месте контейнера вставка и удаление производятся очень быстро — за .
</td>
</tr>
<tr>
<td>deque</td>
<td>Дэк. Контейнер похож на vector, но с возможностью быстрой вставки и удаления элементов на обоих концах за . Реализован в виде двусвязанного списка линейных массивов. С другой стороны, в отличие от vector, дек не гарантирует расположение всех своих элементов в непрерывном участке памяти, что делает невозможным безопасное использование арифметики указателей для доступа к элементам контейнера.
</td>
</tr>
</table>

<table>
<caption>Ассоциативные контейнеры</caption>
<tr><td>Set</td>
<td>Упорядоченное множество уникальных элементов. При вставке/удалении элементов множества итераторы, указывающие на элементы этого множества, не становятся недействительными.
Обеспечивает стандартные операции над множествами типа объединения, пересечения, вычитания.
Тип элементов множества должен реализовывать оператор сравнения operator&lt; или требуется предоставить функцию-компаратор.
Реализован на основе самобалансирующего дерева двоичного поиска.
</td>
</tr>
<tr><td>Multiset</td>
<td>То же что и set, но позволяет хранить повторяющиеся элементы.</td>
</tr>
<tr>
<td>Map</td>
<td>Упорядоченный ассоциативный массив пар элементов, состоящих из ключей и соответствующих им значений.
Ключи должны быть уникальны. Порядок следования элементов определяется ключами.
При этом тип ключа должен реализовывать оператор сравнения operator&lt;, либо требуется предоставить функцию-компаратор.
</td>
</tr>
<tr>
<td>multimap</td>
<td>То же что и map, но позволяет хранить несколько одинаковых ключей.</td>
</tr>
</table>

<table>
<caption>Контейнеры-адаптеры</caption>
<tr>
<td>stack</td>
<td>Стек — контейнер, в котором добавление и удаление элементов осуществляется с одного конца.</td>
</tr>
<tr>
<td>queue</td>
<td>Очередь — контейнер, с одного конца которого можно добавлять элементы, а с другого — вынимать.</td>
</tr>
<tr>
<td>priority_queue</td>
<td>Очередь с приоритетом, организованная так, что самый большой элемент всегда стоит на первом месте.</td>
</tr>
</table>

<table>
<caption>Псевдоконтейнеры</caption>
<tr>
<td>bitset</td>
<td>Служит для хранения битовых масок. Похож на vector&lt;bool&gt; фиксированного размера.
Размер фиксируется тогда, когда объявляется объект bitset. Итераторов в bitset нет. Оптимизирован по размеру памяти.</td>
</tr>
<tr>
<td>basic_string</td>
<td>Контейнер, предназначенный для хранения и обработки строк. Хранит в памяти элементы подряд единым блоком, что позволяет организовать быстрый доступ ко всей последовательности.
Элементы должны быть простых (фундаментальных) типов данных. Определена конкатенация с помощью +.
</td>
</tr>
<tr>
<td>valarray</td>
<td>Шаблон служит для хранения числовых массивов и оптимизирован для достижения повышенной вычислительной производительности.
В некоторой степени похож на vector, но в нём отсутствует большинство стандартных для контейнеров операций.
Определены операции над двумя valarray и над valarray и скаляром (поэлементные).
Эти операции возможно эффективно реализовать как на векторных процессорах, так и на скалярных процессорах с блоками SIMD.
</td>
</tr>
</table>

<p>В контейнерах для хранения элементов используется семантика передачи объектов по значению.
Другими словами, при добавлении контейнер получает копию элемента.
Если создание копии нежелательно, то используют контейнер указателей на элементы.
Присвоение элементов реализуется с помощью оператора присваивания, а их разрушение происходит с использованием деструктора.
В таблице приведены основные требования к элементам в контейнерах:
</p>

<table>
<tr>
<td>Метод</td>
<td>Описание</td>
<td>Примечание</td>
</tr>
<tr>
<td>Конструктор копии</td>
<td>Создает новый элемент, идентичный старому</td>
<td>Используется при каждой вставке элемента в контейнер</td>
</tr>
<tr>
<td>Оператор присваивания</td>
<td>Заменяет содержимое элемента копией исходного элемента</td>
<td>Используется при каждой модификации элемента</td>
</tr>
<tr>
<td>Деструктор</td>
<td>Разрушает элемент</td>
<td>Используется при каждом удалении элемента</td>
</tr>
<tr>
<td>Конструктор по умолчанию</td>
<td>Создает элемент без аргументов</td>
<td>Применяется только для определенных операций</td>
</tr>
<tr>
<td>operator==</td>
<td>Сравнивает два элемента</td>
<td>Используется при выполнении operator== для двух контейнеров</td>
</tr>
<tr>
<td>operator &lt;</td>
<td>Определяет, меньше ли один элемент другого</td>
<td>Используется при выполнении operator&lt; для двух контейнеров</td>
</tr>
</table>

<p>Все «полноценные» стандартные контейнеры удовлетворяют определенному набору требований (или соглашений). В приведенной ниже таблице полагается, что С — класс контейнера, содержащий объекты типа Т.</p>

<table>
<tr>
<td>Выражение</td>
<td>Возвращаемый тип</td>
<td>Сложность</td>
<td>Примечание</td>
</tr>
<tr>
<td>C::value_type</td>
<td>T</td>
<td>Время компиляции</td>
<td></td>
</tr>
<tr>
<td>C::reference</td>
<td>T</td>
<td>Время компиляции</td>
<td></td>
</tr>
<tr>
<td>C::const_reference</td>
<td></td>
<td>Время компиляции</td>
<td></td>
</tr>
<tr>
<td>C::pointer</td>
<td>Тип указателя, указывающего на C::reference</td>
<td>Время компиляции</td>
<td>Указатель на Т</td>
</tr>
<tr>
<td>C::iterator</td>
<td>Тип итератора, указывающего на C::reference</td>
<td>Время компиляции</td>
<td>Итератор любого типа, кроме итератора вывода</td>
</tr>
<tr>
<td>C::const_iterator</td>
<td>Тип итератора, указывающего на C::const_reference</td>
<td>Время компиляции</td>
<td>Итератор любого типа, кроме итератора вывода</td>
</tr>
<tr>
<td>C::size_type</td>
<td>Беззнаковый целочисленный тип</td>
<td>Время компиляции</td>
<td></td>
</tr>
<tr>
<td>C obj;</td>
<td></td>
<td>Постоянная</td>
<td>После: obj.size() == 0</td>
</tr>
<tr>
<td>C obj1; obj1 = obj2;</td>
<td></td>
<td>Линейная</td>
<td>После: obj1 == obj2</td>
</tr>
<tr>
<td>C obj; (&amp;obj)->~C();</td>
<td>Результат не используется</td>
<td>Линейная</td>
<td>После: a.size() == 0.</td>
</tr>
<tr>
<td>obj.begin()</td>
<td></td>
<td>Постоянная</td>
<td></td>
</tr>
<tr>
<td>obj.end()</td>
<td></td>
<td>Постоянная</td>
<td></td>
</tr>
<tr>
<td>obj1 == obj2</td>
<td>Обратимый в bool</td>
<td>Линейная</td>
<td></td>
</tr>
<tr>
<td>obj1 != obj2</td>
<td>Обратимый в bool</td>
<td>Линейная</td>
<td></td>
</tr>
<tr>
<td>obj.size()</td>
<td>size_type</td>
<td>Зависит от типа</td>
<td>Не рекомендуется применять для проверки, пуст ли контейнер</td>
</tr>
<tr>
<td>obj.empty()</td>
<td>Обратимый в bool</td>
<td>Постоянная</td>
<td></td>
</tr>
<tr>
<td>obj1 &lt; obj2</td>
<td>Обратимый в bool</td>
<td>Линейная</td>
<td></td>
</tr>
<tr>
<td>obj1 > obj2</td>
<td>Обратимый в bool</td>
<td>Линейная</td>
<td></td>
</tr>
<tr>
<td>obj1 &lt;= obj2</td>
<td>Обратимый в bool</td>
<td>Линейная</td>
<td></td>
</tr>
<tr>
<td>obj1 >= obj2</td>
<td>Обратимый в bool</td>
<td>Линейная</td>
<td></td>
</tr>
<tr>
<td>obj.swap(obj2)</td>
<td>void</td>
<td>Постоянная</td>
<td></td>
</tr>
</table>

<h2>Итераторы</h2>

<p>В библиотеке STL для доступа к элементам в качестве посредника используется обобщённая абстракция, именуемая итератором. Каждый контейнер поддерживает «свой» вид итератора, который представляет собой «модернизированный» интеллектуальный указатель, «знающий» как получить доступ к элементам конкретного контейнера. Стандарт C++ определяет пять категорий итераторов, описанных в следующей таблице:</p>

<table>
<tr>
<th>Категория</th>
<th>Поддерживаемые операции</th>
<th>Примечание</th>
</tr>
<tr>
<td>Входные</td>
<td>operator++, operator*, operator->, конструктор копии, operator=, operator==, operator!=</td>
<td>Обеспечивают доступ для чтения в одном направлении. Позволяют выполнить присваивание или копирование с помощью оператора присваиваивания и конструктора копии</td>
</tr>
<tr>
<td>Выходные</td>
<td>operator++, operator*, конструктор копии</td>
<td>Обеспечивают доступ для записи в одном направлении. Их нельзя сравнивать на равенство.</td>
</tr>
<tr>
<td>Однонаправленные</td>
<td>operator++, operator*, operator->, конструктор копии, конструктор по умолчанию, operator=, operator==, operator!=</td>
<td>Обеспечивают доступ для чтения и записи в одном направлении. Позволяют выполнить присваивание или копирование с помощью оператора присваиваивания и конструктора копии. Их можно сравнивать на равенство.</td>
</tr>
<tr>
<td>Двунаправленные</td>
<td>operator++, operator--, operator*, operator->, конструктор копии, конструктор по умолчанию, operator=, operator==, operator!=</td>
<td>Поддерживают все функции, описанные для однонаправленных итераторов (см. выше). Кроме того, они позволяют переходить к предыдущему элементу.</td>
</tr>
<tr>
<td>Произвольного доступа</td>
<td>operator++, operator--, operator*, operator->, конструктор копии, конструктор по умолчанию, operator=, operator==, operator!=, operator+, operator-, operator+=, operator-=, operator&lt;, operator>, operator&lt;=, operator>=, operator[]</td>
<td>Эквивалентны обычным указателям: поддерживают арифметику указателей, синтаксис индексации массивов и все формы сравнения.</td>
</tr>
</table>



<h2>Контрольные вопросы</h2>
<ol>
<li>Что такое шаблоны и с какой целью они используются?</li>
<li>Какого типа шаблоны используются в программах?</li>
<li>Как оформляются шаблоны функций?</li>
<li>Какие требования предъявляются к фактическим параметрам шаблонов?</li>
<li>Какие преимущества программы обеспечиваются при использовании шаблонов классов?</li>
</ol>

<h2>Варианты заданий</h2>

<ol>
<li>Используйте шаблон <strong>vector</strong> для массива данных об авто.</li>
<li>Используйте шаблон <strong>list</strong> для двусвязного списка данных об авто.</li>
<li>Используйте шаблон <strong>deque</strong> для учёта данных об очереди авто на заправке.</li>
<li>Используйте шаблон <strong>set</strong> для построения двух множеств целых чисел и вычисления их пересечения.</li>
<li>Используйте шаблон <strong>multiset</strong> для подсчета числа вхождений каждого числа во множество целых чисел с повторами.</li>
<li>Используйте шаблон <strong>map</strong> для исключения повторов среди множества целых чисел.</li>
<li>Используйте шаблон <strong>multimap</strong> для исключения повторов комбинаций среди множества пар целых чисел.</li>
<li>Используйте шаблон <strong>stack</strong> для стека вещественных чисел.</li>
<li>Используйте шаблон <strong>queue</strong> для очереди авто на мойке.</li>
<li>Используйте шаблон <strong>priority_queue</strong> для очереди заказов, чтобы обслуживать самые большие заказы в первую очередь.</li>
<li>Используйте шаблон <strong>bitset</strong> для хранения информации о простоте первых 10000 целых чисел.</li>
<li>Используйте шаблон <strong>basic_string</strong> для хранения фамилий имен и отчеств.</li>
<li>Используйте шаблон <strong>valarray</strong> для массива данных об авто.</li>
<li>Используйте шаблон <strong>hash_map</strong> для массива данных об авто.</li>
<li>Используйте шаблон <strong>unordered_map</strong> для массива данных об авто.</li>
</ol>

</body>
</html>
