<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="ru">
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8"/>
<meta name="language" content="ru"/>
<meta name="viewport" content="width=device-width"/>
<meta name="description" content="Программирование C++, индивидуальная работа"/>
<link rel="stylesheet" type="text/css" href="/styles.css" />
<title>Программирование на С++, индивидуальная работа</title>
</head>
<body>
<h1>Программирование на С++, индивидуальная работа</h1>

<p>Цель: Разработка простейших классов на примере разработки моделей элементарных объектов.
Введение
</p>
<p>Индивидуальное задание по курсу «Программирование» – это обязательный вид работы, который необходимо выполнить студенту для получения высокой оценки по результатам семестра. 
Структура и цели индивидуального задания
</p>
<p>Основной целью индивидуального задания является углубленное изучение теоретических и практических вопросов разработки и реализации компьютерных программ на выбранных языках программирования. 
</p>
<p>Индивидуальное задание состоит из двух частей. Задача первой части задания – овладение дополнительным теоретическим материалом и систематизация знаний студента о методах разработки алгоритмов решения практических задач, углубленное изучение отдельных вопросов использования языка программирования, его операторов и стандартных библиотек. Результатом первой части задания является обзор и описание состояния вопроса по выбранной тематике (реферативная часть). Вторая часть задания посвящена получению практических навыков решения прикладных задач с использованием выбранной среды программирования. В качестве конкретной задачи (или задач) обычно выбирается задача, согласованная по смыслу с первой частью индивидуального задания. 
</p>
<p>По согласованию с преподавателем студент имеет возможность выбрать в качестве индивидуального задания другую тему индивидуальной работы и согласовать другую структуру отчета. 
Обзорная (реферативная) часть
</p>
<p>Задачей данной части индивидуального задания является самостоятельный поиск и систематическое изложение материала по выбранной тематике. Студент должен самостоятельно скомпоновать и связно изложить материал, который не входит в базовый лекционный материал курса «Программирование». Для выполнения этой исследовательской работы следует использовать как печатные, так и электронные источники. 
</p>

<h2>Перечень примерных тем рефератов</h2>
<ul>
<li>Консольное управление ОС.</li>
<li>Расширенное описание операционной среды, ее дополнительных возможностей и логики функционирования.</li>
<li>Расширенное описание технологии работы с выбранной системой программирования</li>
<li>Расширенные возможности системы программирования, комплексирование с другими языками программирования.</li>
<li>Расширенное описание возможностей применения библиотечных процедур из библиотек выбранной системы программирования.</li>
<li>Расширенное описание, логика работы и способы использования операторов языка.</li>
<li>Применение выбранной системы программирования для решения типовых задач обработки информации: графические приложения, численные задачи (линейная алгебра, решение систем уравнений и т.п.), игровые программы, обучающие программы и т.п. Например:</li>
<li>Алгоритмы арифметических действий с целыми числами произвольной размерности </li>
<li>Алгоритмы нахождения простых чисел </li>
<li>Алгоритмы работы с битовыми массивами. </li>
<li>Алгоритмы работы с символьными строками </li>
<li>Алгоритмы матричных операций.</li>
<li>Алгоритмы поиска элементов. </li>
<li>Алгоритмы сортировки. </li>
<li>Алгоритмы решения простых нелинейных уравнений.</li>
<li>Алгоритмы определения кратчайшего пути на карте. </li>
<li>Алгоритмы нахождения значений определенных интегралов.</li> 
<li>Алгоритмы исследования и построения графиков функций </li>
<li>Алгоритмы работы с многосвязными списками </li>
</ul>

<h2>Практическая часть</h2>
<p>Целью практической части индивидуального задания является применение изученных методов
работы с системами программирования в практической разработке программного обеспечения ЭВМ.
Для выполнения практической части индивидуального задания следует выполнить математическую постановку выбранной задачи.
В обязательном порядке указать, какие данные являются входными и выходными. Разработать их форматы и способы хранения.
</p>

<p>Разработать алгоритм и записать его средствами блок-схем.
</p>

<p>Реализовать алгоритм на выбранном языке программирования.
</p>

<p>Провести вычислительный эксперимент, доказывающий, что реализованная программа работает правильно. 
</p>

<p>Общая постановка задачи: 	 
Разработать класс, набор методов (конструктор и минимум два метода) для программной модели заданного объекта.
Описание объекта и его основных свойств приводится ниже. Разработать вызывающую программу (main), использующую объекты разработанного класса и тестирующую работоспособность всех методов.
</p>

<h2>Варианты заданий</h2>

<table>
<tbody>
<tr><th>Номер</th><th>Задание</th></tr>
<tr><td>1</td><td>Объект «комплексные числа». Операции определяются по общепринятым формулам. Предусмотреть возможность операции присваивания, сложения, деления и перевода в текстовую строку текущих значений. Конструктор должен позволить создавать объекты без и с начальной инициализацией.</td></tr>
<tr><td>2</td><td>Объект «комплексные числа». Операции определяются по общепринятым формулам. Предусмотреть возможность операции присваивания, сложения, умножения и перевода в показательную () форму с возможностью распечатки на консоль. Конструктор должен позволить создавать объекты без и с начальной инициализацией.</td></tr>
<tr><td>3</td><td>Объект «вектор на плоскости» заданный в системе декартовых координат. Начало вектора расположено в начале координат. Операции определяются согласно общепринятых формул линейной (векторной) алгебры. Предусмотреть возможность операции присваивания, сложения, скалярного умножения и распечатки координат текущих значений. Конструктор должен позволить создавать объекты без и с начальной инициализацией.</td></tr>
<tr><td>4</td><td>Объект «вектор на плоскости» заданный в системе декартовых координат. Начало вектора расположено в начале координат. Операции определяются согласно общепринятых формул линейной (векторной) алгебры. Предусмотреть возможность операции присваивания, вычитания, скалярного умножения и распечатки координат текущих значений. Конструктор должен позволить создавать объекты без и с начальной инициализацией.</td></tr>
<tr><td>5</td><td>Объект «вектор на плоскости» заданный в системе декартовых координат. Начало вектора расположено в начале координат. Операции определяются согласно общепринятых формул линейной (векторной) алгебры. Предусмотреть возможность операции присваивания, сравнения модулей, скалярного умножения и распечатки координат текущих значений. Конструктор должен позволить создавать объекты без и с начальной инициализацией.</td></tr>
<tr><td>6</td><td>Объект «вектор на плоскости» заданный в системе декартовых координат. Начало вектора расположено в начале координат. Операции определяются согласно общепринятых формул линейной (векторной) алгебры. Предусмотреть возможность операции присваивания, нахождения угла между векторами, скалярного умножения и распечатки координат текущих значений. Конструктор должен позволить создавать объекты без и с начальной инициализацией.</td></tr>
<tr><td>7</td><td>Объект «равнобедренный треугольник, заданный длинами сторон». Предусмотреть возможность операции присваивания, определения площади и периметра, а так же логический метод, определяющий существует или такой треугольник. Конструктор должен позволить создавать объекты без и с начальной инициализацией.</td></tr>
<tr><td>8</td><td>Объект «равносторонний треугольник, заданный длинами сторон». Предусмотреть возможность операции присваивания, определения площади и периметра, а так же логический метод, определяющий существует или такой треугольник. Конструктор должен позволить создавать объекты без и с начальной инициализацией.</td></tr>
<tr><td>9</td><td>Объект «прямоугольный треугольник, заданный длинами сторон». Предусмотреть возможность операции присваивания, определения площади и периметра, а так же логический метод, определяющий существует или такой треугольник. Конструктор должен позволить создавать объекты без и с начальной инициализацией.</td></tr>
<tr><td>10</td><td>Объект «равнобедренный треугольник, заданный длиной равнобедренной стороной и углом между ними». Предусмотреть возможность операции присваивания, определения площади и периметра, а так же логический метод, отвечающий на вопрос – остро или тупо угольным является заданный треугольник. Конструктор должен позволить создавать объекты без и с начальной инициализацией.</td></tr>
<tr><td>11</td><td>Объект «треугольник, заданный длиной двух стороной и углом между ними». Предусмотреть возможность операции присваивания, определения площади и периметра, а так же логический метод, отвечающий на вопрос – остро или тупо угольным является заданный треугольник. Конструктор должен позволить создавать объекты без и с начальной инициализацией.</td></tr>
<tr><td>12</td><td>Объект «прямоугольник, заданный длинами двух сторон». Предусмотреть возможность операции присваивания, определения площади и периметра, а так же логический метод, отвечающий на вопрос – является ли прямоугольник квадратом. Конструктор должен позволить создавать объекты без и с начальной инициализацией.</td></tr>
<tr><td>13</td><td>Объект «множество целых чисел заданной мощности». Предусмотреть возможность операции присваивания, объединения двух множеств, вывода на печать элементов множества, а так же метод, отвечающий на вопрос – принадлежит ли указанное значение множеству. Конструктор должен позволить создавать объекты без и с начальной инициализацией. Мощность множества задается при создании объекта.</td></tr>
<tr><td>14</td><td>Объект «множество вещественных чисел заданной мощности». Предусмотреть возможность операции присваивания, объединения двух множеств, вывода на печать элементов множества, а так же метод, отвечающий на вопрос – принадлежит ли указанное значение множеству. Конструктор должен позволить создавать объекты без и с начальной инициализацией. Мощность множества задается при создании объекта.</td></tr>
<tr><td>15</td><td>Объект «множество символов заданной мощности». Предусмотреть возможность операции присваивания, объединения двух множеств, вывода на печать элементов множества, а так же метод, отвечающий на вопрос – принадлежит ли указанное значение множеству. Конструктор должен позволить создавать объекты без и с начальной инициализацией. Мощность множества задается при создании объекта.</td></tr>
<tr><td>16</td><td>Объект «множество целых чисел удвоенной длины заданной мощности». Предусмотреть возможность операции присваивания, объединения двух множеств, вывода на печать элементов множества, а так же метод, отвечающий на вопрос – принадлежит ли указанное значение множеству. Конструктор должен позволить создавать объекты без и с начальной инициализацией. Мощность множества задается при создании объекта.</td></tr>
<tr><td>17</td><td>Объект «множество вещественных чисел удвоенной точности заданной мощности». Предусмотреть возможность операции присваивания, объединения двух множеств, вывода на печать элементов множества, а так же метод, отвечающий на вопрос – принадлежит ли указанное значение множеству. Конструктор должен позволить создавать объекты без и с начальной инициализацией. Мощность множества задается при создании объекта.</td></tr>
<tr><td>18</td><td>Объект «множество байт заданной мощности». Предусмотреть возможность операции присваивания, объединения двух множеств, вывода на печать элементов множества, а так же метод отвечающий на вопрос – принадлежит ли указанное значение множеству. Конструктор должен позволить создавать объекты без и с начальной инициализацией. Мощность множества задается при создании объекта.</td></tr>
<tr><td>19</td><td>Объект «множество целых чисел не заданной (переменной) мощности». Предусмотреть возможность операции добавить элемент к множеству, определение количество элементов в множестве, вывода на печать всех элементов множества, а так же метод удаляющий указанный элемент из множества, если этот элемент принадлежит множеству. Конструктор должен позволить создавать объекты без и с начальной инициализацией.</td></tr>
<tr><td>20</td><td>Объект «множество вещественных чисел не заданной (переменной) мощности». Предусмотреть возможность операции добавить элемент к множеству, определение количество элементов в множестве, вывода на печать всех элементов множества, а так же метод удаляющий указанный элемент из множества, если этот элемент принадлежит множеству. Конструктор должен позволить создавать объекты без и с начальной инициализацией.</td></tr>
<tr><td>21</td><td>Объект «множество символов не заданной (переменной) мощности». Предусмотреть возможность операции добавить элемент к множеству, определение количество элементов в множестве, вывода на печать всех элементов множества, а так же метод удаляющий указанный элемент из множества, если этот элемент принадлежит множеству. Конструктор должен позволить создавать объекты без и с начальной инициализацией.</td></tr>
<tr><td>22</td><td>Объект «множество целых чисел удвоенной длины не заданной (переменной) мощности». Предусмотреть возможность операции добавить элемент к множеству, определение количество элементов в множестве, вывода на печать всех элементов множества, а так же метод удаляющий указанный элемент из множества, если этот элемент принадлежит множеству. Конструктор должен позволить создавать объекты без и с начальной инициализацией.</td></tr>
<tr><td>23</td><td>Объект «прямоугольник, заданный длинами двух сторон». Предусмотреть возможность операции присваивания, определения площади и периметра, а так же логический метод, отвечающий на вопрос – содержится ли, указанный параметрами метода прямоугольник, внутри прямоугольника. Конструктор должен позволить создавать объекты без и с начальной инициализацией </td></tr>
</tbody>
</table>

<h3>Примеры подобных учебных реализаций: СТЕК символьных строк</h3>

<div class="lang-cpp"><![CDATA[
class stack {
  private:
     char st[55];   // массив для хранения элементов стека
     int  ptr;      // указатель номера СЕДУЮЩЕГО свободного места в массиве
     int  max_ptr;  // максимальный размер стека
     char buf[110];  // для организации печати информации о состоянии стека
  public:
     stack();            // конструктор
     ~stack();           // деструктор
     void push(char c);  // метод - поместить в стек
     char pop();         // метод - взять из стека ('\0' - если стек пуст)
     char look();        // метод - посмотреть что в вершин стека ('\0' - если стек пуст)
     char * pr();        // метод - вернуть символьную строку - элементов в стеке
     void prln();        // метод -  распечатать стек
};
stack::stack()            // конструктор
     {
      max_ptr=55;
      ptr=0;
      for(int i=0; i< max_ptr; i++) st[i]='\0';
     };
stack::~stack()          // деструктор
     {
      ptr=0;
      for(int i=0; i< max_ptr; i++) st[i]='\0';
     };
void stack::push(char c)   // метод - поместить в стек
     {
      if ( (ptr+1) > max_ptr) 
      { printf("*** переполнение стека ***\n");
        exit(666);
      };
      st[ptr++]=c;
      return;
     };
char stack::pop()    // метод - взять из стека ('\0' - если стек пуст)
    {
      char cc;
      if (ptr < 0 ) return '\0';
      ptr--;
      cc=st[ptr];
      st[ptr]='\0';
      return cc;
    };
 
char stack::look()      // метод - посмотреть что в вершин стека ('\0' - если стек пуст)
    {
     char cc;
     int t_ptr;
     t_ptr=ptr-1;
     if ( t_ptr < 0 ) return '\0';
     cc = st[t_ptr];
     return cc;
    };
 
char *stack::pr()  // метод - вернуть символьную строку - элементов в стеке
    { int i;
      int j=0;
      buf[j++]=':'; buf[j++]=' ';
      for (i= (strlen(st)-1); i >= 0;  i-- ) 
       {      
         buf[j++]=st[i];
         buf[j++]=' ';
       };
      buf[--j]='\0';
      //sprintf(buf,": %s ",st);
      return buf;
    };
 
void stack::prln()    // метод -  распечатать стек
    { printf("%s\n", pr() );
      return;
    };
=====================================================================
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
//#include "stack.h"
int main(int argc, char * argv[]) {
  stack st; 
  st.prln();
 
  st.push('1'); st.prln();
  st.push('2'); st.prln();
  st.push('3'); st.prln();
  st.push('4'); st.prln();
  char
  z=st.pop();
  printf("===>pop ===> %c \n",z);
  st.prln();
  z=st.pop();
  printf("===>pop ===> %c \n",z);
  st.prln();
  z=st.look();
  printf("===>look===> %c \n",z);
  st.prln();
  printf("*********** %s\n",st.pr());
 return;
};

]]></div>

<p>Результаты:</p>

<pre><![CDATA[
:
: 1
: 2 1
: 3 2 1
: 4 3 2 1
===>pop ===> 4
: 3 2 1
===>pop ===> 3
: 2 1
===>look===> 2
: 2 1
*********** : 2 1
]]></pre>

<h3>Класс - "моя строка" st</h3>

<div class="lang-cpp"><![CDATA[
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
 
class st {
   private:
   int l;           // длина
   char * s;        // адрес строки
  public:
   st();            // конструктор без параметра
   st(char *);    // конструктор с инициализирующим параметром
   ~st();
const char * put(const char *); // взять указатель на строку
const char * get();               // записать строку
 st(const st & x);                // конструктор копирования
 st & operator=(const st & x);    // оператор присваивания
 st & operator+=(const st & x);  //унарный оператор +=
 
 friend st operator+(const st & x, const st & y); 
 // дружественная функция +
 
 friend st operator-(const st & x, const st & y);
                            // дружественная функция -
 
 void ch(char); // для теста - изменить 0-й символ
 void pr( char *); // для теста - распечатать....
 
};
 
void st::ch(char x)
{ if (s[0] != '\0') this->s[0]=x;
   return;
};
 
 void st::pr(char tit[]="")
{printf("%s[%d]<%s>\n",tit,l,s);return; };
 
st::st()
{ l=1; s=new char[1]; s[0]='\0';};  
 
st::st(char * d)
{ l=strlen(d)+1; s=new char[l]; 
  strcpy(s, d);
  };
 
st::~st()
{
   delete [] s;
   l=0;
};
 
 st & st::operator=(const st & x)
 {
   if( this == &x ) return *this;
   delete [] this->s;
   this->l=x.l;
   this->s=new char[l]; 
   strcpy(s, x.s); 
   return *this;
 };
 
 // copy constructor
 //   попробуйте убрать.....
 st::st(const st & x)
 {
   this->l=x.l;
   this->s=new char[l]; 
   strcpy(s, x.s); 
 };
 
 // унарный +=
 st & st::operator+=(const st & x)
 {
   char *p;    int lp=this->l+x.l-1;
   p=new char[lp];
   sprintf(p,"%s%s",this->s, x.s);
   // в р - конактенитрованная строка
   delete [] this->s;
   this->l=lp;
   this->s=new char[lp]; 
   strcpy(this->s, p); 
   return *this;
 };
 // бинарный +
 st operator+(const st & x, const st & y )
 {
   char *p; 
   st temp;//! вызывается конструктор копирования
   int lp=x.l + y.l -1;
 
   p=new char[lp];
 
   sprintf(p,"%s%s", x.s, y.s);
   // в р - конактенитрованная строка
   temp.l=lp;
   temp.s=new char[lp]; 
   strcpy(temp.s, p); 
   return temp;
 };
 
 // бинарный -
 st operator-(const st & x, const st & y )
 {
   printf("x=%s  y=%s \n", x.s, y.s); 
   char *p; 
   st temp;  // !!!!!!!!!!!!!!!!!!!!!
   int i,j;    
   int k;
   char tchar;
   int flag;
   int n=x.l+1;
   p=new char[n];
   k=0;
   for(i=0; i< x.l; i++)
    {   tchar=x.s[i];
        // есть ли tchar в y.s ?
        flag=0;
        for(j=0;j<y.l;j++)  
          if(tchar==y.s[j]) {flag=1; break;};
        if(flag==0) p[k++]=tchar;
    };
    p[k]='\0';
   // в р - новая строка
   temp.l=k;
   temp.s=new char[k]; 
   strcpy(temp.s, p); 
   return temp;
 };
 
const char * st::put(const char * d)
{ 
  delete [] s;
  l=strlen(d)+1; s=new char[l]; 
  strcpy(s, d); 
  return s;
};
 
const char * st::get()
{
  return s;
}
 
int main(int argc, char *argv[] )
{ st a1, a2, a3, a4="куку";
  const char * p;
 
  p=a1.put("привет");  
  printf("***p===<%s>\n",p);
  a1.pr("a1= ....  ==> ");
  a2=a1;
  a2.pr("a2=a1 => ");
  a3.put("Всем "); a3.pr("a3.put(...) ==> ");
  a3+=a2;        a3.pr("a3+=a2 ==> ");
  printf("*************************\n");
  a1.ch('$');      a1.pr("a1($) ==> ");
  a2=a1;
  a2.ch('@');    a2.pr("a1(@) ==> ");
  a4.pr("a4 ==> ");
  printf("*************************\n");
  a2=a1 + " +++ " + a4;    a2.pr("a1 +++ a4 ==> ");
  a1 = "победа!";   a1.pr("a1=.... ==> ");
  a2 = a1 - "по";   a2.pr("a2=a1 - по ==> ");
  a3 = a1 - "ап";   a3.pr("a3=a1 - ап ==> ");
  return 0;
}
]]></div>

<p>Результаты:
</p>

<div class="lang-cpp"><![CDATA[
***p===<привет>
a1= ....  ==> [7]<привет>
a2=a1 => [7]<привет>
a3.put(...) ==> [6]<Всем >
a3+=a2 ==> [12]<Всем привет>
*************************
a1($) ==> [7]<$ривет>
a1(@) ==> [7]<@ривет>
a4 ==> [5]<куку>
*************************
a1 +++ a4 ==> [16]<$ривет +++ куку>
a1=.... ==> [8]<победа!>
x=победа!  y=по
a2=a1 - по ==> [5]<беда!>
x=победа!  y=ап
a3=a1 - ап ==> [5]<обед!>

]]></div>

<p>множества</p>

<div class="lang-cpp"><![CDATA[
#include <stdio.h>
#include <iostream.h>
#include <string.h>
#include <stdlib.h>

class set {
private:
int size;
int *elems;
public:
set(void);
friend set operator+(set,set);
friend set operator-(set,set);
friend set operator*(set,set);
friend int operator<=(set,set);
friend int operator>=(set,set);
friend int operator==(set,set);
friend int operator!=(set,set);
friend void operator>>(set,char*); //Вывод множества в файл
friend void operator << (set&,char*); //Ввод множества из файла
void Print();
};

class ErrorInOpenFile {
public:
ErrorInOpenFile() { strcpy(mess,"Ошибка при работе с файлом");}
void ErrMessage() const {cout << mess;}
private:
char mess[50];
};

set::set() // конструктор
{
size=0;
};

int operator != (set a, set b) // не равно
{
int i,j,flg,res;
res=1;
for(i=0; i<a.size; i++)
{
flg=0;
for(j=0; j<b.size; j++)
if(b.elems[j] == a.elems[i]) flg=1;
if(!flg) res=0;
}
return !res;
};

int operator == (set a, set b) // равно
{
int i,j,flg,res;
res=1;
for(i=0;i<a.size;i++)
{
flg=0;
for(j=0; j<b.size; j++)
if(b.elems[j] == a.elems[i]) flg=1;
if(!flg) res=0;
}
return res;
};

int operator>=(set a, set b) {
int i,j;
int res,flg;
res=1;
for(i=0; i < a.size; i++) {
flg=0;
for(j=0; j<b.size; j++)
if(b.elems[j] == a.elems[i]) flg=1;
if(!flg) res=0;
}
return res;
};

int operator <= (set a, set b)
{
int i,j;
int res,flg;
res=1;
for(i=0; i<b.size; i++)
{
flg=0;
for(j=0;j<a.size;j++)
if(a.elems[j] == b.elems[i]) flg=1;
if(!flg)res=0;
}
return res;
};

set operator + (set a,set b)
{
int i,j,k;
int count;
count=0;
int flag;
for(i=0;i<b.size;i++)
{
flag=1;
for(j=0;j<a.size;j++)
if(a.elems[j] == b.elems[i]) flag=0;
if(flag) count++;
}
count+=a.size;
set res;
res.size=count;
res.elems=new int[count];
for(i=0;i<a.size;i++)res.elems[i]=a.elems[i];
for(j=0;j<b.size;j++)
{
flag=1;
for(k=0;k<a.size;k++)
if(a.elems[k]==b.elems[j])flag=0;
if(flag) res.elems[i++]=b.elems[j];
}
return res;
};

set operator-(set a,set b)
{
int i,j,k;
int count;
count=0;
int flag;
for(i=0;i<a.size;i++)
{
flag=1;
for(j=0;j<b.size;j++)
if(a.elems[i]==b.elems[j])flag=0;
if(flag)count++;
}
set res;
res.size=count;
res.elems=new int[count];
i=0;
for(j=0;j<a.size;j++)
{
flag=1;
for(k=0;k<b.size;k++)
if(a.elems[j]==b.elems[k])flag=0;
if(flag) res.elems[i++]=a.elems[j];
}

return res;
};

set operator*(set a,set b)
{
int i,j,k;
int count;
count=0;
int flag;
for(i=0;i<b.size;i++)
{
flag=1;
for(j=0;j<a.size;j++)
if(a.elems[j]==b.elems[i])flag=0;
if(!flag)count++;
}
set res;
res.size=count;
res.elems=new int[count];
i=0;
for(j=0;j<b.size;j++)
{
flag=1;
for(k=0;k<a.size;k++)
if(a.elems[k]==b.elems[j])flag=0;
if(!flag) res.elems[i++]=b.elems[j];
}
return res;
};

void operator << (set& nw,char* FileName)
{
const MAX_STR=255;
FILE *in;
char buff[MAX_STR+1];
try
{
in=fopen(FileName,"r");
if(in==NULL) throw ErrorInOpenFile();
}
catch(ErrorInOpenFile ERR)
{
ERR.ErrMessage();
exit(1);
}
unsigned i,count;
fgets(buff,MAX_STR,in);
sscanf(buff,"%d",&count);
nw.size=count;
nw.elems=new int[count];
for(i=0;i<count;i++)
{
fgets(buff,MAX_STR,in);
sscanf(buff,"%d",&nw.elems[i]);
}
fclose(in);
};

void operator>>(set nw,char* FileName)
{
int i;
const MAX_STR=255;
char buff[MAX_STR];
FILE* out;
try
{
out=fopen(FileName,"w+");
if(out==NULL)throw ErrorInOpenFile();
}
catch(ErrorInOpenFile ERR)
{
ERR.ErrMessage();
exit(1);
}
sprintf(buff,"%d\n",nw.size);
fputs(buff,out);
for(i=0; i<nw.size; i++)
{
sprintf(buff,"%d\n",nw.elems[i]);
fputs(buff,out);
}
fclose(out);
};

void set::Print()
{
int i;
cout << "\n";
for(i=0;i<size;i++)
cout << elems[i] << "\n";
};
void main()
{
set A;
set B;
set C;
A << "SetA.txt";
cout << "\nSet A";
A.Print();
B << "SetB.txt";

cout << "\nSet B";
B.Print();

C=A+B;
cout << "\nSet C";
C.Print();
// set D;
// D << "SetD.txt";
// set E;
// E=A-D;
// cout << "\nSet E";
// E.Print();
// set F;
// F=A*D;
// cout << "\nSet F";
// F.Print();
};
]]></div>

<p>Атрибуты строки</p>

<div class="lang-cpp"><![CDATA[
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <conio.h>
 
class string {
 private:
     char *str;
     unsigned char attr;
     int  row, col;
 public:
     string();
     string(char *, unsigned char, int , int );
     void write();
};
string::string()
  {
   str = new char [ sizeof "Привет!" ];
   strcpy(str, "Привет!");
   attr=(BLUE  <<  4) + YELLOW;  // BROWN << 4+GREEN;
   row=15;
   col=36;
  };
string::string(char * line, unsigned char a, int y=0, int x=0)
 {
  str=new char [ strlen(line)+1 ]; 
  strcpy(str, line);
   attr=a;
   row=y;
   col=x;
  };
void string::write()
{
   textattr( attr);
   gotoxy(col, row);
   cputs( str );
}

void main(int argc, char * argv[])
{
   clrscr();
 
   string string1;
   string string2("Строка вторая!", (BLACK << 4)+WHITE);
   string string3("Третья строка!", (BROWN << 4)+GREEN, 17, 19);
   string string4("Четвертая строка!", (BROWN << 4)+GREEN, 1, 1);
    string1.write();
    string2.write();
    string3.write();
    string4.write();
  return;
}
]]></div>

<h2>Отчет о выполнении</h2>
<p>Отчет о выполненном индивидуальном задании предоставляется в отпечатанном виде и должен быть подписан студентом. 
Отчет о выполнении индивидуального задания из двух частей: программная система (включая исходные тексты) и пояснительная записка.</p>

<p>Требования к оформлению отчёта:</p>

<ul>
<li>Печать на листах А4 с одной стороны; параметры страниц: слева 2.5 см; справа 1.5 см; сверху 2.0 см; снизу 2.0 см. </li>
<li>Абзацы: одинарный межстрочный интервал; отступ 6 пунктов; выравнивание по ширине; Times New Roman 14 пунктов. </li>
<li>Раздел: начинается с новой страницы; интервал после названий разделов 6 пунктов; шрифт Times New Roman 16 полужирный. </li>
<li>Параграфы: без разрыва страницы; перед названием параграфа интервал 6 пунктов; шрифт Times New Roman 14 полужирный; </li>
<li>Выравнивание всех заголовков - по центру, точка в конце заголовка не ставится. </li>
<li>Приложения нумеруются буквами алфавита. </li>
<li>Разделы (кроме вступления и заключения) нумеруются арабскими цифрами. </li>
<li>Номера страниц в правом верхнем углу; первая страница (титульный лист) не нумеруется. </li>
<li>Сноски - только в конце страницы. </li>
<li>Иллюстрации выравниваются по центру и подписываются как "Рис. 1 Название" </li>
<li>Названия таблиц выравниваются по правому краю и подписываются как "Таблица 1. Название" </li>
</ul>

<p>Отчёт состоит из таких основных частей:</p>
<ul>
<li>Титульный лист.</li>
<li>Содержание.</li>
<li>Введение.</li>
<li>Теоретическая часть.</li>
<li>Практическая часть.</li>
<li>Заключение.</li>
<li>Список использованных источников.</li>
</ul>

<p>Содержание создавать автоматически, используя возможности текстового процессора. 
</p>

<p>Введение: область использования.
</p>

<p>Теоретическая часть состоит из одного или нескольких разделов, где описываются алгоритмы, программные комплексы,
функции библиотек, возможности и функции среды разработки, используемых при создании курсовой работы.
</p>

<p>Практическая часть состоит из одного или нескольких разделов, описывающих процесс реализации алгоритма и создание программной системы. 
</p>

</body>
</html>
