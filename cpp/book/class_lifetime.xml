<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="xhtml.xsl"?>

<chapter xmlns="http://www.example.com/postrisc"
 id="class_lifetime"
 description="Инициализация, присваивание и уничтожение класса"
>
<title>Инициализация, присваивание и уничтожение класса</title>

<preface>

<p>В этой главе мы детально изучим автоматическую инициализацию,
присваивание и уничтожение объектов классов в программе. Для поддержки
инициализации служит конструктор - определенная проектировщиком функция
(возможно, перегруженная), которая автоматически применяется к каждому
объекту класса перед его первым использованием. Парная по отношению к
конструктору функция, деструктор, автоматически применяется к каждому
объекту класса по окончании его использования и предназначена для
освобождения ресурсов, захваченных либо в конструкторе класса, либо на
протяжении его жизни.
</p>

<p>По умолчанию как инициализация, так и присваивание одного объекта
класса другому выполняются почленно, т.е. путем последовательного
копирования всех членов. Хотя этого обычно достаточно, при некоторых
обстоятельствах такая семантика оказывается неадекватной. Тогда
проектировщик класса должен предоставить специальный копирующий
конструктор и копирующий оператор присваивания. Самое сложное в
поддержке этих функций-членов - понять, что они должны быть написаны.
</p>

</preface>

<section id="class_init">
<title>Инициализация класса</title>

<p>Рассмотрим следующее определение класса:
</p>

<div class="lang-cpp"><![CDATA[class Data {
public:
   int ival;
   char *ptr;
};]]></div>

<p>Чтобы безопасно пользоваться объектом класса, необходимо правильно
инициализировать его члены. Однако смысл этого действия для разных
классов различен. Например, может ли ival содержать отрицательное
значение или нуль? Каковы правильные начальные значения обоих членов
класса? Мы не ответим на эти вопросы, не понимая абстракции,
представляемой классом. Если с его помощью описываются служащие
компании, то ptr, вероятно, указывает на фамилию служащего, а ival -
его уникальный номер. Тогда отрицательное или нулевое значения
ошибочны. Если же класс представляет текущую температуру в городе, то
допустимы любые значения ival. Возможно также, что класс Data
представляет строку со счетчиком ссылок: в таком случае ival содержит
текущее число ссылок на строку по адресу ptr. При такой абстракции ival
инициализируется значением 1; как только значение становится равным 0,
объект класса уничтожается.
</p>

<p>Мнемонические имена класса и обоих его членов сделали бы,
конечно, его назначение более понятным для читателя программы, но не
дали бы никакой дополнительной информации компилятору. Чтобы компилятор
понимал наши намерения, мы должны предоставить одну или несколько
перегруженных функций инициализации - конструкторов. Подходящий
конструктор выбирается в зависимости от множества начальных значений,
указанных при определении объекта. Например, любая из приведенных ниже
инструкций представляет корректную инициализацию объекта класса Data:
</p>

<div class="lang-cpp"><![CDATA[Data dat01( "Venus and the Graces", 107925 );
Data dat02( "about" );
Data dat03( 107925 );
Data dat04;]]></div>
<p>Бывают ситуации (как в случае с dat04), когда нам нужен объект
класса, но его начальные значения мы еще не знаем. Возможно, они станут
известны позже. Однако начальное значение задать необходимо, хотя бы
такое, которое показывает, что разумное начальное значение еще не
присвоено. Другими словами, инициализация объекта иногда сводится к
тому, чтобы показать, что он еще не инициализирован. Большинство
классов предоставляют специальный конструктор по умолчанию, для
которого не требуется задавать начальных значений. Как правило, он
инициализирует объект таким образом, чтобы позже можно было понять, что
реальной инициализации еще не проводилось.
</p>

<p>Обязан ли наш класс Data иметь конструктор? Нет, поскольку все
его члены открыты. Унаследованный из языка C механизм поддерживает
явную инициализацию, аналогичную используемой при инициализации
массивов:
</p>

<div class="lang-cpp"><![CDATA[
int main() {
   // local1.ival = 0; local1.ptr = 0
   Data local1 = { 0, 0 };

   // local2.ival = 1024;
   // local3.ptr = "Anna Livia Plurabelle"
   Data.local2 - { 1024, "Anna Livia Plurabelle" };

   // ...
}]]></div>
<p>Значения присваиваются позиционно, на основе порядка, в котором
объявляются данные-члены. Следующий пример приводит к ошибке
компиляции, так как ival объявлен перед ptr:
</p>
<div class="lang-cpp"><![CDATA[// ошибка: ival = "Anna Livia Plurabelle";
//         ptr = 1024
Data.local2 - { "Anna Livia Plurabelle", 1024 };]]></div>
<p>Явная инициализация имеет два основных недостатка. Во-первых, она
может быть применена лишь для объектов классов, все члены которых
открыты (т.е. эта инициализация не поддерживает инкапсуляции данных и
абстрактных типов - их не было в языке C, откуда она заимствована). А
во-вторых, такая форма требует вмешательства программиста, что
увеличивает вероятность появления ошибок (забыл включить список
инициализации или перепутал порядок следования инициализаторов в нем).
</p>

<p>Так нужно ли применять явную инициализацию вместо
конструкторов? Да. Для некоторых приложений более эффективно
использовать список для инициализации больших структур постоянными
значениями. К примеру, мы можем таким образом построить палитру цветов
или включить в текст программы фиксированные координаты вершин и
значения в узлах сложной геометрической модели. В подобных случаях
инициализация выполняется во время загрузки, что сокращает затраты
времени на запуск конструктора, даже если он определен как встроенный.
Это особенно удобно при работе с глобальными объектами1.
</p>

<p>Однако в общем случае предпочтительным методом инициализации
является конструктор, который гарантированно будет вызван компилятором
для каждого объекта до его первого использования. В следующем разделе
мы познакомимся с конструкторами детально.
</p>

</section>

<section id="class_constructor">
<title>Конструктор класса</title>

<p>Среди других функций-членов конструктор выделяется тем, что его имя
совпадает с именем класса. Для объявления конструктора по умолчанию мы
пишем2:
</p>

<div class="lang-cpp"><![CDATA[class Account {
public:
   // конструктор по умолчанию ...
   Account();
   // ...
private:
   char *_name;
   unsigned int _acct_nmbr;
   double _balance;
};]]></div>
<p>Единственное синтаксическое ограничение, налагаемое на конструктор,
состоит в том, что он не должен иметь тип возвращаемого значения, даже
void. Поэтому следующие объявления ошибочны:
</p>

<div class="lang-cpp"><![CDATA[// ошибки: у конструктора не может быть типа возвращаемого значения
void     Account::Account() { ... }
Account* Account::Account( const char *pc ) { ... }]]></div>

<p>Количество конструкторов у одного класса может быть любым, лишь бы все они имели разные списки формальных параметров.
</p>

<p>Откуда мы знаем, сколько и каких конструкторов определить? Как
минимум, необходимо присвоить начальное значение каждому члену, который
в этом нуждается. Например, номер счета либо задается явно, либо
генерируется автоматически таким образом, чтобы гарантировать его
уникальность. Предположим, что он будет создаваться автоматически.
Тогда мы должны разрешить инициализировать оставшиеся два члена _name и _balance:
</p>

<div class="lang-cpp"><![CDATA[Account( const char *name, double open_balance );]]></div>
<p>Объект класса Account, инициализируемый конструктором, можно объявить следующим образом:
</p>
<div class="lang-cpp"><![CDATA[Account newAcct( "Mikey Matz", 0 );]]></div>

<p>Если же есть много счетов, для которых начальный баланс равен 0, то
полезно иметь конструктор, задающий только имя владельца и
автоматически инициализирующий _balance нулем. Один из способов сделать
это - предоставить конструктор вида:
</p>

<div class="lang-cpp"><![CDATA[Account( const char *name );]]></div>

<p>Другой способ - включить в конструктор с двумя параметрами значение по умолчанию, равное нулю:
</p>
<div class="lang-cpp"><![CDATA[Account( const char *name, double open_balance = 0.0 );]]></div>
<p>Оба конструктора обладают необходимой пользователю
функциональностью, поэтому оба решения приемлемы. Мы предпочитаем
использовать аргумент по умолчанию, поскольку в такой ситуации общее
число конструкторов класса сокращается.
</p>

<p>Нужно ли поддерживать также задание одного лишь начального
баланса без указания имени клиента? В данном случае спецификация класса
явно запрещает это. Наш конструктор с двумя параметрами, из которых
второй имеет значение по умолчанию, предоставляет полный интерфейс для
указания начальных значений тех членов класса Account, которые могут
быть инициализированы пользователем:
</p>

<div class="lang-cpp"><![CDATA[class Account {
public:
   // конструктор по умолчанию ...
   Account();

   // имена параметров в объявлении указывать необязательно
   Account( const char*, double=0.0 );

   const char* name() { return name; }
   // ...
private:
   // ...
};]]></div>
<p>Ниже приведены два примера правильного определения объекта класса Account, где конструктору передается один или два аргумента:
</p>
<div class="lang-cpp"><![CDATA[int main() {
   // правильно: в обоих случаях вызывается конструктор
   // с двумя параметрами
   Account acct( "Ethan Stern" );
   Account *pact = new Account( "Michael Lieberman", 5000 );

   if ( strcmp( acct.name(), pact->name() ))
      // ...
}]]></div>
<p>C++ требует, чтобы конструктор применялся к определенному объекту до
его первого использования. Это означает, что как для acct, так и для
объекта, на который указывает pact, конструктор будет вызван перед
проверкой в инструкции if.
</p>

<p>Компилятор перестраивает нашу программу, вставляя вызовы
конструкторов. Вот как, по всей вероятности, будет модифицировано
определение acct внутри main():
</p>
<div class="lang-cpp"><![CDATA[// псевдокод на C++,
// иллюстрирующий внутреннюю вставку конструктора
int main() {
   Account acct;
   acct.Account::Account("Ethan Stern", 0.0);
   // ...
}]]></div>
<p>Конечно, если конструктор определен как встроенный, то он подставляется в точке вызова.
</p>

<p>Обработка оператора new несколько сложнее. Конструктор
вызывается только тогда, когда он успешно выделил память. Модификация
определения pact в несколько упрощенном виде выглядит так:
</p>
<div class="lang-cpp"><![CDATA[// псевдокод на C++,
// иллюстрирующий внутреннюю вставку конструктора при обработке new
int main() {
   // ...

   Account *pact;
   try {
        pact = _new( sizeof( Account ));
        pact->Acct.Account::Account(
                 "Michael Liebarman", 5000.0);
   }
   catch( std::bad_alloc ) {
          // оператор new закончился неудачей:
          // конструктор не вызывается
   }
   // ...
}]]></div>
<p>Существует три в общем случае эквивалентных формы задания аргументов конструктора:
</p>
<div class="lang-cpp"><![CDATA[// в общем случае эти формы эквивалентны
Account acct1( "Anna Press" );
Account acct2 = Account( "Anna Press" );
Account acct3 = "Anna Press";]]></div>
<p>Форма acct3 может использоваться только при задании единственного
аргумента. Если аргументов два или более, мы рекомендуем пользоваться
формой acct1, хотя допустима и acct2.
</p>
<div class="lang-cpp"><![CDATA[// рекомендуемая форма вызова конструктора
Account acct1( "Anna Press" );]]></div>
<p>Новички часто допускают ошибку при объявлении объекта, инициализированного конструктором по умолчанию:
</p>
<div class="lang-cpp"><![CDATA[// увы! работает не так, как ожидалось
Account newAccount();]]></div>
<p>Эта инструкция компилируется без ошибок. Однако при попытке использовать объект в таком контексте:
</p>
<div class="lang-cpp"><![CDATA[// ошибка компиляции ...
if ( ! newAccount.name() ) ...]]></div>
<p>компилятор не сможет применить к функции нотацию доступа к членам класса. Определение
</p>
<div class="lang-cpp"><![CDATA[// определяет функцию newAccount,
// а не объект класса
Account newAccount();]]></div>
<p>интерпретируется компилятором как определение функции без
параметров, которая возвращает объект типа Account. Правильное
объявление объекта класса, инициализируемого конструктором по
умолчанию, не содержит пустых скобок:
</p>
<div class="lang-cpp"><![CDATA[// правильно: определяется объект класса ...
Account newAccount;]]></div>
<p>Определять объект класса, не указывая списка фактических аргументов,
можно в том случае, если в нем либо объявлен конструктор по умолчанию,
либо вообще нет объявлений конструкторов. Если в классе объявлен хотя
бы один конструктор, то не разрешается определять объект класса, не
вызывая ни одного из них. В частности, если в классе определен
конструктор, принимающий один или более параметров, но не определен
конструктор по умолчанию, то в каждом определении объекта такого класса
должны присутствовать необходимые аргументы. Можно возразить, что не
имеет смысла определять конструктор по умолчанию для класса Account,
поскольку не бывает счетов без имени владельца. В пересмотренной версии
класса Account такой конструктор исключен:
</p>
<div class="lang-cpp"><![CDATA[class Account {
public:
   // имена параметров в объявлении указывать необязательно
   Account( const char*, double=0.0 );

   const char* name() { return name; }
   // ...
private:
   // ...
};]]></div>
<p>Теперь при объявлении каждого объекта Account в конструкторе
обязательно надо указать как минимум аргумент типа C-строки, но это
скорее всего бессмысленно. Почему? Контейнерные классы (например,
vector) требуют, чтобы для класса помещаемых в них элементов был либо
задан конструктор по умолчанию, либо вообще никаких конструкторов.
Аналогичная ситуация имеет место при выделении динамического массива
объектов класса. Так, следующая инструкция вызвала бы ошибку компиляции
для новой версии Account:
</p>
<div class="lang-cpp"><![CDATA[// ошибка: требуется конструктор по умолчанию для класса Account
Account *pact = new Account[ new_client_cnt ];]]></div>
<p>На практике часто требуется задавать конструктор по умолчанию, если имеются какие-либо другие конструкторы.
</p>

<p>А если для класса нет разумных значений по умолчанию? Например,
класс Account требует задавать для любого объекта фамилию владельца
счета. В таком случае лучше всего установить состояние объекта так,
чтобы было видно, что он еще не инициализирован корректными значениями:
</p>
<div class="lang-cpp"><![CDATA[// конструктор по умолчанию для класса Account
inline Account::Account() {
   _name = 0;
   _balance = 0.0;
   _acct_nmbr = 0;
}]]></div>
<p>Однако в функции-члены класса Account придется включить проверку целостности объекта перед его использованием.
</p>

<p>Существует и альтернативный синтаксис: список инициализации
членов, в котором через запятую указываются имена и начальные значения.
Например, конструктор по умолчанию можно переписать следующим образом:
</p>
<div class="lang-cpp"><![CDATA[// конструктор по умолчанию класса Account с использованием
// списка инициализации членов
inline Account::Account()
       : _name(0),
         _balance( 0.0 ), _acct_nmbr( 0 )
{}]]></div>
<p>Такой список допустим только в определении, но не в объявлении
конструктора. Он помещается между списком параметров и телом
конструктора и отделяется двоеточием. Вот как выглядит наш конструктор
с двумя параметрами при частичном использовании списка инициализации
членов:
</p>
<div class="lang-cpp"><![CDATA[inline Account::
Account( const char* name, double opening_bal )
       : _balance( opening_bal )
{
      _name = new char[ strlen(name)+1 ];
      strcpy( _name, name );

      _acct_nmbr = get_unique_acct_nmbr();
}]]></div>
<p>get_unique_acct_nmbr() - это не являющаяся открытой функция-член,
которая возвращает гарантированно не использованный ранее номер счета.
</p>

<p>Конструктор нельзя объявлять с ключевыми словами const или volatile (см. раздел 13.3.5), поэтому приведенные записи неверны:
</p>
<div class="lang-cpp"><![CDATA[class Account {
public:
   Account() const;     // ошибка
   Account() volatile;  // ошибка
   // ...
};]]></div>
<p>Это не означает, что объекты класса с такими спецификаторами
запрещено инициализировать конструктором. Просто к объекту применяется
подходящий конструктор, причем без учета спецификаторов в объявлении
объекта. Константность объекта класса устанавливается после того, как
работа по его инициализации завершена, и пропадает в момент вызова
деструктора. Таким образом, объект класса со спецификатором const
считается константным с момента завершения работы конструктора до
момента запуска деструктора. То же самое относится и к спецификатору
volatile.
</p>

<p>Рассмотрим следующий фрагмент программы:
</p>
<div class="lang-cpp"><![CDATA[
// в каком-то заголовочном файле
extern void print(const Account& acct);
// ...
int main() {
   // преобразует строку "oops" в объект класса Account
   // с помощью конструктора Account::Account( "oops", 0.0 )
   print( "oops" );

   // ...
}
]]></div>

<p>По умолчанию конструктор с одним параметром (или с несколькими - при
условии, что все параметры, кроме первого, имеют значения по умолчанию)
играет роль оператора преобразования. В этом фрагменте программы
конструктор Account неявно применяется компилятором для трансформации
литеральной строки в объект класса Account при вызове print(), хотя в
данной ситуации такое преобразование не нужно.
</p>

<p>Непреднамеренные неявные преобразования классов, например трансформация "oops" в объект класса Account,
оказались источником трудно обнаруживаемых ошибок.
Поэтому в стандарт C++ было добавлено ключевое слово explicit, говорящее компилятору, что такие преобразования не нужны:
</p>

<div class="lang-cpp"><![CDATA[
class Account {
public:
   explicit Account(const char*, double = 0.0);
};
]]></div>

<p>Данный модификатор применим только к конструктору.
</p>

</section>

<section id="class_constructor_def">
<title>Конструктор по умолчанию</title>

<p>Конструктором по умолчанию называется конструктор, который можно
вызывать, не задавая аргументов. Это не значит, что такой конструктор
не может принимать аргументов; просто с каждым его формальным
параметром ассоциировано значение по умолчанию:
</p>
<div class="lang-cpp"><![CDATA[// все это конструкторы по умолчанию
Account::Account() { ... }
iStack::iStack( int size = 0 ) { ... }
Complex::Complex(double re=0.0, double im=0.0) { ... }]]></div>
<p>Когда мы пишем:
</p>
<div class="lang-cpp"><![CDATA[int main() {
   Account acct;
   // ...
}]]></div>
<p>то компилятор сначала проверяет, определен ли для класса Account конструктор по умолчанию. Возникает одна из следующих ситуаций:
</p>

<ol>
<li>Такой конструктор определен. Тогда он применяется к acct.</li>
<li>Конструктор определен, но не является открытым. В данном случае определение acct помечается компилятором как ошибка: у функции main() нет прав доступа.</li>
<li>Конструктор по умолчанию не определен, но есть один или несколько конструкторов, требующих задания аргументов. Определение acct помечается как ошибка: слишком мало аргументов у конструктора.</li>
<li>Нет ни конструктора по умолчанию, ни какого-либо другого. Определение считается корректным, acct не инициализируется, конструктор не вызывается.</li>
</ol>

<p>Пункты 1 и 3 должны быть уже достаточно понятны (если это не так,
перечитайте данную главу) Посмотрим более внимательно на пункты 2 и 4.
</p>

<p>Допустим, что все члены класса Account объявлены открытыми и не объявлено никакого конструктора:
</p>

<div class="lang-cpp"><![CDATA[class Account {
public:
   char           *_name;
   unsigned int   _acct_nmbr;
   double         _balance;
};]]></div>

<p>В таком случае при определении объекта класса Account специальной
инициализации не производится. Начальные значения всех трех членов
зависят только от контекста, в котором встретилось определение.
Например, для статических объектов гарантируется, что все их члены
будут обнулены (как и для объектов, не являющихся экземплярами
классов):
</p>
<div class="lang-cpp"><![CDATA[// статический класс хранения
// вся ассоциированная с объектом память обнуляется

Account global_scope_acct;
static Account file_scope_acct;

Account foo() {
   static Account local_static_acct;
   // ...
}]]></div>
<p>Однако объекты, определенные локально или распределенные
динамически, в начальный момент будут содержать случайный набор битов,
оставшихся в стеке программы:
</p>
<div class="lang-cpp"><![CDATA[// локальные и распределенные из хипа объекты не инициализированы
// до момента явной инициализации или присваивания

Account bar() {
   Account local_acct;
   Account *heap_acct = new Account;
   // ...
}]]></div>
<p>Новички часто полагают, что компилятор автоматически генерирует
конструктор, если он не задан, и применяет его для инициализации членов
класса. Для Account в том виде, в каком мы его определили, это неверно.
Никакой конструктор не генерируется и не вызывается. Для более сложных
классов, имеющих члены, которые сами являются классами, или
использующих наследование, это отчасти справедливо: конструктор по
умолчанию может быть сгенерирован, но и он не присваивает начальных
значений членам встроенных или составных типов, таким, как указатели
или массивы.
</p>

<p>Если мы хотим, чтобы подобные члены инициализировались, то
должны сами позаботиться об этом, предоставив один или несколько
конструкторов. В противном случае отличить корректное значение члена
такого типа от неинициализированного, если объект создан локально или
распределен из хипа,3 практически невозможно.
</p>

</section>

<section id="class_constructor_rights">
<title>Ограничение прав на создание объекта</title>

<p>Доступность конструктора определяется тем, в какой секции класса он
объявлен. Мы можем ограничить или явно запретить некоторые формы
создания объектов, если поместим соответствующий конструктор в
неоткрытую секцию. В примере ниже конструктор по умолчанию класса
Account объявлен закрытым, а с двумя параметрами - открытым:
</p>
<div class="lang-cpp"><![CDATA[class Account {
   friend class vector<Account>;
public:
   explicit Account( const char*, double = 0.0 );
   // ...
private:
   Account();
   // ...
};]]></div>
<p>Обычная программа сможет теперь определять объекты класса Account,
лишь указав как имя владельца счета, так и начальный баланс. Однако
функции-члены Account и дружественный ему класс vector могут создавать
объекты, пользуясь любым конструктором.
</p>

<p>Конструкторы, не являющиеся открытыми, в реальных программах C++ чаще всего используются для:
</p>

<ul>
<li>предотвращения копирования одного объекта в другой объект того же класса (эта проблема рассматривается в следующем подразделе);</li>
<li>указания на то, что конструктор должен вызываться только в случае,
когда данный класс выступает в роли базового в иерархии наследования, а
не для создания объектов, которыми программа может манипулировать
напрямую (см. обсуждение наследования и объектно-ориентированного
программирования в главе 17).</li>
</ul>

</section>

<section id="class_constructor_copy">
<title>Копирующий конструктор</title>

<p>Инициализация объекта другим объектом того же класса называется
почленной инициализацией по умолчанию. Копирование одного объекта в
другой выполняется путем последовательного копирования каждого
нестатического члена. Проектировщик класса может изменить такое
поведение, предоставив специальный копирующий конструктор. Если он
определен, то вызывается всякий раз, когда один объект инициализируется
другим объектом того же класса.
</p>

<p>Часто почленная инициализация не обеспечивает корректного
поведения класса. Поэтому мы явно определяем копирующий конструктор. В
нашем классе Account это необходимо, иначе два объекта будут иметь
одинаковые номера счетов, что запрещено спецификацией класса.
</p>

<p>Копирующий конструктор принимает в качестве формального
параметра ссылку на объект класса (традиционно объявляемую со
спецификатором const). Вот его реализация:
</p>

<div class="lang-cpp"><![CDATA[
inline Account::Account(const Account& rhs)
   : _balance( rhs._balance )
{
    _name = new char[ strlen(rhs._name) + 1 ];
    strcpy( _name, rhs._name );
    // копировать rhs._acct_nmbr нельзя
    _acct_nmbr = get_unique_acct_nmbr();
}
]]></div>

<p>Когда мы пишем:
</p>

<div class="lang-cpp"><![CDATA[Account acct2( acct1 );]]></div>

<p>компилятор определяет, объявлен ли явный копирующий конструктор для
класса Account. Если он объявлен и доступен, то он и вызывается; а если
недоступен, то определение acct2 считается ошибкой. В случае, когда
копирующий конструктор не объявлен, выполняется почленная инициализация
по умолчанию. Если впоследствии объявление копирующего конструктора
будет добавлено или удалено, никаких изменений в программы
пользователей вносить не придется. Однако перекомпилировать их все же
необходимо. (Более подробно почленная инициализация рассматривается в
разделе 14.6.)
</p>

<p>Упражнение 14.1
</p>

<p>Какие из следующих утверждений ложны? Почему?
</p>

<ol>
<li>У класса должен быть хотя бы один конструктор.</li>
<li>Конструктор по умолчанию - это конструктор с пустым списком параметров.</li>
<li>Если разумных начальных значений у членов класса нет, то не следует предоставлять конструктор по умолчанию.</li>
<li>Если в классе нет конструктора по умолчанию, то компилятор генерирует его автоматически и инициализирует каждый член значением по умолчанию для соответствующего типа.</li>
</ol>

<p>Упражнение 14.2
</p>

<p>Предложите один или несколько конструкторов для данного множества членов. Объясните свой выбор:
</p>
<div class="lang-cpp"><![CDATA[class NoName {
public:
   // здесь должны быть конструкторы
   // ...
protected:
   char   *pstring;
   int    ival;
   double dval;
};]]></div>
<p>Упражнение 14.3
</p>

<p>Выберите одну из следующих абстракций (или предложите свою
собственную). Решите, какие данные (задаваемые пользователем) подходят
для представляющего эту абстракцию класса. Напишите соответствующий
набор конструкторов. Объясните свое решение.
</p>

<ol>
<li>Книга</li>
<li>Дата</li>
<li>Служащий</li>
<li>Транспортное средство</li><li>Объект
</li><li>Дерево</li>
</ol>

<p>Упражнение 14.4
</p>

<p>Пользуясь приведенным определением класса:
</p>
<div class="lang-cpp"><![CDATA[class Account {
public:
   Account();
   explicit Account( const char*, double=0.0 );
   // ...
};]]></div>
<p>объясните, что происходит в результате следующих определений:
</p>
<div class="lang-cpp"><![CDATA[(a) Account acct;
(b) Account acct2 = acct;
(c) Account acct3 = "Rena Stern ";
(d) Account acct4(  "Anna Engel ", 400.00 );
(e) Account acct5 = Account( acct3 );]]></div>
<p>Упражнение 14.5
</p>

<p>Параметр копирующего конструктора может и не быть константным, но обязан быть ссылкой. Почему ошибочна такая инструкция:
</p>

<div class="lang-cpp"><![CDATA[Account::Account( const Account rhs );]]></div>

</section>

<section id="class_destructor">
<title>Деструктор класса</title>

<p>Одна из целей, стоящих перед конструктором, - обеспечить
автоматическое выделение ресурса. Мы уже видели в примере с классом
Account конструктор, где с помощью оператора new выделяется память для
массива символов и присваивается уникальный номер счету. Можно также
представить ситуацию, когда нужно получить монопольный доступ к
разделяемой памяти или к критической секции потока. Для этого
необходима симметричная операция, обеспечивающая автоматическое
освобождение памяти или возврат ресурса по завершении времени жизни
объекта, - деструктор. Деструктор - это специальная определяемая
пользователем функция-член, которая автоматически вызывается, когда
объект выходит из области видимости или когда к указателю на объект
применяется операция delete. Имя этой функции образовано из имени
класса с предшествующим символом "тильда" (~). Деструктор не возвращает
значения и не принимает никаких параметров, а следовательно, не может
быть перегружен. Хотя разрешается определять несколько таких
функций-членов, лишь одна из них будет применяться ко всем объектам
класса. Вот, например, деструктор для нашего класса Account:
</p>
<div class="lang-cpp"><![CDATA[
class Account {
public:
    Account();
     explicit Account( const char*, double=0.0 );
    Account(const Account&);
     ~Account();
     // ...
private:
    char         *_name;
    unsigned int _acct_nmbr;
    double       _balance;
};

inline
Account::~Account()
{
      delete [] _name;
      return_acct_number( _acct_nnmbr );
}]]></div>
<p>Обратите внимание, что в нашем деструкторе не сбрасываются значения членов:
</p>
<div class="lang-cpp"><![CDATA[inline
Account::~Account()
{
      // необходимо
      delete [] _name;
      return_acct_number( _acct_nnmbr );
      // необязательно
      _name = 0;
      _balance = 0.0;
      _acct_nmbr = 0;
}]]></div>
<p>Делать это необязательно, поскольку отведенная под члены объекта память все равно будет освобождена. Рассмотрим следующий класс:
</p>
<div class="lang-cpp"><![CDATA[class Point3d {
public:
   // ...
private:
   float x, y, z;
};]]></div>
<p>Конструктор здесь необходим для инициализации членов, представляющих
координаты точки. Нужен ли деструктор? Нет. Для объекта класса Point3d
не требуется освобождать ресурсы: память выделяется и освобождается
компилятором автоматически в начале и в конце его жизни.
</p>

<p>В общем случае, если члены класса имеют простые значения,
скажем, координаты точки, то деструктор не нужен. Не для каждого класса
необходим деструктор, даже если у него есть один или более
конструкторов. Основной целью деструктора является освобождения
ресурсов, выделенных либо в конструкторе, либо во время жизни объекта,
например освобождение замка или памяти, выделенной оператором new.
</p>

<p>Но функции деструктора не ограничены только освобождением
ресурсов. Он может реализовывать любую операцию, которая по замыслу
проектировщика класса должна быть выполнена сразу по окончании
использования объекта. Так, широко распространенным приемом для
измерения производительности программы является определение класса
Timer, в конструкторе которого запускается та или иная форма
программного таймера. Деструктор останавливает таймер и выводит
результаты замеров. Объект данного класса можно условно определять в
критических участках программы, которые мы хотим профилировать, таким
образом:
</p>
<div class="lang-cpp"><![CDATA[{
   // начало критического участка программы
#ifdef PROFILE
   Timer t;
#endif
   // критический участок
   // t уничтожается автоматически
   // отображается затраченное время ...
}]]></div>

<p>Чтобы убедиться в том, что мы понимаем поведение деструктора (да и конструктора тоже), разберем следующий пример:
</p>

<div class="lang-cpp"><![CDATA[
#include "Account.h"
Account global( "James Joyce" ); //ctr!

int main() {
  Account local( "Anna Livia Plurabelle", 10000 ); //ctr!
  Account& loc_ref = global;
  Account *pact = 0;

  {
    Account local_too( "Stephen Hero" );  //ctr!
    pact = new Account( "Stephen Dedalus" );  //ctr!
  }

  delete pact;
}
]]></div>

<p>Сколько здесь вызывается конструкторов? Четыре:
один для глобального объекта global;
по одному для каждого из локальных объектов local и local_too,
и один для объекта, распределенного в хипе (pact).
Ни объявление ссылки loc_ref на объект,
ни объявление указателя pact не приводят к вызову конструктора.
Ссылка - это псевдоним для уже сконструированного объекта, в данном случае для global.
Указатель также лишь адресует объект, созданный ранее (в данном случае распределенный в хипе), или не адресует никакого объекта.
</p>

<p>Аналогично вызываются четыре деструктора: для глобального
объекта global, объявленного в строке (2), для двух локальных объектов
и для объекта в хипе при вызове delete в строке (14). Однако в
программе нет инструкции, с которой можно связать вызов деструктора.
Компилятор просто вставляет эти вызовы за последним использованием
объекта, но перед закрытием соответствующей области видимости.
</p>

<p>Конструкторы и деструкторы глобальных объектов вызываются на
стадиях инициализации и завершения выполнения программы. Хотя такие
объекты нормально ведут себя при использовании в том файле, где они
определены, но их применение в ситуации, когда производятся ссылки
через границы файлов, становится в C++ серьезной проблемой.4
</p>

<p>Деструктор не вызывается, когда из области видимости выходит ссылка или указатель на объект (сам объект при этом остается).
</p>

<p>С++ с помощью внутренних механизмов препятствует применению
оператора delete к указателю, не адресующему никакого объекта, так что
соответствующие проверки кода необязательны:
</p>

<div class="lang-cpp"><![CDATA[
// необязательно: неявно выполняется компилятором
if (pact != 0 ) delete pact;
]]></div>

<p>Всякий раз, когда внутри функции этот оператор применяется к
отдельному объекту, размещенному в хипе, лучше использовать объект
класса auto_ptr, а не обычный указатель (см. обсуждение класса auto_ptr
в разделе 8.4). Это особенно важно потому, что пропущенный вызов delete
(скажем, в случае, когда возбуждается исключение) ведет не только к
утечке памяти, но и к пропуску вызова деструктора. Ниже приводится
пример программы, переписанной с использованием auto_ptr (она слегка
модифицирована, так как объект класса auto_ptr может быть явно
переустановлен для адресации другого объекта только присваиванием его
другому auto_ptr):
</p>

<div class="lang-cpp"><![CDATA[
#include <memory>
#include "Account.h"
Account global( "James Joyce" );
int main() {
   Account local( "Anna Livia Plurabelle", 10000 );
   Account& loc_ref = global;
   auto_ptr<account> pact( new Account( "Stephen Dedalus" ));

   {
      Account local_too( "Stephen Hero" );
   }

   // объект auto_ptr уничтожается здесь
}
]]></div>

</section>

<section id="class_destructor_call">
<title>Явный вызов деструктора</title>

<p>Иногда вызывать деструктор для некоторого объекта приходится явно. 
Особенно часто такая необходимость возникает в связи с оператором new.
Рассмотрим пример. Когда мы пишем:
</p>

<div class="lang-cpp"><![CDATA[char *arena = new char[ sizeof Image ];]]></div>

<p>то из хипа выделяется память, размер которой равен размеру объекта
типа Image, она не инициализирована и заполнена случайными битами. Если
же написать:
</p>
<div class="lang-cpp"><![CDATA[Image *ptr = new (arena) Image( "Quasimodo");]]></div>
<p>то никакой новой памяти не выделяется. Вместо этого переменной ptr
присваивается адрес, ассоциированный с переменной arena. Теперь память,
на которую указывает ptr, интерпретируется как занимаемая объектом
класса Image, и конструктор применяется к уже существующей области.
Таким образом, оператор размещения new() позволяет сконструировать
объект в ранее выделенной области памяти.
</p>

<p>Закончив работать с изображением Quasimodo, мы можем произвести
какие-то операции с изображением Esmerelda, размещенным по тому же
адресу arena в памяти:
</p>
<div class="lang-cpp"><![CDATA[Image *ptr = new (arena) Image( "Esmerelda" );]]></div>

<p>Однако изображение Quasimodo при этом будет затерто, а мы его
модифицировали и хотели бы записать на диск. Обычно сохранение
выполняется в деструкторе класса Image, но если мы применим оператор
delete:
</p>

<div class="lang-cpp"><![CDATA[// плохо: не только вызывает деструктор, но и освобождает память
delete ptr;]]></div>

<p>то, помимо вызова деструктора, еще и возвратим в хип память, чего
делать не следовало бы. Вместо этого можно явно вызвать деструктор
класса Image:
</p>

<div class="lang-cpp"><![CDATA[ptr->~Image();]]></div>
<p>сохранив отведенную под изображение память для последующего вызова оператора размещения new.
</p>

<p>Отметим, что, хотя ptr и arena адресуют одну и ту же область памяти в хипе, применение оператора delete к arena
</p>

<div class="lang-cpp"><![CDATA[// деструктор не вызывается
delete arena;]]></div>
<p>не приводит к вызову деструктора класса Image, так как arena имеет
тип char*, а компилятор вызывает деструктор только тогда, когда
операндом в delete является указатель на объект класса, имеющего
деструктор.
</p>

</section>

<section id="class_destructor_codesize">
<title>Опасность увеличения размера программы</title>

<p>Встроенный деструктор может стать причиной непредвиденного
увеличения размера программы, поскольку он вставляется в каждой точке
выхода внутри функции для каждого активного локального объекта.
Например, в следующем фрагменте
</p>
<div class="lang-cpp"><![CDATA[Account acct( "Tina Lee" );
int swt;
// ...
switch( swt ) {
case 0:
   return;
case 1:
   // что-то сделать
   return;
case 2:
   // сделать что-то другое
   return;
// и так далее
}]]></div>
<p>компилятор подставит деструктор перед каждой инструкцией return.
Деструктор класса Account невелик, и затраты времени и памяти на его
подстановку тоже малы. В противном случае придется либо объявить
деструктор невстроенным, либо реорганизовать программу. В примере выше
инструкцию return в каждой метке case можно заменить инструкцией break
с тем, чтобы у функции была единственная точка выхода:
</p>
<div class="lang-cpp"><![CDATA[// переписано для обеспечения единственной точки выхода
switch( swt ) {
case 0:
   break;
case 1:
   // что-то сделать
   break;
case 2:
   // сделать что-то другое
   break;
// и так далее
}

// единственная точка выхода
return;]]></div>
<p>Упражнение 14.6
</p>

<p>Напишите подходящий деструктор для приведенного набора членов
класса, среди которых pstring адресует динамически выделенный массив
символов:
</p>
<div class="lang-cpp"><![CDATA[class NoName {
public:
   ~NoName();
   // ...
private:
   char    *pstring;
   int     ival;
   double  dval;
};]]></div>
<p>Упражнение 14.7
</p>

<p>Необходим ли деструктор для класса, который вы выбрали в упражнении 14.3?
Если нет, объясните почему. В противном случае предложите реализацию.
</p>

<p>Упражнение 14.8
</p>

<p>Сколько раз вызываются деструкторы в следующем фрагменте:
</p>
<div class="lang-cpp"><![CDATA[
void mumble(const char *name, fouble balance, char acct_type) {
   Account acct;

   if ( ! name )
      return;

   if ( balance <= 99 )
      return;

   switch( acct_type ) {
      case 'z': return;
      case 'a':
      case 'b': return;
   }

   // ...
}
]]></div>

</section>

<section id="class_arrays">
<title>Массивы и векторы объектов</title>

<p>Массив объектов класса определяется точно так же, как массив элементов встроенного типа. Например:
</p>
<div class="lang-cpp"><![CDATA[Account table[ 16 ];]]></div>

<p>определяет массив из 16 объектов Account. Каждый элемент по очереди
инициализируется конструктором по умолчанию. Можно и явно передать
конструкторам аргументы внутри заключенного в фигурные скобки списка
инициализации массива. Строка:
</p>
<div class="lang-cpp"><![CDATA[Account pooh_pals[] = { "Piglet", "Eeyore", "Tigger" };]]></div>
<p>определяет массив из трех элементов, инициализируемых конструкторами:
</p>
<div class="lang-cpp"><![CDATA[Account( "Piglet", 0.0 );   // первый элемент (Пятачок)
Account( "Eeyore", 0.0 );   // второй элемент (Иа-Иа)
Account( "Tigger", 0.0 );   // третий элемент (Тигра)]]></div>
<p>Один аргумент можно задать явно, как в примере выше. Если же
необходимо передать несколько аргументов, то придется воспользоваться
явным вызовом конструктора:
</p>
<div class="lang-cpp"><![CDATA[Account pooh_pals[] = {
   Account( "Piglet", 1000.0 ),
   Account( "Eeyore", 1000.0 ),
   Account( "Tigger", 1000.0 )
};]]></div>
<p>Чтобы включить в список инициализации массива конструктор по умолчанию, мы употребляем явный вызов с пустым списком параметров:
</p>
<div class="lang-cpp"><![CDATA[Account pooh_pals[] = {
   Account( "Woozle", 10.0 ),        // Бука
   Account( "Heffalump", 10.0 ),     // Слонопотам
   Account();
};]]></div>
<p>Эквивалентный массив из трех элементов можно объявить и так:
</p>
<div class="lang-cpp"><![CDATA[Account pooh_pals[3] = {
   Account( "Woozle", 10.0 ),
   Account( "Heffalump", 10.0 )
};]]></div>
<p>Таким образом, члены списка инициализации последовательно
используются для заполнения очередного элемента массива. Те элементы,
для которых явные аргументы не заданы, инициализируются конструктором
по умолчанию. Если его нет, то в списке должны быть заданы аргументы
конструктора для каждого элемента массива.
</p>

<p>Доступ к отдельным элементам массива объектов производится с
помощью оператора взятия индекса, как и для массива элементов любого из
встроенных типов. Например:
</p>
<div class="lang-cpp"><![CDATA[pooh_pals[0];
обращается к Piglet, а
pooh_pals[1];]]></div>
<p>к Eeyore и т.д. Для доступа к членам объекта, находящегося в
некотором элементе массива, мы сочетаем операторы взятия индекса и
доступа к членам:
</p>
<div class="lang-cpp"><![CDATA[pooh_pals[1]._name != pooh_pals[2]._name;]]></div>
<p>Не существует способа явно указать начальные значения элементов
массива, память для которого выделена из хипа. Если класс поддерживает
создание динамических массивов с помощью оператора new, он должен либо
иметь конструктор по умолчанию, либо не иметь никаких конструкторов. На
практике почти у всех классов есть такой конструктор.
</p>

<p>Объявление
</p>

<div class="lang-cpp"><![CDATA[Account *pact = new Account[ 10 ];]]></div>

<p>создает в памяти, выделенной из хипа, массив из десяти объектов
класса Account, причем каждый инициализируется конструктором по
умолчанию.
</p>

<p>Чтобы уничтожить массив, адресованный указателем pact, необходимо применить оператор delete. Однако написать
</p>
<div class="lang-cpp"><![CDATA[// увы! это не совсем правильно
delete pact;]]></div>
<p>недостаточно, так как pact при этом не идентифицируется как массив
объектов. В результате деструктор класса Account применяется лишь к
первому элементу массива. Чтобы применить его к каждому элементу, мы
должны включить пустую пару скобок между оператором delete и адресом
удаляемого объекта:
</p>
<div class="lang-cpp"><![CDATA[// правильно:
// показывает, что pact адресует массив
delete [] pact;]]></div>

<p>Пустая пара скобок говорит о том, что pact адресует именно массив.
Компилятор определяет, сколько в нем элементов, и применяет деструктор
к каждому из них.
</p>

</section>

<section id="class_array_heap">
<title>Инициализация массива, распределенного из кучи</title>

<p>По умолчанию инициализация массива объектов, распределенного из
хипа, проходит в два этапа: выделение памяти для массива, к каждому
элементу которого применяется конструктор по умолчанию, если он
определен, и последующее присваивание значения каждому элементу.
</p>

<p>Чтобы свести инициализацию к одному шагу, программист должен
вмешаться и поддержать следующую семантику: задать начальные значения
для всех или некоторых элементов массива и гарантировать применение
конструктора по умолчанию для тех элементов, начальные значения которых
не заданы. Ниже приведено одно из возможных программных решений, где
используется оператор размещения new:
</p>

<div class="lang-cpp"><![CDATA[#include <utility>
#include <vector>
#include <new>
#include <cstddef>
#include "Accounts.h"
typedef pair<char*, double>
 value_pair;
/* init_heap_array()
 *     объявлена как статическая функция-член
 *     обеспечивает выделение памяти из хипа и инициализацию
 *     массива объектов
 * init_values: пары начальных значений элементов массива
 * elem_count: число элементов в массиве
 *             если 0, то размером массива считается размер вектора
 *             init_values
 */
Account* Account::init_heap_array(
    vector<value_pair>& init_values,
    vector<value_pair>::size_type elem_count = 0 )
{
   vector<value_pair> ::size_type
          vec_size = init_value.size();

   if ( vec_size == 0 && elem_count == 0 )
      return 0;

   // размер массива равен либо elem_count,
   // либо, если elem_count == 0, размеру вектора ...
   size_t elems = elem_count
                  ? elem_count : vec_size();

   // получить блок памяти для размещения массива
   char *p = new char[sizeof(Account)*elems];

   // по отдельности инициализировать каждый элемент массива
   int offset = sizeof( Account );
   for ( int ix = 0; ix < elems; ++ix )
   {
        // смещение ix-ого элемента
        // если пара начальных значений задана,
        //      передать ее конструктору;
        // в противном случае вызвать конструктор по умолчанию

        if ( ix < vec_size )
           new( p+offset*ix ) Account( init_values[ix].first,
                                       init_values[ix].second );
        else new( p+offset*ix ) Account;
   }

   // отлично: элементы распределены и инициализированы;
   // вернуть указатель на первый элемент
   return (Account*)p;
}]]></div>
<p>Необходимо заранее выделить блок памяти, достаточный для хранения
запрошенного массива, как массив байт, чтобы избежать применения к
каждому элементу конструктора по умолчанию. Это делается в такой
инструкции:
</p>

<div class="lang-cpp"><![CDATA[char *p = new char[sizeof(Account)*elems];]]></div>

<p>Далее программа в цикле обходит этот блок, присваивая на каждой
итерации переменной p адрес следующего элемента и вызывая либо
конструктор с двумя параметрами, если задана пара начальных значений,
либо конструктор по умолчанию:
</p>

<div class="lang-cpp"><![CDATA[for ( int ix = 0; ix < elems; ++ix )
   {
       if ( ix < vec_size )
           new( p+offset*ix ) Account( init_values[ix].first,
                                       init_values[ix].second );
        else new( p+offset*ix ) Account;
   }]]></div>
<p>В разделе 14.3 говорилось, что оператор размещения new позволяет
применить конструктор класса к уже выделенной области памяти. В данном
случае мы используем new для поочередного применения конструктора
класса Account к каждому из выделенных элементов массива. Поскольку при
создании инициализированного массива мы подменили стандартный механизм
выделения памяти, то должны сами позаботиться о ее освобождении.
Оператор delete работать не будет:
</p>
<div class="lang-cpp"><![CDATA[delete [] ps;]]></div>
<p>Почему? Потому что ps (мы предполагаем, что эта переменная была
инициализирована вызовом init_heap_array()) указывает на блок памяти,
полученный не с помощью стандартного оператора new, поэтому число
элементов в массиве компилятору неизвестно. Так что всю работу придется
сделать самим:
</p>
<div class="lang-cpp"><![CDATA[void
Account::
dealloc_heap_array( Account *ps, size_t elems )
{
   for ( int ix = 0; ix < elems; ++ix )
       ps[ix].Account::~Account();

   delete [] reinterpret_cast<char*>(ps);
}]]></div>

<p>Если в функции инициализации мы пользовались арифметическими операциями над указателями для доступа к элементам:
</p>
<div class="lang-cpp"><![CDATA[new( p+offset*ix ) Account;]]></div>
<p>то здесь мы обращаемся к ним, задавая индекс в массиве ps:
</p>
<div class="lang-cpp"><![CDATA[ps[ix].Account::~Account();]]></div>

<p>Хотя и ps, и p адресуют одну и ту же область памяти, ps объявлен как
указатель на объект класса Account, а p - как указатель на char.
Индексирование p дало бы ix-й байт, а не ix-й объект класса Account.
Поскольку с p ассоциирован не тот тип, что нужно, арифметические
операции над указателями приходится программировать самостоятельно.
</p>

<p>Мы объявляем обе функции статическими членами класса:
</p>

<div class="lang-cpp"><![CDATA[
typedef pair<char*, double> value_pair;
class Account {
public:
     // ...
    static Account* init_heap_array(
         vector< value_pair>& init_values,
         vector< value_pair>::size_type elem_count = 0 );
     static void dealloc_heap_array( Account*, size_t );
     // ...
};
]]></div>

</section>

<section id="class_vector">
<title>Вектор объектов</title>

<p>Когда определяется вектор из пяти объектов класса, например:
</p>

<div class="lang-cpp"><![CDATA[
vector<Point> vec(5);
]]></div>

<p>то инициализация элементов производится в следующем порядке:
</p>

<ol>
<li>С помощью конструктора по умолчанию создается временный объект типа класса, хранящегося в векторе.</li>
<li>К каждому элементу вектора применяется копирующий конструктор, в результате чего каждый объект инициализируется копией временного объекта.</li>
<li>Временный объект уничтожается.</li>
</ol>

<p>Хотя конечный результат оказывается таким же, как при определении массива из пяти объектов класса:
</p>

<div class="lang-cpp"><![CDATA[
Point pa[5];
]]></div>

<p>эффективность подобной инициализации вектора ниже, так как,
во-первых, на конструирование и уничтожение временного объекта,
естественно, нужны ресурсы, а во-вторых, копирующий конструктор обычно
оказывается вычислительно более сложным, чем конструктор по умолчанию.
</p>

<p>Общее правило проектирования таково: вектор объектов класса
удобнее только для вставки элементов, т.е. в случае, когда изначально
определяется пустой вектор. Если мы заранее вычислили, сколько придется
вставлять элементов, или имеем на этот счет обоснованное предположение,
то надо зарезервировать необходимую память, а затем приступать к
вставке. Например:
</p>

<div class="lang-cpp"><![CDATA[
vector<Point>  cvs;   // пустой
int cv_cnt = calc_control_vertices();

// зарезервировать память для хранения cv_cnt объектов класса Point
// cvs все еще пуст ...
cvs.reserve( cv_cnt );
// открыть файл и подготовиться к чтению из него
ifstream infile( "spriteModel" );
istream_iterator<Point>  cvfile( infile ),eos;

// вот теперь можно вставлять элементы
copy( cvfile, eos, inserter( cvs, cvs.begin() ));
]]></div>

<p>Поведение объектов list (список) и deque (двусторонняя очередь)
аналогично поведению объектов vector (векторов). Вставка объекта в
любой из этих контейнеров осуществляется с помощью копирующего
конструктора.
</p>

<p>Упражнение 14.9
</p>

<p>Какие из приведенных инструкций неверны? Исправьте их.
</p>
<div class="lang-cpp"><![CDATA[(a) Account *parray[10] = new Account[10];
(b) Account iA[1024] = {
    "Nhi", "Le", "Jon", "Mike", "Greg", "Brent", "Hank"
    "Roy", "Elena" };

(c) string *ps=string[5]("Tina","Tim","Chyuan","Mira","Mike");
(d) string as[] = *ps;]]></div>

<div class="lang-cpp"><![CDATA[Упражнение 14.10]]></div>

<p>Что лучше применить в каждой из следующих ситуаций: статический
массив (такой, как Account pA[10]), динамический массив или вектор?
Объясните свой выбор.
</p>

<p>Внутри функции Lut() нужен набор из 256 элементов для хранения объектов класса Color. Значения являются константами.
</p>

<p>Необходимо хранить набор из неизвестного числа объектов класса Account. Данные счетов читаются из файла.
</p>

<p>Функция gen_words(elem_size) должна сгенерировать и передать обработчику текста набор из elem_size строк.
</p>

<p>Упражнение 14.11
</p>

<p>Потенциальным источником ошибок при использовании динамических
массивов является пропуск пары квадратных скобок, говорящей, что
указатель адресует массив, т.е. неверная запись
</p>
<div class="lang-cpp"><![CDATA[// печально: не проверяется, что parray адресует массив
delete parray;
вместо
// правильно: определяется размер массива, адресуемого parray
delete [] parray;]]></div>
<p>Наличие пары скобок заставляет компилятор найти размер массива.
Затем к каждому элементу по очереди применяется деструктор (всего size
раз). Если же скобок нет, уничтожается только один элемент. В любом
случае освобождается вся память, занятая массивом.
</p>

<p>При обсуждении первоначального варианта языка С++ много спорили
о том, должно ли наличие квадратных скобок инициировать поиск или же
(как было в исходной спецификации) лучше поручить программисту явно
указывать размер массива:
</p>

<div class="lang-cpp"><![CDATA[
// в первоначальном варианте языка размер массива требовалось задавать явно
delete p[10] parray;]]></div>

<p>Как вы думаете, почему язык был изменен таким образом, что явного
задания размера не требуется (а значит, нужно уметь его сохранять и
извлекать), но скобки, хотя и пустые, в операторе delete остались (так
что компилятор не должен запоминать, адресует указатель единственный
объект или массив)? Какой вариант языка предложили бы вы?
</p>

</section>

<section id="class_list_init">
<title>Список инициализации членов</title>

<p>Модифицируем наш класс Account, объявив член _name типа string:
</p>
<div class="lang-cpp"><![CDATA[#include >string>
class Account {
public:
   // ...
private:
   unsigned int _acct_nmbr;
   double       _balance;
   string       _name;
};]]></div>

<p>Придется заодно изменить и конструкторы. Возникает две проблемы:
поддержание совместимости с первоначальным интерфейсом и инициализация
объекта класса с помощью подходящего набора конструкторов.
</p>

<p>Исходный конструктор Account с двумя параметрами
</p>
<div class="lang-cpp"><![CDATA[Account( const char*, double = 0.0 );]]></div>

<p>не может инициализировать член типа string. Например:
</p>

<div class="lang-cpp"><![CDATA[string new_client( " Steve Hall" );
Account new_acct( new_client, 25000 );]]></div>

<p>не будет компилироваться, так как не существует неявного преобразования из типа string в тип char*. Инструкция
</p>

<div class="lang-cpp"><![CDATA[Account new_acct( new_client.c_str(), 25000 );]]></div>
<p>правильна, но вызовет у пользователей класса недоумение. Одно из решений - добавить новый конструктор вида:
</p>
<div class="lang-cpp"><![CDATA[Account( string, double = 0.0 );]]></div>
<p>Если написать:
</p>
<div class="lang-cpp"><![CDATA[Account new_acct( new_client, 25000 );]]></div>
<p>вызывается именно этот конструктор, тогда как старый код
</p>
<div class="lang-cpp"><![CDATA[Account *open_new_account( const char *nm )
{
   Account *pact = new Account( nm );
   // ...
   return pacct;
}]]></div>
<p>по-прежнему будет приводить к вызову исходного конструктора с двумя параметрами.
</p>

<p>Так как в классе string определено преобразование из типа char* в
тип string (преобразования классов обсуждаются в этой главе ниже), то
можно заменить исходный конструктор на новый, которому в качестве
первого параметра передается тип string. В таком случае, когда
встречается инструкция:
</p>

<div class="lang-cpp"><![CDATA[Account myAcct( " Tinkerbell"  );]]></div>

<p><q>Tinkerbell</q> преобразуется во временный объект типа string. Затем
этот объект передается новому конструктору с двумя параметрами.
</p>

<p>При проектировании приходится идти на компромисс между
увеличением числа конструкторов класса Account и несколько менее
эффективной обработкой аргументов типа char* из-за необходимости
создавать временный объект. Мы предоставили две версии конструктора с
двумя параметрами. Тогда модифицированный набор конструкторов Account
будет таким:
</p>

<div class="lang-cpp"><![CDATA[
#include <string>

class Account {
public:
   Account();
   Account( const char*, double=0.0 );
   Account( const string&, double=0.0 );
   Account( const Account&);
   // ...
private:
   // ...
};
]]></div>

<p>Как правильно инициализировать член, являющийся объектом некоторого
класса с собственным набором конструкторов? Этот вопрос можно разделить
на три:
</p>

<ol>
<li>где вызывается конструктор по умолчанию? Внутри конструктора по умолчанию класса Account;</li>
<li>где вызывается копирующий конструктор? Внутри копирующего конструктора класса Account и внутри конструктора с двумя параметрами, принимающего в качестве первого тип string;</li>
<li>как передать аргументы конструктору класса, являющегося членомдругого класса? Это необходимо делать внутри конструктора Account с двумя параметрами, принимающего в качестве первого тип char*.</li>
</ol>

<p>Решение заключается в использовании списка инициализации членов (мы
упоминали о нем в разделе 14.2). Члены, являющиеся классами, можно явно
инициализировать с помощью списка, состоящего из разделенных запятыми
пар "имя члена/значение". Наш конструктор с двумя параметрами теперь
выглядит так (напомним, что _name - это член, являющийся объектом
класса string):
</p>

<div class="lang-cpp"><![CDATA[
inline Account::Account(const char* name, double opening_bal)
   : _name( name ), _balance( opening_bal )
{
   _acct_nmbr = het_unique_acct_nmbr();
}
]]></div>

<p>Список инициализации членов следует за сигнатурой конструктора и
отделяется от нее двоеточием. В нем указывается имя члена, а в скобках
- начальные значения, что аналогично синтаксису вызова функции. Если
член является объектом класса, то эти значения становятся аргументами,
передаваемыми подходящему конструктору, который затем и используется. В
нашем примере значение name передается конструктору string, который
применяется к члену _name. Член _balance инициализируется значением opening_bal.
</p>

<p>Аналогично выглядит второй конструктор с двумя параметрами:
</p>

<div class="lang-cpp"><![CDATA[
inline Account::Account(const string& name, double opening_bal)
   : _name( name ), _balance( opening_bal )
{
   _acct_nmbr = het_unique_acct_nmbr();
}
]]></div>

<p>В этом случае вызывается копирующий конструктор string, инициализирующий член _name значением параметра name типа string.
</p>

<p>Часто у новичков возникает вопрос: в чем разница между
использованием списка инициализации и присваиванием значений членам в
теле конструктора? Например, в чем разница между
</p>

<div class="lang-cpp"><![CDATA[
inline Account::Account(const char* name, double opening_bal)
   : _name( name ), _balance( opening_bal )
{
   _acct_nmbr = het_unique_acct_nmbr();
}
]]></div>

<p>и</p>

<div class="lang-cpp"><![CDATA[
Account(const char* name, double opening_bal) {
   _name = name;
   _balance = opening_bal;
   _acct_nmbr = het_unique_acct_nmbr();
}
]]></div>

<p>В конце работы обоих конструкторов все три члена будут иметь
одинаковые значения. Разница в том, что только список обеспечивает
инициализацию тех членов, которые являются объектами класса. В теле
конструктора установка значения члена - это не инициализация, а
присваивание. Важно это различие или нет, зависит от природы члена.
</p>

<p>С концептуальной точки зрения выполнение конструктора состоит
из двух фаз: фаза явной или неявной инициализации и фаза вычислений,
включающая все инструкции в теле конструктора. Любая установка значений
членов во второй фазе рассматривается как присваивание, а не
инициализация. Непонимание этого различия приводит к ошибкам и
неэффективным программам.
</p>

<p>Первая фаза может быть явной или неявной в зависимости от того,
имеется ли список инициализации членов. При неявной инициализации
сначала вызываются конструкторы по умолчанию всех базовых классов в
порядке их объявления, а затем конструкторы по умолчанию всех членов,
являющихся объектами классов. (Базовые классы мы будем рассматривать в
главе 17 при обсуждении объектно-ориентированного программирования.)
Например, если написать:
</p>

<div class="lang-cpp"><![CDATA[
inline Account::Account() {
   _name = "";
   _balance = 0.0;
   _acct_nmbr = 0;
}
]]></div>

<p>то фаза инициализации будет неявной. Еще до выполнения тела
конструктора вызывается конструктор по умолчанию класса string,
ассоциированный с членом _name. Это означает, что присваивание _name
пустой строки излишне.
</p>

<p>Для объектов классов различие между инициализацией и
присваиванием существенно. Член, являющийся объектом класса, всегда
следует инициализировать с помощью списка, а не присваивать ему
значение в теле конструктора. Более правильной является следующая
реализация конструктора по умолчанию класса Account:
</p>

<div class="lang-cpp"><![CDATA[
inline Account::Account() : _name(string()) {
   _balance = 0.0;
   _acct_nmbr = 0;
}
]]></div>

<p>Мы удалили ненужное присваивание _name из тела конструктора. Явный
же вызов конструктора по умолчанию string излишен. Ниже приведена
эквивалентная, но более компактная версия:
</p>

<div class="lang-cpp"><![CDATA[
inline Account::Account() {
   _balance = 0.0;
   _acct_nmbr = 0;
}
]]></div>

<p>Однако мы еще не ответили на вопрос об инициализации двух членов
встроенных типов. Например, так ли существенно, где происходит
инициализация _balance: в списке инициализации или в теле конструктора?
Инициализация и присваивание членам, не являющимся объектами классов,
эквивалентны как с точки зрения результата, так и с точки зрения
производительности (за двумя исключениями). Мы предпочитаем
использовать список:
</p>

<div class="lang-cpp"><![CDATA[
// предпочтительный стиль инициализации
inline Account::Account() : _balance( 0.0 ), _acct_nmbr( 0 )
{ }
]]></div>

<p>Два вышеупомянутых исключения - это константные члены и члены-ссылки
независимо от типа. Для них всегда нужно использовать список
инициализации, в противном случае компилятор выдаст ошибку:
</p>

<div class="lang-cpp"><![CDATA[
class ConstRef {
public:
   ConstRef(int ii );
private:
   int i;
   const int ci;
   int& ri;
};

ConstRef::ConstRef( int ii ) {  // присваивание
   i = ii;        // правильно
   ci = ii;       // ошибка: нельзя присваивать константному члену
   ri = i;        // ошибка: ri не инициализирована
}
]]></div>

<p>К началу выполнения тела конструктора инициализация всех константных
членов и членов-ссылок должна быть завершена. Для этого нужно указать
их в списке инициализации. Правильная реализация предыдущего примера
такова:
</p>

<div class="lang-cpp"><![CDATA[
// правильно: инициализируются константные члены и ссылки
ConstRef::ConstRef( int ii )
    : ci( ii ), ri ( i )
{ i = ii; }
]]></div>

<p>Каждый член должен встречаться в списке инициализации не более
одного раза. Порядок инициализации определяется не порядком следования
имен в списке, а порядком объявления членов. Если дано следующее
объявление членов класса Account:
</p>

<div class="lang-cpp"><![CDATA[
class Account {
public:
   // ...
private:
   unsigned int _acct_nmbr;
   double       _balance;
   string       _name;
};
]]></div>

<p>то порядок инициализации для такой реализации конструктора по умолчанию
</p>
<div class="lang-cpp"><![CDATA[
inline Account::Account()
    : _name( string() ), _balance( 0.0 ), _acct_nmbr( 0 )
{ }
]]></div>

<p>будет следующим: _acct_nmbr, _balance, _name. Однако члены,
указанные в списке (или в неявно инициализируемом члене-объекте
класса), всегда инициализируются раньше, чем производится присваивание
членам в теле конструктора. Например, в следующем конструкторе:
</p>

<div class="lang-cpp"><![CDATA[
inline Account::Account(const char* name, double bal)
   : _name( name ), _balance( bal )
{
   _acct_nmbr = get_unique_acct_nmbr();
}
]]></div>

<p>порядок инициализации такой: _balance, _name, _acct_nmbr.
</p>

<p>Расхождение между порядком инициализации и порядком следования
членов в соответствующем списке может приводить к трудным для
обнаружения ошибкам, когда один член класса используется для
инициализации другого:
</p>
<div class="lang-cpp"><![CDATA[
class X {
   int i;
   int j;
public:
   // видите проблему?
   X( int val )
      : j( val ), i( j )
      {}
   // ...
};
]]></div>

<p>кажется, что перед использованием для инициализации i член j уже
инициализирован значением val, но на самом деле i инициализируется
первым, для чего применяется еще неинициализированный член j. Мы
рекомендуем помещать инициализацию одного члена другим (если вы
считаете это необходимым) в тело конструктора:
</p>

<div class="lang-cpp"><![CDATA[
// предпочтительная идиома
X::X( int val ) : i( val ) { j = i; }
]]></div>

<p>Упражнение 14.12:
Что неверно в следующих определениях конструкторов? Как бы вы исправили обнаруженные ошибки?
</p>

<div class="lang-cpp"><![CDATA[
(a) Word::Word( char *ps, int count = 1 )
         : _ps( new char[strlen(ps)+1] ),
           _count( count )
    {
         if ( ps )
            strcpy( _ps, ps );
         else {
            _ps = 0;
            _count = 0;
         }
    }
(b) class CL1 {
    public:
       CL1() { c.real(0.0); c.imag(0.0); s = " not set" ; }
       // ...
    private:
       complex<double> c;
       string s;
    }
 (c) class CL2 {
    public:
       CL2( map<string,location> *pmap, string key )
            : _text( key ), _loc( (*pmap)[key] ) {}
       // ...
    private:
       location _loc;
       string   _text;
};
]]></div>

</section>

<section id="class_field_init">
<title>Почленная инициализация A</title>

<p>Инициализация одного объекта класса другим объектом того же класса, как, например:
</p>

<div class="lang-cpp"><![CDATA[
Account oldAcct( " Anna Livia Plurabelle"  );
Account newAcct( oldAcct );
]]></div>

<p>называется <i>почленной инициализацией по умолчанию</i>. По
умолчанию - потому, что она производится автоматически, независимо от
того, есть явный конструктор или нет. Почленной - потому, что единицей
инициализации является отдельный нестатический член, а не побитовая
копия всего объекта класса.
</p>

<p>Такую инициализацию проще всего представить, если считать, что
компилятор создает специальный внутренний копирующий конструктор, где
поочередно, в порядке объявления, инициализируются все нестатические
члены. Если рассмотреть первое определение нашего класса Account:
</p>

<div class="lang-cpp"><![CDATA[
class Account {
public:
   // ...
private:
   char         *_name;
   unsigned int _acct_nmbr;
   double       _balance;
};
]]></div>

<p>то можно представить, что копирующий конструктор по умолчанию определен так:
</p>

<div class="lang-cpp"><![CDATA[
inline Account::Account(const Account& rhs) {
   _name = rhs._name;
   _acct_nmbr = rhs._acct_nmbr;
   _balance = rhs._balance;
}
]]></div>

<p>Почленная инициализация одного объекта класса другим встречается в следующих ситуациях:
</p>

<p>1. явная инициализация одного объекта другим:
</p>

<div class="lang-cpp"><![CDATA[Account newAcct( oldAcct );]]></div>

<p>1. передача объекта класса в качестве аргумента функции:
</p>

<div class="lang-cpp"><![CDATA[
extern bool cash_on_hand(Account acct);

if (cash_on_hand(oldAcct))
   // ...
]]></div>

<p>1. передача объекта класса в качестве возвращаемого функцией значения:
</p>

<div class="lang-cpp"><![CDATA[
extern Account consolidate_accts(const vector<Account>&) {
   Account final_acct;
   // выполнить финансовую операцию
   return final_acct;
}
]]></div>

<p>1. определение непустого последовательного контейнера:
</p>

<div class="lang-cpp"><![CDATA[
// вызывается пять копирующих конструкторов класса string
vector<string> svec(5);
]]></div>

<p>(В этом примере с помощью конструктора string по умолчанию создается
один временный объект, который затем копируется в пять элементов
вектора посредством копирующего конструктора string.)
</p>

<p>1. вставка объекта класса в контейнер:
</p>

<div class="lang-cpp"><![CDATA[
svec.push_back(string("pooh"));
]]></div>

<p>Для большинства определений реальных классов почленная инициализация
по умолчанию не соответствует семантике класса. Чаще всего это
случается, когда его член представляет собой указатель, который
адресует освобождаемую деструктором память в хипе, как, например, в
нашем Account.
</p>

<p>В результате такой инициализации newAcct._name и oldAcct._name
указывают на одну и ту же C-строку. Если oldAcct выходит из области
видимости и к нему применяется деструктор, то newAcct._name указывает
на освобожденную область памяти. С другой стороны, если newAcct
модифицирует строку, адресуемую _name, то она изменяется и для oldAcct.
Подобные ошибки очень трудно найти.
</p>

<p>Одно из решений псевдонимов указателей заключается в том, чтобы
выделить область памяти для копии строки и инициализировать
newAcct._name адресом этой области. Следовательно, почленную
инициализацию по умолчанию для класса Account нужно подавить за счет
предоставления явного копирующего конструктора, который реализует
правильную семантику инициализации.
</p>

<p>Внутренняя семантика класса также может не соответствовать
почленной инициализации по умолчанию. Ранее мы уже объясняли, что два
разных объекта Account не должны иметь одинаковые номера счетов. Чтобы
гарантировать такое поведение, мы должны подавить почленную
инициализацию по умолчанию для класса Account. Вот как выглядит
копирующий конструктор, решающий обе эти проблемы:
</p>
<div class="lang-cpp"><![CDATA[
inline Account::Account(const Account& rhs) {
   // решить проблему псевдонима указателя
   _name = new char[ strlen(rhs._name)+1 ];
   strcpy( _name, rhs._name );

   // решить проблему уникальности номера счета
   _acct_nmbr = get_unique_acct_nmbr();

   // копирование этого члена и так работает
   _balance = rhs._balance;
}
]]></div>

<p>Альтернативой написанию копирующего конструктора является полный
запрет почленной инициализации. Это можно сделать следующим образом:
</p>

<ol>
<li>Объявить копирующий конструктор закрытым членом. Это
предотвратит почленную инициализацию всюду, кроме функций-членов и
друзей класса.</li>
<li>Запретить почленную инициализацию в функциях-членах и друзьях
класса, намеренно не предоставляя определения копирующего конструктора
(однако объявить его так, как описано на шаге 1, все равно нужно). Язык
не дает нам возможности ограничить доступ к закрытым членам класса со
стороны функций-членов и друзей. Но если определение отсутствует, то
любая попытка вызвать копирующий конструктор, законная с точки зрения
компилятора, приведет к ошибке во время редактирования связей,
поскольку не удастся найти определение символа.</li>
</ol>

<p>Чтобы запретить почленную инициализацию, класс Account можно объявить так:
</p>

<div class="lang-cpp"><![CDATA[
class Account {
public:
   Account();
   Account(const char *s, double x = 0.0);

   // ...
private:
   Account(const Account&);
   // ...
};
]]></div>

</section>

<section id="class_member_initialization">
<title>Инициализация члена, являющегося объектом класса</title>

<p>Что произойдет, если в объявлении _name заменить C-строку на тип
класса string? Как это повлияет на почленную инициализацию по
умолчанию? Как надо будет изменить явный копирующий конструктор? Мы
ответим на эти вопросы в данном подразделе.
</p>

<p>При почленной инициализации по умолчанию исследуется каждый
член. Если он принадлежит к встроенному или составному типу, то такая
инициализация применяется непосредственно. Например, в первоначальном
определении класса Account член _name инициализируется непосредственно,
так как это указатель:
</p>

<div class="lang-cpp"><![CDATA[newAcct._name = oldAcct._name;]]></div>

<p>Члены, являющиеся объектами классов, обрабатываются по-другому. В инструкции
</p>
<div class="lang-cpp"><![CDATA[Account newAcct( oldAcct );]]></div>

<p>оба объекта распознаются как экземпляры Account. Если у этого класса
есть явный копирующий конструктор, то он и применяется для задания
начального значения, в противном случае выполняется почленная
инициализация по умолчанию.
</p>

<p>Таким образом, если обнаруживается член-объект класса, то
описанный выше процесс применяется рекурсивно. У класса есть явный
копирующий конструктор? Если да, вызвать его для задания начального
значения члена-объекта класса. Иначе применить к этому члену почленную
инициализацию по умолчанию. Если все члены этого класса принадлежат к
встроенным или составным типам, то каждый инициализируется
непосредственно и процесс на этом завершается. Если же некоторые члены
сами являются объектами классов, то алгоритм применяется к ним
рекурсивно, пока не останется ничего, кроме встроенных и составных
типов.
</p>

<p>В нашем примере у класса string есть явный копирующий
конструктор, поэтому _name инициализируется с помощью его вызова.
Копирующий конструктор по умолчанию для класса Account выглядит
следующим образом (хотя явно он не определен):
</p>

<div class="lang-cpp"><![CDATA[
inline Account::Account( const Account& rhs) {
   _acct_nmbr = rhs._acct_nmbr;
   _balance = rhs._balance;

   // Псевдокод на C++
   // иллюстрирует вызов копирующего конструктора
   // для члена, являющегося объектом класса
   _name.string::string( rhs._name );
}
]]></div>

<p>Теперь почленная инициализация по умолчанию для класса Account
корректно обрабатывает выделение и освобождение памяти для _name, но
все еще неверно копирует номер счета, поэтому приходится кодировать
явный копирующий конструктор. Однако приведенный ниже фрагмент не
совсем правилен. Можете ли вы сказать, почему?
</p>

<div class="lang-cpp"><![CDATA[
// не совсем правильно...
inline Account::Account(const Account& rhs) {
   _name = rhs._name;
   _balance = rhs._balance;
   _acct_nmbr = get_unique_acct_nmbr();
}
]]></div>

<p>Эта реализация ошибочна, поскольку в ней не различаются
инициализация и присваивание. В результате вместо вызова копирующего
конструктора string мы вызываем конструктор string по умолчанию на фазе
неявной инициализации и копирующий оператор присваивания string - в
теле конструктора. Исправить это несложно:
</p>

<div class="lang-cpp"><![CDATA[
inline Account::Account(const Account& rhs)
   : _name(rhs._name)
{
   _balance = rhs._balance;
   _acct_nmbr = get_unique_acct_nmbr();
}
]]></div>

<p>Самое главное - понять, что такое исправление необходимо. (Обе
реализации приводят к тому, что в _name копируется значение из
rhs._name, но в первой одна и та же работа выполняется дважды.) Общее
эвристическое правило состоит в том, чтобы по возможности
инициализировать все члены-объекты классов в списке инициализации
членов.
</p>

<p>Упражнение 14.13
</p>

<p>Для какого определения класса скорее всего понадобится копирующий конструктор?
</p>

<ol>
<li>Представление Point3w, содержащее четыре числа с плавающей точкой.</li>
<li>Класс matrix, в котором память для хранения матрицы выделяется динамически в конструкторе и освобождается в деструкторе.</li>
<li>Класс payroll (платежная ведомость), где каждому объекту приписывается уникальный идентификатор.</li>
<li>Класс word (слово), содержащий объект класса string и вектор, в котором хранятся пары (номер строки, смещение в строке).</li>
</ol>

<p>Упражнение 14.14
</p>

<p>Реализуйте для каждого из данных классов копирующий конструктор, конструктор по умолчанию и деструктор.
</p>
<div class="lang-cpp"><![CDATA[
(a) class BinStrTreeNode {
    public:
       // ...
    private:
       string _value;
       int    _count;
       BinStrTreeNode *_leftchild;
       BinStrTreeNode *_rightchild;
    };
(b) class BinStrTree {
    public:
       // ...
    private:
       BinStrTreeNode *_root;
    };
(c) class iMatrix {
    public:
       // ...
    private:
       int  _rows;
       int  _cols;
       int *_matrix;
    };
(d) class theBigMix {
    public:
       // ...
    private:
       BinStrTree    _bst;
       iMatrix       _im;
       string        _name;
       vectorMfloat> *_pvec;
    };
]]></div>

<p>Упражнение 14.15
</p>

<p>Нужен ли копирующий конструктор для того класса, который вы
выбрали в упражнении 14.3 из раздела 14.2? Если нет, объясните почему.
Если да, реализуйте его.
</p>

<p>Упражнение 14.16
</p>

<p>Идентифицируйте в следующем фрагменте программы все места, где происходит почленная инициализация:
</p>
<div class="lang-cpp"><![CDATA[
Point global;

Point foo_bar(Point arg) {
   Point local = arg;
   Point *heap = new Point( global );
   *heap = local;
   Point pa[ 4 ] = { local, *heap };
   return *heap;
}
]]></div>

</section>

<section id="class_field_assign">
<title>Почленное присваивание A</title>

<p>Присваивание одному объекту класса значения другого объекта того же
класса реализуется почленным присваиванием по умолчанию. От почленной
инициализации по умолчанию оно отличается только использованием
копирующего оператора присваивания вместо копирующего конструктора:
</p>

<div class="lang-cpp"><![CDATA[newAcct = oldAcct;]]></div>

<p>по умолчанию присваивает каждому нестатическому члену newAcct
значение соответственного члена oldAcct. Компилятор генерирует
следующий копирующий оператор присваивания:
</p>

<div class="lang-cpp"><![CDATA[
inline Account&; Account::operator=(const Account& rhs) {
   _name = rhs._name;
   _balance = rhs._balance;
   _acct_nmbr = rhs._acct_nmbr;
}
]]></div>

<p>Как правило, если для класса не подходит почленная инициализация по
умолчанию, то не подходит и почленное присваивание по умолчанию.
Например, для первоначального определения класса Account, где член
_name был объявлен как char*, такое присваивание не годится ни для
_name, ни для _acct_nmbr.
</p>

<p>Мы можем подавить его, если предоставим явный копирующий
оператор присваивания, где будет реализована подходящая для класса
семантика:
</p>

<div class="lang-cpp"><![CDATA[
// общий вид копирующего оператора присваивания
className& className::operator=(const className& rhs) {
   // не надо присваивать самому себе
   if (this != &rhs) {
        // здесь реализуется семантика копирования класса
   }
   // вернуть объект, которому присвоено значение
   return *this;
}
]]></div>

<p>Здесь условная инструкция
</p>
<div class="lang-cpp"><![CDATA[if (this != &rhs)]]></div>
<p>предотвращает присваивание объекта класса самому себе, что особенно
неприятно в ситуации, когда копирующий оператор присваивания сначала
освобождает некоторый ресурс, ассоциированный с объектом в левой части,
чтобы назначить вместо него ресурс, ассоциированный с объектом в правой
части. Рассмотрим копирующий оператор присваивания для класса Account:
</p>

<div class="lang-cpp"><![CDATA[
Account& Account::operator=(const Account& rhs) {
   // не надо присваивать самому себе
   if (this != &rhs) {
      delete [] _name;
      _name = new char[strlen(rhs._name)+1];
      strcpy( _name,rhs._name );
      _balance = rhs._balance;
      _acct_nmbr = rhs._acct_nmbr;
   }
   return *this;
}
]]></div>

<p>Когда один объект класса присваивается другому, как, например, в инструкции:
</p>
<div class="lang-cpp"><![CDATA[newAcct = oldAcct;]]></div>
<p>выполняются следующие шаги:
</p>

<ol>
<li>Выясняется, есть ли в классе явный копирующий оператор присваивания.</li>
<li>Если есть, проверяются права доступа к нему, чтобы понять, можно ли его вызывать в данном месте программы.</li>
<li>Оператор вызывается для выполнения присваивания; если же он недоступен, компилятор выдает сообщение об ошибке.</li>
<li>Если явного оператора нет, выполняется почленное присваивание по умолчанию.</li>
<li>При почленном присваивании каждому члену встроенного или составного
члена объекта в левой части присваивается значение соответственного
члена объекта в правой части.</li>
<li>Для каждого члена, являющегося объектом класса, рекурсивно
применяются шаги 1-6, пока не останутся только члены встроенных и
составных типов.</li>
</ol>
<p>Если мы снова модифицируем определение класса Account так, что _name
будет иметь тип string, то почленное присваивание по умолчанию
</p>

<div class="lang-cpp"><![CDATA[newAcct = oldAcct;]]></div>

<p>будет выполняться так же, как при создании компилятором следующего оператора присваивания:
</p>
<div class="lang-cpp"><![CDATA[
inline Account& Account::operator=(const Account& rhs) {
   _balance = rhs._balance;
   _acct_nmbr = rhs._acct_nmbr;

   // этот вызов правилен и с точки зрения программиста
   name.string::operator=( rhs._name );
}
]]></div>

<p>Однако почленное присваивание по умолчанию для объектов класса
Account не подходит из-за _acct_nmbr. Нужно реализовать явный
копирующий оператор присваивания с учетом того, что _name - это объект
класса string:
</p>

<div class="lang-cpp"><![CDATA[
Account& Account::operator=(const Account& rhs) {
   // не надо присваивать самому себе
   if (this != &rhs) {
      // вызывается string::operator=(const string&)
      _name = rhs._name;
      _balance = rhs._balance;
   }
   return *this;
}
]]></div>

<p>Чтобы запретить почленное копирование, мы поступаем так же, как и в
случае почленной инициализации: объявляем оператор закрытым и не
предоставляем его определения.
</p>

<p>Копирующий конструктор и копирующий оператор присваивания
обычно рассматривают вместе. Если необходим один, то, как правило,
необходим и другой. Если запрещается один, то, вероятно, следует
запретить и другой.
</p>

<p>Упражнение 14.17
</p>

<p>Реализуйте копирующий оператор присваивания для каждого из классов, определенных в упражнении 14.14 из раздела 14.6.
</p>

<p>Упражнение 14.18
</p>

<p>Нужен ли копирующий оператор присваивания для того класса,
который вы выбрали в упражнении 14.3 из раздела 14.2? Если да,
реализуйте его. В противном случае объясните, почему он не нужен.
</p>

</section>

<section id="class_efficiency">
<title>Соображения эффективности</title>

<p>В общем случае объект класса эффективнее передавать аргументы функции по указателю или по ссылке, нежели по значению.
Например, если дана функция с сигнатурой:
</p>

<div class="lang-cpp"><![CDATA[
bool sufficient_funds(Account acct, double);
]]></div>

<p>то при каждом ее вызове требуется выполнить почленную инициализацию
формального параметра acct значением фактического аргумента-объекта
класса Account. Если же функция имеет любую из таких сигнатур:
</p>

<div class="lang-cpp"><![CDATA[
bool sufficient_funds(Account *pacct, double);
bool sufficient_funds(Account & acct, double);
]]></div>

<p>то достаточно скопировать адрес объекта Account.
В этом случае никакой инициализации класса не происходит - и ссылочные и указательные параметры представляют собой машинные адреса.
</p>

<p>Хотя возвращать указатель или ссылку на объект класса также
более эффективно, чем сам объект, но корректно запрограммировать это
достаточно сложно. Рассмотрим такой оператор сложения:
</p>

<div class="lang-cpp"><![CDATA[
// задача решается, но для больших матриц эффективность может
// оказаться неприемлемо низкой
Matrix operator+( const Matrix& m1, const Matrix& m2) {
   Matrix result;
   // выполнить арифметические операции ...
   return result;
}
]]></div>

<p>Этот перегруженный оператор позволяет пользователю писать
</p>
<div class="lang-cpp"><![CDATA[Matrix a, b;
// ...

// в обоих случаях вызывается operator+()
Matrix c = a + b;
a = b + c;]]></div>
<p>Однако возврат результата по значению может потребовать слишком
больших затрат времени и памяти, если Matrix представляет собой большой
и сложный класс. Если эта операция выполняется часто, то она, вероятно,
резко снизит производительность.
</p>

<p>Следующая пересмотренная реализация намного увеличивает скорость:
</p>
<div class="lang-cpp"><![CDATA[
// более эффективно, но после возврата адрес оказывается недействительным
// это может привести к краху программы
Matrix& operator+( const Matrix& m1, const Matrix& m2) {
   Matrix result;
   // выполнить сложение ...
   return result;
}
]]></div>

<p>но при этом происходят частые сбои программы. Дело в том, что
значение переменной result не определено после выхода из функции, в
которой она объявлена. (Мы возвращаем ссылку на локальный объект,
который после возврата не существует.)
</p>

<p>Значение возвращаемого адреса должно оставаться действительным
после выхода из функции. В приведенной реализации возвращаемый адрес не
затирается:
</p>
<div class="lang-cpp"><![CDATA[
// нет возможности гарантировать отсутствие утечки памяти
// поскольку матрица может быть большой, утечки будут весьма заметными
Matrix& operator+(const Matrix& m1, const Matrix& m2) {
   Matrix *result = new Matrix;
   // выполнить сложение ...
   return *result;
}
]]></div>

<p>Однако это неприемлемо: происходит большая утечка памяти, так как ни
одна из частей программы не отвечает за применение оператора delete к
объекту по окончании его использования.
</p>

<p>Вместо оператора сложения лучше применять именованную функцию,
которой в качестве третьего параметра передается ссылка, где следует
сохранить результат:
</p>

<div class="lang-cpp"><![CDATA[
// это обеспечивает нужную эффективность,
// но не является интуитивно понятным для пользователя
void mat_add(Matrix& result, const Matrix& m1, const Matrix& m3) {
   // вычислить результат
}
]]></div>

<p>Таким образом, проблема производительности решается, но для класса
уже нельзя использовать операторный синтаксис, так что теряется
возможность инициализировать объекты
</p>
<div class="lang-cpp"><![CDATA[// более не поддерживается
Matrix c = a + b;]]></div>
<p>и использовать их в выражениях:
</p>
<div class="lang-cpp"><![CDATA[// тоже не поддерживается
if ( a + b > c ) ...]]></div>

<p>Неэффективный возврат объекта класса - слабое место С++. В качестве
одного из решений предлагалось расширить язык, введя имя возвращаемого
функцией объекта:
</p>

<div class="lang-cpp"><![CDATA[
Matrix& operator+(const Matrix& m1, const Matrix& m2) {
   Matrix result;
   // ...
   return result;
}
]]></div>

<p>Тогда компилятор мог бы самостоятельно переписать функцию, добавив к ней третий параметр-ссылку:
</p>

<div class="lang-cpp"><![CDATA[
// переписанная компилятором функция
// в случае принятия предлагавшегося расширения языка
void
operator+(Matrix& result, const Matrix& m1, const Matrix& m2) {
   // вычислить результат
}
]]></div>

<p>и преобразовать все вызовы этой функции, разместив результат
непосредственно в области, на которую ссылается первый параметр.
Например:
</p>
<div class="lang-cpp"><![CDATA[Matrix c = a + b;]]></div>
<p>было бы трансформировано в
</p>
<div class="lang-cpp"><![CDATA[Matrix c;
operator+(c, a, b);]]></div>
<p>Это расширение так и не стало частью языка, но предложенная
оптимизация прижилась. Компилятор в состоянии распознать, что
возвращается объект класса и выполнить трансформацию его значения и без
явного расширения языка. Если дана функция общего вида:
</p>
<div class="lang-cpp"><![CDATA[
classType functionName(paramList) {
   classType namedResult;
   // выполнить какие-то действия ...
   return namedResult;
}
]]></div>

<p>то компилятор самостоятельно трансформирует как саму функцию, так и все обращения к ней:
</p>

<div class="lang-cpp"><![CDATA[
void functionName(classType& namedResult, paramList) {
   // вычислить результат и разместить его по адресу namedResult
}
]]></div>

<p>что позволяет уйти от необходимости возвращать значение объекта и
вызывать копирующий конструктор. Чтобы такая оптимизация была
применена, в каждой точке возврата из функции должен возвращаться один
и тот же именованный объект класса.
</p>

<p>И последнее замечание об эффективности работы с объектами в C++. Инициализация объекта класса вида
</p>

<div class="lang-cpp"><![CDATA[Matrix c = a + b;]]></div>

<p>всегда эффективнее присваивания. Например, результат следующих двух инструкций такой же, как и в предыдущем случае:
</p>

<div class="lang-cpp"><![CDATA[Matrix c;
c = a + b;]]></div>

<p>но объем требуемых вычислений значительно больше. Аналогично эффективнее писать:
</p>

<div class="lang-cpp"><![CDATA[for ( int ix = 0; ix < size-2; ++ix ) {
     Matrix matSum = mat[ix] + mat[ix+1];
     // ...
}]]></div>

<p>чем</p>

<div class="lang-cpp"><![CDATA[Matrix matSum;
for ( int ix = 0; ix < size-2; ++ix ) {
     matSum = mat[ix] + mat[ix+1];
     // ...
}]]></div>

<p>Причина, по которой присваивание всегда менее эффективно, состоит в
том, что возвращенный локальный объект нельзя подставить вместо объекта
в левой части оператора присваивания. Иными словами, в то время как
инструкцию
</p>

<div class="lang-cpp"><![CDATA[Point3d p3 = operator+( p1, p2 );]]></div>

<p>можно безопасно трансформировать:</p>

<div class="lang-cpp"><![CDATA[// Псевдокод на C++
Point3d p3;
operator+( p3, p1, p2 );]]></div>
<p>преобразование
</p>
<div class="lang-cpp"><![CDATA[Point3d p3;
p3 = operator+( p1, p2 );]]></div>
<p>в
</p>
<div class="lang-cpp"><![CDATA[// Псевдокод на C++
// небезопасно в случае присваивания
operator+( p3, p1, p2 );
небезопасно.]]></div>

<p>Преобразованная функция требует, чтобы переданный ей объект
представлял собой неформатированную область памяти. Почему? Потому что
к объекту сразу применяется конструктор, который уже был применен к
именованному локальному объекту. Если переданный объект уже был
сконструирован, то делать это еще раз с семантической точки зрения
неверно.
</p>

<p>Что касается инициализируемого объекта, то отведенная под него
память еще не подвергалась обработке. Если же объекту присваивается
значение и в классе объявлены конструкторы (а именно этот случай мы и
рассматриваем), можно утверждать, что эта память уже форматировалась
одним из них, так что непосредственно передавать объект функции
небезопасно.
</p>

<p>Вместо этого компилятор должен создать неформатированную
область памяти в виде временного объекта класса, передать его функции,
а затем почленно присвоить возвращенный временный объект объекту,
стоящему в левой части оператора присваивания. Наконец, если у класса
есть деструктор, то он применяется к временному объекту. Например,
следующий фрагмент
</p>

<div class="lang-cpp"><![CDATA[
Point3d p3;
p3 = operator+( p1, p2 );
]]></div>

<p>трансформируется в такой:
</p>

<div class="lang-cpp"><![CDATA[
// Псевдокод на C++
Point3d temp;
operator+( temp, p1, p2 );
p3.Point3d::operator=( temp );
temp.Point3d::~Point3d();
]]></div>

</section>
</chapter>
