<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="xhtml.xsl"?>

<chapter xmlns="http://www.example.com/postrisc"
 id="basic_instructions"
 description="Базовые инструкции"
>
<title>Инструкции</title>

<preface>

<p>Мельчайшей независимой частью С++ программы является инструкция. Она соответствует 
  предложению естественного языка, но завершается точкой с запятой (;), а не точкой. 
  Выражение С++ (например, ival + 5) становится простой инструкцией, если после 
  него поставить точку с запятой. Составная инструкция – это последовательность 
  простых, заключенная в фигурные скобки. По умолчанию инструкции выполняются 
  в порядке записи. Как правило, последовательного выполнения недостаточно для 
  решения реальных задач. Специальные управляющие конструкции позволяют менять 
  порядок действий в зависимости от некоторых условий и повторять составную инструкцию 
  определенное количество раз. Инструкции if, if-else и switch обеспечивают условное 
  выполнение. Повторение обеспечивается инструкциями цикла while, do-while и for. 
</p>

</preface>

<section id="simple_and_complex">
<title>Простые и составные инструкции</title>

<p>Простейшей формой является пустая инструкция. Вот как она выглядит:
</p>

<div class="lang-cpp"><![CDATA[; // пустая инструкция]]></div>

<p>Пустая инструкция используется там, где синтаксис С++ требует употребления 
  инструкции, а логика программы – нет. Например, в следующем цикле while, копирующем 
  одну строку в другую, все необходимые действия производятся внутри круглых скобок 
  (условной части инструкции). Однако согласно правилам синтаксиса С++ после while 
  должна идти инструкция. Поскольку нам нечего поместить сюда (вся работа уже 
  выполнена), приходится оставить это место пустым:
</p>

<div class="lang-cpp"><![CDATA[while ( *string++ = inBuf++ )
; // пустая инструкция]]></div>
<p>Случайное появление лишней пустой инструкции не вызывает ошибки компиляции. 
  Например, такая строка
</p>

<div class="lang-cpp"><![CDATA[ival = dval + sval;; // правильно: лишняя пустая инструкция]]></div>

<p>состоит из двух инструкций – сложения двух величин с присваиванием результата 
  переменной ival и пустой.
</p>

<p>Простая инструкция состоит из выражения, за которым следует точка с запятой. 
  Например:
</p>

<div class="lang-cpp"><![CDATA[// простые инструкции
int ival = 1024; // инструкция определения переменной
ival; // выражение
ival + 5; // еще одно выражение
ival = ival +5; // присваивание]]></div>
<p>Условные инструкции и инструкции цикла синтаксически требуют употребления единственной 
  инструкции, связанной с ними. Однако, как правило, этого недостаточно. В таких 
  случаях употребляются составные инструкции – последовательность простых, заключенная 
  в фигурные скобки:
</p>
<div class="lang-cpp"><![CDATA[if ( ival0 > ival1 ) {
   // составная инструкция, состоящая
   // из объявления и двух присваиваний
   int temp = ivalO;
   ivalO = ival1;
   ival1 = temp;
}]]></div>

<p>Составная инструкция может употребляться там же, где простая, и не нуждается 
  в завершающей точке с запятой.
</p>

<p>Пустая составная инструкция эквивалентна пустой простой. Приведенный выше пример 
  с пустой инструкцией можно переписать так:
</p>
<div class="lang-cpp"><![CDATA[while ( *string++ = *inBuf++ )
{} // пустая инструкция]]></div>

<p>Составную инструкцию, содержащую определения переменных, часто называют блоком.
Блок задает локальную область видимости в программе – идентификаторы,
объявленные внутри блока (как temp в предыдущем примере), видны только в нем.
</p>

</section>

<section id="insn_declarations">
<title>Инструкции объявления</title>

<p>В С++ определение объекта, например
</p>

<div class="lang-cpp"><![CDATA[int ival;]]></div>
<p>рассматривается как инструкция объявления (хотя в данном случае более правильно 
  было бы сказать определения). Ее можно использовать в любом месте программы, 
  где разрешено употреблять инструкции. В следующем примере объявления помечены 
  комментарием //#n, где n – порядковый номер.
</p>
<div class="lang-cpp"><![CDATA[#include <fstream>
#include <string>
#include <vector>
int main()
{
   string fileName; // #1
   cout << "Введите имя файла: ";
   cin >> fileName;
   if ( fileName.empty() ) {
      // странный случай
      cerr << "Пустое имя файла. Завершение работы.\n";
      return -1;
   }
   ifstream inFile( fileName.c_str() ); // #2
      if ( ! inFile ) {
      cerr << "Невозможно открыть файл.\n";
      return -2;
   }

   string inBuf; // #3
   vector< string > text; // #4
   while ( inFile >> inBuf ) {
      for ( int ix = 0; ix < inBuf .size(); ++ix ) // #5
         // можно обойтись без ch,
         // но мы использовали его для иллюстрации
         if (( char ch = inBuf[ix] )=='.'){ // #6
            ch = '_';
            inBuf[ix] = ch;
         }
         text.push_back( inBuf );
   }
   if ( text.empty() )
      return 0;
   // одна инструкция объявления,
   // определяющая сразу два объекта
   vector<string>::iterator iter = text.begin(), // #7
         iend = text.end();
   while ( iter != -iend ) {
      cout << *iter << '\n';
      ++iter;
   }
  return 0;
}]]></div>
<p>Программа содержит семь инструкций объявления и восемь определений объектов. 
  Объявления действуют локально; переменная объявляется непосредственно перед 
  первым использованием объекта.
</p>

<p>В 70-е годы философия программирования уделяла особое внимание тому, чтобы определения 
  всех объектов находились в начале программы или блока, перед исполняемыми инструкциями. 
  (В С, например, определение переменной не является инструкцией и обязано располагаться 
  в начале блока.) В некотором смысле это была реакция на идиому использования 
  переменных без предварительного объявления, чреватую ошибками. Такую идиому 
  поддерживал, например, FORTRAN.
</p>

<p>Поскольку в С++ объявление является обычной инструкцией, ему разрешено появляться 
  в любом месте программы, где допустимо употребление инструкции, что дает возможность 
  использовать локальные объявления.
</p>

<p>Необходимо ли это? Для встроенных типов данных применение локальных объявлений 
  является скорее вопросом вкуса. Язык их поощряет , разрешая объявлять переменные 
  внутри условных частей инструкций if, if-else, switch, while, for. Те программисты, 
  которые любят этот стиль, верят, что таким образом делают свои программы более 
  понятными.
</p>

<p>Локальные объявления становятся необходимостью, когда мы используем объекты 
  классов, имеющие конструкторы и деструкторы. Если мы помещаем все объявления 
  в начало блока или функции, происходят две неприятные вещи:
</p>

<ul>
  <li>конструкторы всех объектов вызываются перед исполнением первой инструкции блока.
 Применение локальных объявлений позволяет <q>размазать</q> расходы на инициализацию по всему блоку;</li>
  <li> что более важно, блок или функция могут завершиться до того, как будут 
    действительно использованы все объявленные в начале объекты. Скажем, наша 
    программа из предыдущего примера имеет два аварийных выхода: при вводе пользователем 
    пустого имени файла и при невозможности открыть файл с заданным именем. При 
    этом последующие инструкции функции уже не выполняются. Если бы объекты inBuf 
    и next были объявлены в начале блока, конструкторы и деструкторы этих объектов 
    в случае ненормального завершения функции вызывались бы совершенно напрасно.</li>
</ul>

<p>Инструкция объявления может состоять из одного или более определений. Например, 
  в нашей программе мы определяем два итератора вектора в одной инструкции:
</p>

<div class="lang-cpp"><![CDATA[
// одна инструкция объявления,
// определяющая сразу два объекта
vector<string>::iterator iter = text.begin(),
      lend = text.end();]]></div>

<p>Эквивалентная пара, определяющая по одному объекту, выглядит так:
</p>

<div class="lang-cpp"><![CDATA[vector<string>::iterator iter = text.begin();
vector<string>::iterator lend = text.end();]]></div>

<p>Хотя определение одного или нескольких объектов в одном предложении является 
  скорее вопросом вкуса, в некоторых случаях – например, при одновременном определении 
  объектов, указателей и ссылок – это может спровоцировать появление ошибок. Скажем, 
  в следующей инструкции не совсем ясно, действительно ли программист хотел определить 
  указатель и объект или просто забыл поставить звездочку перед вторым идентификатором 
  (используемые имена переменных наводят на второе предположение):
</p>
<div class="lang-cpp"><![CDATA[// то ли хотел определить программист?
string *ptrl, ptr2;]]></div>
<p>Эквивалентная пара инструкций не позволит допустить такую ошибку:
</p>
<div class="lang-cpp"><![CDATA[string *ptr1;
string *ptr2;]]></div>
<p>В наших примерах мы обычно группируем определения объектов в инструкции по 
  сходству употребления. Например, в следующей паре
</p>
<div class="lang-cpp"><![CDATA[int aCnt=0, eCnt=0, iCnt=0, oCnt=0, uCnt=0;
int charCnt=0, wordCnt=0;]]></div>

<p>первая инструкция объявляет пять очень похожих по назначению объектов – счетчиков 
  пяти гласных латинского алфавита. Счетчики для подсчета символов и слов определяются 
  во второй инструкции. Хотя такой подход нам кажется естественным и удобным, 
  нет никаких причин считать его хоть чем-то лучше других.
</p>

<p>Упражнение 5.1:
Представьте себе, что вы являетесь руководителем программного проекта и хотите, 
  чтобы применение инструкций объявления было унифицировано. Сформулируйте правила 
  использования объявлений объектов для вашего проекта.
</p>

<p>Упражнение 5.2:
Представьте себе, что вы только что присоединились к проекту из предыдущего 
  упражнения. Вы совершенно не согласны не только с конкретными правилами использования 
  инструкций объявления, но и вообще с навязыванием каких-либо правил для этого. 
  Объясните свою позицию.
</p>

</section>

<section id="insn_if">
<title>Инструкция if</title>

<p>Инструкция if обеспечивает выполнение или пропуск инструкции или блока в зависимости 
  от условия. Ее синтаксис таков:
</p>

<div class="lang-cpp"><![CDATA[if ( условие )
инструкция]]></div>

<p>условие заключается в круглые скобки. Оно может быть выражением, как в этом 
  примере:
</p>

<div class="lang-cpp"><![CDATA[if(a+b>c) { ... }]]></div>

<p>или инструкцией объявления с инициализацией:
</p>

<div class="lang-cpp"><![CDATA[if ( int ival = compute_value() ){...}]]></div>

<p>Область видимости объекта, объявленного в условной части, ограничивается ассоциированной 
  с if инструкцией или блоком. Например, такой код вызывает ошибку компиляции:
</p>

<div class="lang-cpp"><![CDATA[if ( int ival = compute_value() ) {
   // область видимости ival
   // ограничена этим блоком
}
// ошибка: ival невидим
if ( ! ival ) ...]]></div>
<p>Попробуем для иллюстрации применения инструкции if реализовать функцию min(), 
  возвращающую наименьший элемент вектора. Заодно наша функция будет подсчитывать 
  число элементов, равных минимуму. Для каждого элемента вектора мы должны проделать 
  следующее:
</p>
<ol>
  <li> Сравнить элемент с текущим значением минимума.</li>
  <li> Если элемент меньше, присвоить текущему минимуму значение элемента и сбросить 
    счетчик в 1.</li>
  <li> Если элемент равен текущему минимуму, увеличить счетчик на 1.</li>
  <li> В противном случае ничего не делать.</li>
  <li> После проверки последнего элемента вернуть значение минимума и счетчика.</li>
</ol>

<p>Необходимо использовать две инструкции if:
</p>

<div class="lang-cpp"><![CDATA[
if ( minVal > ivec[ i ] )...// новое значение minVal
if ( minVal == ivec[ i ] )...// одинаковые значения
]]></div>

<p>Довольно часто программист забывает использовать фигурные скобки, если нужно 
  выполнить несколько инструкций в зависимости от условия:
</p>
<div class="lang-cpp"><![CDATA[if ( minVal > ivec[ i ] )
minVal = ivec[ i ];
occurs = 1; // не относится к if!]]></div>
<p>Такую ошибку трудно увидеть, поскольку отступы в записи подразумевают, что 
  и minVal=ivec[i], и occurs=1 входят в одну инструкцию if. На самом же деле инструкция
</p>
<div class="lang-cpp"><![CDATA[occurs = 1;]]></div>
<p>не является частью if и выполняется безусловно, всегда сбрасывая occurs в 1. 
  Вот как должна быть составлена правильная if-инструкция (точное положение открывающей 
  фигурной скобки является поводом для бесконечных споров):
</p>
<div class="lang-cpp"><![CDATA[if ( minVal > ivec[ i ] )
{
   minVal = ivec[ i ];
   occurs = 1;
}]]></div>
<p>Вторая инструкция if выглядит так:
</p>
<div class="lang-cpp"><![CDATA[if ( minVal == ivec [ i ] )
   ++occurs;]]></div>
<p>Заметим, что порядок следования инструкций в этом примере крайне важен. Если 
  мы будем сравнивать minVal именно в такой последовательности, наша функция всегда 
  будет ошибаться на 1:
</p>
<div class="lang-cpp"><![CDATA[if ( minVal > ivec[ i ] ) {
   minVal = ivec[ i ];
   occurs = 1;
}
// если minVal только что получила новое значение,
// то occurs будет на единицу больше, чем нужно
if ( minVal == ivec[ i ] ) 
   ++occurs;]]></div>
<p>Выполнение второго сравнения не обязательно: один и тот же элемент не может 
  одновременно быть и меньше и равен minVal. Поэтому появляется необходимость 
  выбора одного из двух блоков в зависимости от условия, что реализуется инструкцией 
  if-else, второй формой if-инструкции. Ее синтаксис выглядит таким образом:
</p>
<div class="lang-cpp"><![CDATA[if ( условие )
   инструкция1
else
   инструкция2]]></div>
<p>инструкция1 выполняется, если условие истинно, иначе переходим к инструкция2. 
  Например:
</p>
<div class="lang-cpp"><![CDATA[if ( minVal == ivec[ i ] )
   ++occurs;
else
   if ( minVal > ivec[ i ] ) {
      minVal = ivec[ i ];
      occurs = 1;
   }]]></div>
<p>Здесь инструкция2 сама является if-инструкцией. Если minVal меньше ivec[i], 
  никаких действий не производится.

  В следующем примере выполняется одна из трех инструкций:
</p>
<div class="lang-cpp"><![CDATA[if ( minVal < ivec[ i ] )
{} // пустая инструкция
else
if ( minVal > ivec[ i ] ) {
   minVal = ivec[ i ];
   occurs = 1;
}
else // minVal == ivec[ i ]
++occurs;]]></div>
<p>Составные инструкции if-else могут служить источником неоднозначного толкования, 
  если частей else больше, чем частей if. К какому из if отнести данную часть 
  else? (Эту проблему иногда называют проблемой висячего else). Например:
</p>
<div class="lang-cpp"><![CDATA[if ( minVal <= ivec[ i ] )
   if ( minVal == ivec[ i ] )
      ++occurs;
else {
   minVal = ivec[ i ];
   occurs = 1;
}]]></div>
<p>Судя по отступам, программист предполагает, что else относится к самому первому, 
  внешнему if. Однако в С++ неоднозначность висячих else разрешается соотнесением 
  их с последним встретившимся if. Таким образом, в действительности предыдущий 
  фрагмент означает следующее:
</p>
<div class="lang-cpp"><![CDATA[if ( minVal <= ivec[ i ] ) {
   if ( minVal == ivec[ i ] )
      ++occurs;
   else {
      minVal = ivec[ i ];
      occurs = 1;
   }
}]]></div>
<p>Одним из способов разрешения данной проблемы является заключение внутреннего 
  if в фигурные скобки:
</p>
<div class="lang-cpp"><![CDATA[if ( minVal <= ivec[ i ] ) {
   if ( minVal == ivec[ i ] )
      ++occurs;
}
else {
   minVal = ivec[ i ];
   occurs = 1;
}]]></div>

<p>В некоторых стилях программирования рекомендуется всегда употреблять фигурные 
  скобки при использовании инструкций if-else, чтобы не допустить возможности 
  неправильной интерпретации кода.
</p>

<p>Вот первый вариант функции min(). Второй аргумент функции будет возвращать количество 
  вхождений минимального значения в вектор. Для перебора элементов массива используется 
  цикл for. Но мы допустили ошибку в логике программы. Сможете ли вы заметить ее?
</p>

<div class="lang-cpp"><![CDATA[
#include <vector>
int min(const vector<int>& ivec, int& occurs) {
   int minVal = 0;
   occurs = 0;
   int size = ivec.size();
   for (int ix = 0; ix < size; ++ix) {
      if (minVal == ivec[ix])
         ++occurs;
      else
      if (minVal > ivec[ix] ) {
         minVal = ivec[ix];
         occurs = 1;
      }
   }
  return minVal;
}
]]></div>

<p>Обычно функция возвращает только одно значение.
Однако согласно нашей спецификации в точке вызова должно быть известно не только само минимальное значение, но и количество его вхождений в вектор.
Для возврата второго значения мы использовали параметр типа ссылка.
Любое присваивание значения ссылке occurs изменяет значение переменной, на которую она ссылается:
</p>

<div class="lang-cpp"><![CDATA[
int main() {
   int occur_cnt = 0;
   vector< int > ivec;
   // occur_cnt получает значение occurs
   // из функции min()
   int minval = min( ivec, occur_cnt );
   // ...
}
]]></div>

<p>Альтернативой использованию параметра-ссылки является применение объекта класса pair.
Функция min() могла бы возвращать два значения в одной паре:
</p>

<div class="lang-cpp"><![CDATA[
// альтернативная реализация
// с помощью пары

#include <utility>
#include <vector>
typedef pair<int,int> min_va1_pair;

min_va1_pair min(const vector<int> &ivec) {
   int minVal = 0;
   int occurs = 0;
   // то же самое ...
   return make_pair( minVal, occurs );
}
]]></div>

<p>К сожалению, и эта реализация содержит ошибку. Где же она? Правильно: мы инициализировали 
  minVal нулем, поэтому, если минимальный элемент вектора больше нуля, наша реализация 
  вернет нулевое значение минимума и нулевое значение количества вхождений.
</p>

<p>Программу можно изменить, инициализировав minVal первым элементом вектора:
</p>

<div class="lang-cpp"><![CDATA[int minVal = ivec[0];]]></div>

<p>Теперь функция работает правильно. Однако в ней выполняются некоторые лишние действия, снижающие ее эффективность.

</p>
<div class="lang-cpp"><![CDATA[// исправленная версия min()
// оставляющая возможность для оптимизации ...
int minVal = ivec[0];
occurs = 0;
int size = ivec.size();
for ( int ix = 0; ix < size; ++ix )
{
   if ( minVal == ivec[ ix ] )
   ++occurs;
   // ...]]></div>
<p>Поскольку ix инициализируется нулем, на первой итерации цикла значение первого 
  элемента сравнивается с самим собой. Можно инициализировать ix единицей и избежать 
  ненужного выполнения первой итерации. Однако при оптимизации кода мы допустили 
  другую ошибку (наверное, стоило все оставить как было!). Сможете ли вы ее обнаружить?
</p>
<div class="lang-cpp"><![CDATA[// оптимизированная версия min(),
// к сожалению, содержащая ошибку...
int minVal = ivec[0];
occurs = 0;
int size = ivec.size();
for ( int ix = 1; ix < size; ++ix )
{
  if ( minVal == ivec[ ix ] )
  ++occurs;
   // ...]]></div>
<p>Если ivec[0] окажется минимальным элементом, переменная occurs не получит значения 
  1. Конечно, исправить это очень просто, но сначала надо найти ошибку:
</p>
<div class="lang-cpp"><![CDATA[int minVal = ivec[0];
occurs = 1;]]></div>
<p>К сожалению, подобного рода недосмотры встречаются не так уж редко: программисты 
  тоже люди и могут ошибаться. Важно понимать, что это неизбежно, и быть готовым 
  тщательно тестировать и анализировать свои программы.
</p>

<p>Вот окончательная версия функции min() и программа main(), проверяющая ее работу:
</p>

<div class="lang-cpp"><![CDATA[
#include <iostream>
#include<vector>
int min(const vector<int> &ivec, int &occurs) {
   int minVal = ivec[ 0 ];
   occurs = 1;
   int size = ivec.size();
   for (int ix = 1; ix < size; ++ix ) {
      if (minVal == ivec[ ix ] )
         ++occurs;
      else
         if (minVal > ivec[ix]) {
            minVal = ivec[ix];
            occurs = 1;
         }
   }
   return minVal;
}

int main()
{
   int ia[] = { 9,1,7,1,4,8,1,3,7,2,6,1,5,1 };
   vector<int> ivec( ia, ia+14 );
   int occurs = 0;
   int minVal = min( ivec, occurs );
   cout << "Минимальное значение: " << minVal
         << " встречается: " << occurs << " раз.\n";
   return 0;
}]]></div>
<p>Результат работы программы:
</p>
<div class="lang-cpp"><![CDATA[Минимальное значение: 1 встречается: 5 раз.]]></div>
<p>В некоторых случаях вместо инструкции if-else можно использовать более краткое 
  и выразительное условное выражение. Например, следующую реализацию функции min():
</p>
<div class="lang-cpp"><![CDATA[
template <class valueType>
inline const valueType& min( valueType& vall, valueType& va12) {
   if ( vall < va12 )
      return vall;
   return va12;
}
]]></div>

<p>можно переписать так:
</p>

<div class="lang-cpp"><![CDATA[
template <class valueType>
inline const valueType& min(valueType& vall, valueType& va12) {
   return ( vall < va12 ) ? vall : va12;
}
]]></div>

<p>Длинные цепочки инструкций if-else, подобные приведенной ниже, трудны для восприятия 
  и, таким образом, являются потенциальным источником ошибок.
</p>
<div class="lang-cpp"><![CDATA[if ( ch == 'a' ||
   ch == 'A' )
      ++aCnt;
else
if ( ch == 'e' ||
   ch == 'E' )
      ++eCnt;
else
   if ( ch == 'i' ||
   ch == 'I' )
      ++iCnt;
else
   if ( ch == 'o' ||
      ch == '0' )
         ++oCnt;
else
   if ( ch == 'u' ||
      ch == 'U' )
         ++uCnt;]]></div>
<p>В качестве альтернативы таким цепочкам С++ предоставляет инструкцию switch. 
  Это тема следующего раздела.
</p>

<h4>Упражнение 5.3</h4>
<p>Исправьте ошибки в примерах:
</p>

<div class="lang-cpp"><![CDATA[
(a) if ( ivall != iva12 )
       ivall = iva12
    else 
      ivall = iva12 = 0;

(b) if ( ivat < minval )
         minvat = ival;
      occurs = 1;

(c) if ( int ival = get_value())
         cout << "ival = "
              << ival << endl;
      if ( ! ival )
         cout << "ival = 0\n";

(d) if ( ival = 0 )
      ival = get_value();

(e) if ( iva1 == 0 )
      else ival = 0;
]]></div>

<h4>Упражнение 5.4</h4>

<p>Преобразуйте тип параметра occurs функции min(), сделав его не ссылкой, а простым 
  объектом. Запустите программу. Как изменилось ее поведение? 
</p>

</section>

<section id="insn_switch">
<title>Инструкция switch</title>

<p>Длинные цепочки инструкций if-else, наподобие приведенной в конце предыдущего 
  раздела, трудны для восприятия и потому являются потенциальным источником ошибок. 
  Модифицируя такой код, легко сопоставить, например, разные else и if. Альтернативный 
  метод выбора одного их взаимоисключающих условий предлагает инструкция switch.
</p>

<p>Для иллюстрации инструкции switch рассмотрим следующую задачу. Нам надо подсчитать, 
  сколько раз встречается каждая из гласных букв в указанном отрывке текста. (Общеизвестно, 
  что буква e – наиболее часто встречающаяся гласная в английском языке.) Вот 
  алгоритм программы:
</p>

<ol>
  <li> Считывать по одному символу из входного потока, пока они не кончатся.</li>
  <li> Сравнить каждый символ с набором гласных.</li>
  <li> Если символ равен одной из гласных, прибавить 1 к ее счетчику.</li>
  <li> Напечатать результат.</li>
</ol>
<p>Написанная программа была запущена, в качестве контрольного текста использовался 
  раздел из оригинала данной книги. Результаты подтвердили, что буква e действительно 
  самая частая:
</p>
<div class="lang-cpp"><![CDATA[aCnt: 394
eCnt: 721
iCnt: 461
oCnt: 349
uCnt: 186]]></div>

<p>Инструкция switch состоит из следующих частей:
</p>

<ul>
  <li> ключевого слова switch, за которым в круглых скобках идет выражение, являющееся 
    условием: 
<div class="lang-cpp"><![CDATA[char ch;
while ( cm >> ch )
  switch( ch )]]></div>
  </li>
  <li> набора меток case, состоящих из ключевого слова case и константного выражения, 
    с которым сравнивается условие. В данном случае каждая метка представляет 
    одну из гласных латинского алфавита: 
<div class="lang-cpp"><![CDATA[case 'a':
case 'e':
case 'i':
case 'o':
case 'u':]]></div>
  </li>
  <li> последовательности инструкций, соотносимых с метками case. В нашем примере 
    с каждой меткой будет сопоставлена инструкция, увеличивающая значение соответствующего 
    счетчика;</li>
  <li> необязательной метки default, которая является аналогом части else инструкции 
    if-else. Инструкции, соответствующие этой метке, выполняются, если условие 
    не отвечает ни одной из меток case. Например, мы можем подсчитать суммарное 
    количество встретившихся символов, не являющихся гласными буквами: 
<div class="lang-cpp"><![CDATA[default: // любой символ, не являющийся гласной
++non_vowe1_cnt;]]></div>
  </li>
</ul>

<p>Константное выражение в метке case должно принадлежать к целому типу, поэтому 
  следующие строки ошибочны:
</p>

<div class="lang-cpp"><![CDATA[
// неверные значения меток
case 3.14: // не целое
case ival: // не константа
]]></div>

<p>Кроме того, две разные метки не могут иметь одинаковое значение.
</p>

<p>Выражение условия в инструкции switch может быть сколь угодно сложным, в том 
  числе включать вызовы функций. Результат вычисления условия сравнивается с метками 
  case, пока не будет найдено равное значение или не выяснится, что такого значения 
  нет. Если метка обнаружена, выполнение будет продолжено с первой инструкции 
  после нее, если же нет, то с первой инструкции после метки default (при ее наличии) 
  или после всей составной инструкции switch.
</p>

<p>В отличие от if-else инструкции, следующие за найденной меткой, выполняются 
  друг за другом, проходя все нижестоящие метки case и метку default. Об этом 
  часто забывают. Например, данная реализация нашей программы выполняется совершенно 
  не так, как хотелось бы:
</p>

<div class="lang-cpp"><![CDATA[
#include <iostream>

int main() {
  char ch;
  int aCnt=0, eCnt=0, iCnt=0, oCnt=0, uCnt=0;
  while ( cin >> ch )
    // Внимание! неверная реализация!
    switch ( ch ) {
      case 'a':
            ++aCnt;
      case 'e':
            ++eCnt;
      case 'i':
            ++iCnt;
      case 'o':
            ++oCnt;
      case 'u':
            ++uCnt;
    }

    cout << "Встретилась a: \t" << aCnt << '\n'
         << "Встретилась e: \t" << eCnt << '\n'
         << "Встретилась i: \t" << iCnt << '\n'
         << "Встретилась o: \t" << oCnt << '\n'
         << "Встретилась u: \t" << uCnt << '\n';
}]]></div>

<p>Если значение ch равно i, выполнение начинается с инструкции после case 'i' 
  и iCnt возрастет на 1. Однако следующие ниже инструкции, ++oCnt и ++uCnt, также 
  выполняются, увеличивая значения и этих переменных. Если же переменная ch равна 
  a, изменятся все пять счетчиков.
</p>

<p>Программист должен явно дать указание компьютеру прервать последовательное выполнение 
  инструкций в определенном месте switch, вставив break. В абсолютном большинстве 
  случаев за каждой метке case должен следовать соответствующий break.
</p>

<p>break прерывает выполнение switch и передает управление инструкции, следующей 
  за закрывающей фигурной скобкой, – в данном случае производится вывод. Вот как 
  это должно выглядеть:
</p>

<div class="lang-cpp"><![CDATA[
switch ( ch ) {
   case 'a':
       ++aCnt;
       break;
   case 'e':
       ++eCnt;
       break;
   case 'i':
       ++iCnt;
       break;
   case 'o':
       ++oCnt;
       break;
   case 'u':
       ++uCnt;
       break;
}]]></div>

<p>Если почему-либо нужно, чтобы одна из секций не заканчивалась инструкцией break, 
  то желательно написать в этом месте разумный комментарий. Программа создается 
  не только для машин, но и для людей, и необходимо сделать ее как можно более 
  понятной для читателя. Программист, изучающий чужой текст, не должен сомневаться, 
  было ли нестандартное использование языка намеренным или ошибочным.
</p>

<p>При каком условии программист может отказаться от инструкции break и позволить 
  программе провалиться сквозь несколько меток case? Одним из таких случаев является 
  необходимость выполнить одни и те же действия для двух или более меток. Это 
  может понадобиться потому, что с case всегда связано только одно значение. Предположим, 
  мы не хотим подсчитывать, сколько раз встретилась каждая гласная в отдельности, 
  нас интересует только суммарное количество всех встретившихся гласных. Это можно 
  сделать так:
</p>

<div class="lang-cpp"><![CDATA[int vowelCnt = 0;
// ...
switch ( ch )
{
   // любой из символов a,e,1,o,u
   // увеличит значение vowelCnt
   case 'a':
   case 'e':
   case 'i':
   case 'o':
   case 'u':
   ++vowe1Cnt;
   break;
}]]></div>
<p>Некоторые программисты подчеркивают осознанность своих действий тем, что предпочитают 
  в таком случае писать метки на одной строке:
</p>
<div class="lang-cpp"><![CDATA[switch ( ch )
{
   // допустимый синтаксис
   case 'a': case 'e':
   case 'i': case 'o': case 'u':
   ++vowe1Cnt;
   break;
}]]></div>

<p>В данной реализации все еще осталась одна проблема: как будут восприняты слова типа <dfn>UNIX</dfn>
</p>

<p>Наша программа не понимает заглавных букв, поэтому заглавные U и I не будут 
  отнесены к гласным. Исправить ситуацию можно следующим образом:
</p>

<div class="lang-cpp"><![CDATA[
switch ( ch ) {
   case 'a': case 'A':
       ++aCnt;
       break;
   case 'e': case 'E':
       ++eCnt;
       break;
   case 'i': case 'I':
       ++iCnt;
       break;
   case 'o': case 'O':
       ++oCnt;
       break;
   case 'u': case 'U':
       ++uCnt;
       break;
}]]></div>

<p>Метка default является аналогом части else инструкции if-else. Инструкции, 
  соответствующие default, выполняются, если условие не отвечает ни одной из меток 
  case. Например, добавим к нашей программе подсчет суммарного количества согласных:
</p>

<div class="lang-cpp"><![CDATA[
#include <iostream>
#include <cctype>

int main()
{
    char ch;
    int aCnt=0, eCnt=0, iCnt=0, oCnt=0, uCnt=0,
    consonantCount=0;

    while ( cin >> ch )
        switch ( ch ) {
            case 'a': case 'A':
                ++aCnt;
                break;
            case 'e': case 'E':
                ++eCnt;
                break;
            case 'i': case 'I':
                ++iCnt;
                break;
            case 'o': case 'O':
                ++oCnt;
                break;
            case 'u': case 'U':
                ++uCnt;
                break;
            default:
                if ( isa1pha( ch ) )
                    ++consonantCnt;
                break;
        }

    cout << "Встретилась a: \t" << aCnt << '\n'
        << "Встретилась e: \t" << eCnt << '\n'
        << "Встретилась i: \t" << iCnt << '\n'
        << "Встретилась o: \t" << oCnt << '\n'
        << "Встретилась u: \t" << uCnt << '\n'
        << "Встретилось согласных: \t" << consonantCnt
        << '\n';
}]]></div>

<p>isalpha() – функция стандартной библиотеки С; она возвращает true, если ее 
  аргумент является буквой. isalpha() объявлена в заголовочном файле ctype.h. 
  (Функции из ctype.h мы будем рассматривать в главе 6.)
</p>

<p>Хотя оператор break функционально не нужен после последней метки в инструкции 
  switch, лучше его все-таки ставить. Причина проста: если мы впоследствии захотим 
  добавить еще одну метку после case, то с большой вероятностью забудем вписать 
  недостающий break.
</p>

<p>Условная часть инструкции switch может содержать объявление, как в следующем 
  примере:

  switch( int ival = get_response() )
</p>

<p>ival инициализируется значением, получаемым от get_response(), и это значение 
  сравнивается со значениями меток case. Переменная ival видна внутри блока switch, 
  но не вне его.
</p>

<p>Помещать же инструкцию объявления внутри тела блока switch не разрешается. Данный 
  фрагмент кода не будет пропущен компилятором:
</p>

<div class="lang-cpp"><![CDATA[case illegal_definition:
// ошибка: объявление не может
// употребляться в этом месте
 string file_name = get_file_name();
// ...
break;]]></div>

<p>Если бы разрешалось объявлять переменную таким образом, то ее было бы видно 
  во всем блоке switch, однако инициализируется она только в том случае, если 
  выполнение прошло через данную метку case.
</p>

<p>Мы можем употребить в этом месте составную инструкцию, тогда объявление переменной 
  file_name будет синтаксически правильным. Использование блока гарантирует, что 
  объявленная переменная видна только внутри него, а в этом контексте она заведомо 
  инициализирована. Вот как выглядит правильный текст:
</p>

<div class="lang-cpp"><![CDATA[
case ok: {
    // ок
    string file_name = get_file_name();
    // ...
    break;
}
]]></div>

<h4>Упражнение 5.5</h4>

<p>Модифицируйте программу из данного раздела так, чтобы она подсчитывала не только 
  буквы, но и встретившиеся пробелы, символы табуляции и новой строки.
</p>

<h4>Упражнение 5.6</h4>

<p>Модифицируйте программу из данного раздела так, чтобы она подсчитывала также 
  количество встретившихся двухсимвольных последовательностей ff, fl и fi.
</p>

<h4>Упражнение 5.7</h4>

<p>Найдите и исправьте ошибки в следующих примерах:
</p>

<div class="lang-cpp"><![CDATA[//(a)
switch ( ival ) {
   case 'a': aCnt++;
   case 'e': eCnt++;
   default: iouCnt++;
}
//(b)
switch ( ival ) {
   case 1:
       int ix = get_value();
       ivec[ ix ] = ival;
       break;
   default:
       ix = ivec.sizeQ-1;
       ivec[ ix ] = ival;
}
//(c)
switch ( ival ) {
   case 1, 3, 5, 7, 9:
       oddcnt++;
       break;
   case 2, 4, 6, 8, 10:
       evencnt++;
       break;
 }
//(d)
int iva1=512 jva1=1024, kva1=4096;
int bufsize;
// ...
switch( swt ) {
   case ival:
       bufsize = ival * sizeof( int );
       break;
   case jval:
       bufsize = jval * sizeof( int );
       break;
   case kval:
       bufsize = kval * sizeof( int );
       break;
}
//(e)
enum { illustrator = 1, photoshop, photostyler = 2 };
switch ( ival ) {
   case illustrator:
       --i11us_1icense;
       break;
   case photoshop:
       --pshop_1icense;
       break;
   case photostyler:
       --psty1er_license;
       break;
}
]]></div>

</section>

<section id="insn_for">
<title>Инструкция цикла for</title>

<p>Как мы видели, выполнение программы часто состоит в повторении последовательности 
  инструкций - до тех пор, пока некоторое условие остается истинным. Например, 
  мы читаем и обрабатываем записи файла, пока не дойдем до его конца, перебираем 
  элементы массива, пока индекс не станет равным размерности массива минус 1, 
  и т.д. В С++ предусмотрено три инструкции для организации циклов, в частности 
  for и while, которые начинаются проверкой условия. Такая проверка означает, 
  что цикл может закончиться без выполнения связанной с ним простой или составной 
  инструкции. Третий тип цикла, do while, гарантирует, что тело будет выполнено 
  как минимум один раз: условие цикла проверяется по его завершении. (В этом разделе 
  мы детально рассмотрим цикл for; в разделе 5.6 разберем while, а в разделе 5.7 
  - do while.)
</p>

<p>Цикл for обычно используется для обработки структур данных, имеющих фиксированную 
  длину, таких, как массив или вектор:
</p>

<div class="lang-cpp"><![CDATA[
#include <vector>
int main() {
int ia[ 10 ];
for ( int ix = 0; ix < 10; ++-ix )
  ia[ ix ] = ix;
vector<int> ivec( ia, ia+10 );
vector<int>::iterator iter = ivec.begin() ;

for ( ; iter != ivec.end(); ++iter )
  *iter *= 2;
return 0;
}]]></div>

<p>Синтаксис цикла for следующий:
</p>

<div class="lang-cpp"><![CDATA[for (инструкция-инициализации; условие; выражение )
   инструкция]]></div>

<p>инструкция-инициализации может быть либо выражением, либо инструкцией объявления. 
  Обычно она используется для инициализации переменной значением, которое увеличивается 
  в ходе выполнения цикла. Если такая инициализация не нужна или выполняется где-то 
  в другом месте, эту инструкцию можно заменить пустой (см. второй из приведенных 
  ниже примеров). Вот примеры правильного использования инструкции-инициализации:
</p>

<div class="lang-cpp"><![CDATA[// index и iter определены в другом месте
for ( index =0; ...
for ( ; /* пустая инструкция */ ...
for ( iter = ivec.begin(); ...
for ( int 1o = 0,hi = max; ...
for ( char *ptr = getStr(); ...]]></div>
<p>условие служит для управления циклом. Пока условие при вычислении дает true, 
  инструкция продолжает выполняться. Выполняемая в цикле инструкция может быть 
  как простой, так и составной. Если же самое первое вычисление условия дает false, 
  инструкция не выполняется ни разу. Правильные условия можно записать так:
</p>
<div class="lang-cpp"><![CDATA[(... index < arraySize; ... )
(... iter != ivec.end(); ... )
(... *stl++ = *st2++; ... )
(... char ch = getNextChar(); ... )]]></div>
<p>Выражение вычисляется после выполнения инструкции на каждой итерации цикла. 
  Обычно его используют для модификации переменной, инициализированной в инструкции-инициализации. 
  Если самое первое вычисление условия дает false, выражение не выполняется ни 
  разу. Правильные выражения выглядят таким образом:
</p>
<div class="lang-cpp"><![CDATA[( ... ...; ++-index )
( ... ...; ptr = ptr->next )
( ... ...; ++i, --j, ++cnt )
( ... ...; ) // пустое выражение]]></div>
<p>Для приведенного ниже цикла for
</p>
<div class="lang-cpp"><![CDATA[const int sz = 24;
int ia[ sz ];
vector<int> ivec( sz );

for ( int ix = 0; ix < sz; ++ix ) {
   ivec[ ix ] = ix;
   ia[ ix ]= ix;
 }]]></div>
<p>порядок вычислений будет следующим:
</p>
<ol>
  <li>инструкция-инициализации выполняется один раз перед началом цикла. В данном 
    примере объявляется переменная ix, которая инициализируется значением 0.</li>
  <li> Вычисляется условие. Если оно равно true, выполняется составная инструкция 
    тела цикла. В нашем примере, пока ix меньше sz, значение ix присваивается 
    элементам ivec[ix] и ia[ix]. Когда значением условия станет false, выполнение 
    цикла прекратится. Если самое первое вычисление условия даст false, составная 
    инструкция выполняться не будет.</li>
  <li> Вычисляется выражение. Как правило, его используют для модификации переменной, 
    фигурирующей в инструкции-инициализации и проверяемой в условии. В нашем примере 
    ix увеличивается на 1.</li>
</ol>
<p>Эти три шага представляют собой полную итерацию цикла for. Теперь шаги 2 и 
  3 будут повторяться до тех пор, пока условие не станет равным false, т.е. ix 
  окажется равным или большим sz.
</p>

<p>В инструкции-инициализации можно определить несколько объектов, однако все они 
  должны быть одного типа, так как инструкция объявления допускается только одна:
</p>

<div class="lang-cpp"><![CDATA[
for ( int ival = 0, *pi = &ia, &ri = val;
   ival < size;
   ++iva1, ++pi, ++ri )
   // ...
]]></div>

<p>Объявление объекта в условии гораздо труднее правильно использовать: такое 
  объявление должно хотя бы раз дать значение false, иначе выполнение цикла никогда 
  не прекратится. Вот пример, хотя и несколько надуманный:
</p>
<div class="lang-cpp"><![CDATA[#include <iostream>
int main()
{
   for ( int ix = 0;
      bool done = ix == 10;
      ++ix )
         cout << "ix: " << ix << endl;
}]]></div>
<p>Видимость всех объектов, определенных внутри круглых скобок инструкции for, 
  ограничена телом цикла. Например, проверка iter после цикла вызовет ошибку компиляции 
  :
</p>
<div class="lang-cpp"><![CDATA[int main()
{
   string word;
   vector< string > text;
   // ...
   for ( vector< string >::iterator
      iter = text.begin(),
      iter_end = text.end();
      iter != text.end(); ++iter )
   {
      if ( *iter == word )
      break;
      // ...
}

// ошибка: iter и iter_end невидимы
  if ( iter != iter_end )
  // ...]]></div>

<h4>Упражнение 5.8</h4>

<p>Допущены ли ошибки в нижеследующих циклах for? Если да, то какие?
</p>

<div class="lang-cpp"><![CDATA[
(a)
   for ( int *ptr = &ia, ix = 0;
         ix < size && ptr != ia+size;
         ++ix, ++ptr )
            // ...

(b)
   for ( ; ; ) {
      if ( some_condition )
         break;
      // ...
   }

(c)
   for ( int ix = 0; ix < sz; ++ix )
      // ...

   if ( ix != sz )
      // ...

(d)
   int ix;
   for ( ix < sz; ++ix ) 
   // ...

(e)
   for ( int ix = 0; ix < sz; ++ix, ++ sz ) 
   // ...
]]></div>

<h4>Упражнение 5.9</h4>

<p>Представьте, что вам поручено придумать общий стиль использования цикла for 
  в вашем проекте. Объясните и проиллюстрируйте примерами правила использования 
  каждой из трех частей цикла.
</p>

<p>Упражнение 5.10:
Дано объявление функции:
</p>

<div class="lang-cpp"><![CDATA[
bool is_equa1(const vector<int>& vl, const vector<int>& v2);
]]></div>

<p>Напишите тело функции, определяющей равенство двух векторов. Для векторов разной 
  длины сравнивайте только то количество элементов, которое соответствует меньшему 
  из двух. Например, векторы (0,1,1,2) и (0,1,1,2,3,5,8) считаются равными. Длину 
  векторов можно узнать с помощью функций v1.size() и v2.size().
</p>

</section>

<section id="insn_while">
<title>Инструкция цикла while</title>

<p>Синтаксис инструкции while следующий:
</p>

<div class="lang-cpp"><![CDATA[
while ( условие )
    инструкция
]]></div>

<p>Пока значением условия является true, инструкция выполняется в такой последовательности:
</p>

<ol>
<li>Вычислить условие.</li>
<li>Выполнить инструкцию, если условие истинно.</li>
<li>Если самое первое вычисление условия дает false, инструкция не выполняется.</li>
</ol>

<p>Условием может быть любое выражение:
</p>

<div class="lang-cpp"><![CDATA[bool quit = false;
// ...
while ( ! quit ) {
   // ...
   quit = do_something();
}
]]></div>

<div class="lang-cpp"><![CDATA[
string word;
while ( cin >> word ){ ... }
или объявление с инициализацией:
while ( symbol *ptr = search( name )) {
   // что-то сделать
}
]]></div>

<p>В последнем случае ptr видим только в блоке, соответствующем инструкции while, 
  как это было и для инструкций for и switch.
  Вот пример цикла while, обходящего множество элементов, адресуемых двумя указателями:
</p>

<div class="lang-cpp"><![CDATA[
int sumit(int *parray_begin, int *parray_end) {
   int sum = 0;
   if ( ! parray_begin || ! parray_end )
      return sum;
   while ( parray_begin != parray_end )
      // прибавить к sum
      // и увеличить указатель
      sum += *parray_begin++;
   return sum;
}

int ia[6] = { 0, 1, 2, 3, 4, 5 };
int main() {
   int sum = sumit( &ia[0], &ia[ 6 ] );
   // ...
}
]]></div>

<p>Для того чтобы функция sumit() выполнялась правильно, оба указателя должны 
  адресовать элементы одного и того же массива (parray_end может указывать на 
  элемент, следующий за последним). В противном случае sumit() будет возвращать 
  бессмысленную величину. Увы, С++ не гарантирует, что два указателя адресуют 
  один и тот же массив. Как мы увидим в главе 12, стандартные универсальные алгоритмы 
  реализованы подобным же образом, они принимают параметрами указатели на первый 
  и последний элементы массива.
</p>

<h4>Упражнение 5.11</h4>

<p>Какие ошибки допущены в следующих циклах while:
</p>
<div class="lang-cpp"><![CDATA[(a)
   string bufString, word;
   while ( cin >> bufString >> word )
   // ...
(b)
   while ( vector<int>::iterator iter != ivec.end() )
   // ...
(c)
   while ( ptr = 0 )
   ptr = find_a_value();
(d)
   while ( bool status = find( word )) {
   word = get_next_word();
   if ( word.empty() )
   break;
   // ...
   }
   if ( ! status )
   cout << "Слов не найдено\n";]]></div>

<h4>Упражнение 5.12</h4>

<p>while обычно применяется для циклов, выполняющихся, пока некоторое условие 
  истинно, например, читать следующее значение, пока не будет достигнут конец 
  файла. for обычно рассматривается как пошаговый цикл: индекс пробегает по определенному 
  диапазону значений. Напишите по одному типичному примеру for и while, а затем 
  измените их, используя цикл другого типа. Если бы вам нужно было выбрать для 
  постоянной работы только один из этих типов, какой бы вы выбрали? Почему?
</p>

<h4>Упражнение 5.13</h4>

<p>Напишите функцию, читающую последовательность строк из стандартного ввода до 
  тех пор, пока одно и то же слово не встретится два раза подряд либо все слова 
  не будут обработаны. Для чтения слов используйте while; при обнаружении повтора 
  слова завершите цикл с помощью инструкции break. Если повторяющееся слово найдено, 
  напечатайте его. В противном случае напечатайте сообщение о том, что слова не 
  повторялись. 
</p>

</section>

<section id="insn_do_while">
<title>Инструкция цикла do-while</title>

<p> Представим, что нам надо написать программу, переводящую мили в километры. 
  Структура программы выглядит так:
</p>

<div class="lang-cpp"><![CDATA[int val;
bool more = true; // фиктивное значение, нужное для
// начала цикла

while ( more ) {
   val = getValue();
   val = convertValue(val);
   printValue(val);
   more = doMore();
}]]></div>
<p>Проблема заключается в том, что условие вычисляется в теле цикла. for и while 
  требуют, чтобы значение условия равнялось true до первого вхождения в цикл, 
  иначе тело не выполнится ни разу. Это означает, что мы должны обеспечить такое 
  условие до начала работы цикла. Альтернативой может служить использование do 
  while, гарантирующего выполнение тела цикла хотя бы один раз. Синтаксис цикла 
  do while таков:
</p>
<div class="lang-cpp"><![CDATA[do
   инструкция
while ( условие );]]></div>
<p>инструкция выполняется до первой проверки условия. Если вычисление условия 
  дает false, цикл останавливается. Вот как выглядит предыдущий пример с использованием 
  цикла do while:
</p>
<div class="lang-cpp"><![CDATA[do {
   val = getValue();
   val = convertValue(val);
   printValue(val);
   } while doMore();]]></div>
<p>В отличие от остальных инструкций циклов, do while не разрешает объявлять объекты 
  в своей части условия. Мы не можем написать:
</p>
<div class="lang-cpp"><![CDATA[// ошибка: объявление переменной
// в условии не разрешается
do {
   // ...
   mumble( foo );
} while ( int foo = get_foo() ) // ошибка]]></div>
<p>потому что до условной части инструкции do while мы дойдем только после первого 
  выполнения тела цикла.
</p>

<h4>Упражнение 5.14</h4>

<p>Какие ошибки допущены в следующих циклах do while:
</p>

<div class="lang-cpp"><![CDATA[(a)
do
   string rsp;
   int vail, va12;
   cout << "Введите два числа: ";
   c-in >> vail >> va12;
   cout << "Сумма " << vail
   << " и " << va12
   << " = " << vail + va12 << "\n\n"
   << "Продолжить? [да][нет] ";
   cin >> rsp;
while ( rsp[0] != 'n' );

(b)
do {
   // ...
   } while ( int iva1 = get_response() );
   (c)
   do {
   int ival = get_response();
   if ( iva1 == some_value() )
   break;
} while ( iva1 );
if ( !iva1 )
 // ...]]></div>

<h4> Упражнение 5.15</h4>

<p>Напишите небольшую программу, которая запрашивает у пользователя две строки 
  и печатает результат лексикографического сравнения этих строк (строка считается 
  меньшей, если идет раньше при сортировке по алфавиту). Пусть она повторяет эти 
  действия, пока пользователь не даст команду закончить. Используйте тип string, 
  сравнение строк и цикл do while.
</p>

</section>

<section id="insn_break">
<title>Инструкция break</title>

<p>Инструкция break останавливает циклы for, while, do while и блока switch. Выполнение 
  программы продолжается с инструкции, следующей за закрывающей фигурной скобкой 
  цикла или блока. Например, данная функция ищет в массиве целых чисел определенное 
  значение. Если это значение найдено, функция сообщает его индекс, в противном 
  случае она возвращает -1. Вот как выглядит реализация функции:
</p>

<div class="lang-cpp"><![CDATA[
// возвращается индекс элемента или -1
int search( int *ia, int size, int value) {
   // проверка что ia != 0 и size > 0 ...
   int loc = -1;
   for ( int ix = 0; ix < size; ++ix ) {
      if ( value == ia[ ix ] ) { 
         // нашли!
         // запомним индекс и выйдем из цикла
         loc = ix;
         break;
      }
   } // конец цикла

   // сюда попадаем по break ...
   return loc;
}]]></div>
<p>В этом примере break прекращает выполнение цикла for и передает управление 
  инструкции, следующей за этим циклом, – в нашем случае return. Заметим, что 
  break выводит из блока, относящегося к инструкции for, а не if, хотя является 
  частью составной инструкции, соответствующей if. Использование break внутри 
  блока if, не входящего в цикл или в switch, является синтаксической ошибкой:
</p>
<div class="lang-cpp"><![CDATA[// ошибка: неверное использование break
if ( ptr ) {
   if ( *ptr == "quit" )
   break;
   // ...
}]]></div>
<p>Если эта инструкция используется внутри вложенных циклов или инструкций switch, 
  она завершает выполнение того внутреннего блока, в котором находится. Цикл или 
  switch, включающий тот цикл или switch, из которого мы вышли с помощью break, 
  продолжает выполняться. Например:
</p>
<div class="lang-cpp"><![CDATA[white ( cin >> inBuf )
{
   switch( inBuf[ 0 ] ) {
      case '-':
         for ( int ix = 1; ix < inBuf.size(); ++ix ) {
            if ( inBuf[ ix ] == ' ' )
               break; // #1
         // ...
         // ...
         }
         break; // #2
      case '+':
         // ...
   }
}]]></div>
<p>Инструкция break, помеченная // #1, завершает выполнение цикла for внутри ветви 
  case '-' блока switch, но не сам switch. Аналогично break // #2 завершает выполнение 
  блока switch, но не цикла while, в который тот входит.
</p>

</section>

<section id="insn_continue">
<title>Инструкция continue</title>

<p>Инструкция continue завершает текущую итерацию цикла и передает управление 
  на вычисление условия, после чего цикл может продолжиться. В отличие от инструкции 
  break, завершающей выполнение всего цикла, инструкция continue завершает выполнение 
  только текущей итерации. Например, следующий фрагмент программы читает из входного 
  потока по одному слову. Если слово начинается с символа подчеркивания, оно обрабатывается, 
  в противном случае программа переходит к новому слову.
</p>

<div class="lang-cpp"><![CDATA[
while ( cin >> inBuf ) {
   if ( inBuf[0] '= '_' )
      continue; // завершение итерации
   // обработка слова ...
}
]]></div>

<p>Инструкция continue может быть использована только внутри цикла.
</p>

</section>

<section id="insn_goto">
<title>Инструкция goto</title>

<p>Инструкция goto обеспечивает <em>безусловный </em>переход к другой инструкции 
  внутри той же функции, поэтому современная практика программирования выступает 
  против ее применения.

  Синтаксис goto следующий:
</p>

<div class="lang-cpp"><![CDATA[goto метка;]]></div>
<p>где метка – определенный пользователем идентификатор. Метка ставится перед 
  инструкцией, на которую можно перейти с помощью goto, и должна заканчиваться 
  двоеточием. Нельзя ставить метку непосредственно перед закрывающей фигурной 
  скобкой. Если же это необходимо, их следует разделить пустой инструкцией:
</p>
<div class="lang-cpp"><![CDATA[end: ; // пустая инструкция
}]]></div>
<p>

  Переход через инструкцию объявления в том же блоке с помощью goto невозможен. 
  Например, данная функция вызывает ошибку компиляции:
</p>
<div class="lang-cpp"><![CDATA[int oops_in_error() {
   // mumble ...
   goto end;
   // ошибка: переход через объявление
   int ix = 10;
   // ... код, использующий ix
   end: ;
}]]></div>

<p>Правильная реализация функции помещает объявление ix и использующие его инструкции 
  во вложенный блок:
</p>

<div class="lang-cpp"><![CDATA[
int oops_in_error() {
   // mumble ...
   goto end;

{
  // правильно: объявление во вложенном блоке
  int ix = 10;
  // ... код, использующий ix
}

 end: ;
}
]]></div>

<p>Причина такого ограничения та же, что и для объявлений внутри блока switch: 
  компилятор должен гарантировать, что для объявленного объекта конструктор и 
  деструктор либо выполняются вместе, либо ни один из них не выполняется. Это 
  и достигается заключением объявления во вложенный блок.
</p>

<p>Переход назад через объявление, однако, не считается ошибкой. Почему? Перепрыгнуть 
  через инициализацию объекта нельзя, но проинициализировать один и тот же объект 
  несколько раз вполне допустимо, хотя это может привести к снижению эффективности. 
  Например:
</p>

<div class="lang-cpp"><![CDATA[
// переход назад через объявление не считается ошибкой.
void mumble(int max_size) {
   begin:
   int sz = get_size();
   if ( sz <= 0 ) {
   // выдать предупреждение ...
   goto end;
   } else if ( sz > max_size )
   // получить новое значение sz
   goto begin;
{ // правильно: переход через целый блок
   int ia = new int[ sz ];
   doit( ia, sz ) ;
   delete [] ia;
}
end:
;
}
]]></div>

<p>Использование инструкции goto резко критикуется во всех современных языках 
  программирования. Ее применение приводит к тому, что ход выполнения программы 
  становится трудно понять и, следовательно, такую программу трудно модифицировать. 
  В большинстве случаев goto можно заменить на инструкции if или циклы. Если вы 
  все-таки решили использовать goto, не перескакивайте через большой фрагмент 
  кода, чтобы можно было легко найти начало и конец вашего перехода.
</p>

</section>

<section id="insn_sample">
<title>Пример связанного списка</title>

<p>В конце этого раздела мы покажем, как разработать класс, представляющий собой односвязный список.
  Если вы в первый раз читаете эту книгу, то можете пропустить данный раздел и 
  вернуться к нему после чтения главы 13. (Для усвоения этого материала нужно 
  представлять себе механизм классов С++, конструкторы, деструкторы и т.д.
</p>

<p>Список представляет собой последовательность элементов, каждый из которых содержит 
  значение некоторого типа и адрес следующего элемента (причем для последнего 
  из них адрес может быть нулевым). К любой такой последовательности всегда можно 
  добавить еще один элемент (хотя реальная попытка подобного добавления может 
  закончиться неудачно, если отведенная программе свободная память исчерпана). 
  Список, в котором нет ни одного элемента, называется пустым.
</p>

<p>Какие операции должен поддерживать список? Добавление (insert), удаление (remove) 
  и поиск (find) определенных элементов. Кроме того, можно запрашивать размер 
  списка (size), распечатывать его содержимое (display), проверять равенство двух 
  списков. Мы покажем также, как инвертировать (reverse) и сцеплять (concatenate) 
  списки.
</p>

<p>Простейшая реализация операции size() перебирает все элементы, подсчитывая их 
  количество. Более сложная реализация сохраняет размер как член данных; она намного 
  эффективнее, однако требует некоторого усложнения операций insert() и remove() 
  для поддержки размера в актуальном состоянии.
</p>

<p>Мы выбрали второй вариант реализации функции size() и храним размер списка в 
  члене данных. Мы предполагаем, что пользователи будут достаточно часто применять 
  эту операцию, поэтому ее необходимо реализовать как можно более эффективно.
</p>

<p>(Одним из преимуществ отделения открытого интерфейса от скрытой реализации является 
  то, что если наше предположение окажется неверным, мы сможем переписать реализацию, 
  сохранив открытый интерфейс – в данном случае тип возвращаемого значения и набор 
  параметров функции size() – и программы, использующие эту функцию, не нужно 
  будет модифицировать.)
</p>

<p>Операция insert() в общем случае принимает два параметра: указатель на один 
  из элементов списка и новое значение, которое вставляется после указанного элемента. 
  Например, для списка
</p>

<div class="lang-cpp"><![CDATA[1 1 2 3 8]]></div>

<p>вызов
</p>

<div class="lang-cpp"><![CDATA[mylist.insert (pointer_to_3, 5);]]></div>
<p>изменит наш список так:
</p>
<div class="lang-cpp"><![CDATA[1 1 2 3 5 8]]></div>
<p>Чтобы обеспечить подобную возможность, нам необходимо дать пользователю способ 
  получения адреса определенного элемента. Одним из способов может быть использование 
  функции find() – нахождение элемента с определенным значением:
</p>

<div class="lang-cpp"><![CDATA[pointer_to_3 = mylist.find( 3 );]]></div>

<p>find() принимает в качестве параметра значение из списка. Если элемент с таким 
  значением найден, то возвращается его адрес, иначе find() возвращает 0.
</p>

<p>Может быть два специальных случая вставки элемента: в начало и в конец списка. 
  Для этого требуется только задание значения:
</p>

<div class="lang-cpp"><![CDATA[insert_front( value );
insert_end( value );]]></div>

<p>Предусмотрим следующие операции удаления элемента с заданным значением, первого 
  элемента и всех элементов списка:

</p>
<div class="lang-cpp"><![CDATA[
remove(value);
remove_front();
remove_all();
]]></div>

<p>Функция display() распечатывает размер списка и все его элементы. Пустой список 
  можно представить в виде:
</p>

<div class="lang-cpp"><![CDATA[(0)( )]]></div>

<p>а список из семи элементов как:</p>

<div class="lang-cpp"><![CDATA[(7) ( 0 1 1 2 3 5 8 )]]></div>
<p>reverse() меняет порядок элементов на противоположный. После вызова
</p>
<div class="lang-cpp"><![CDATA[mylist.reverse();]]></div>
<p>предыдущий список выглядит таким образом:
</p>
<div class="lang-cpp"><![CDATA[(7) ( 8 5 3 2 1 1 0 )]]></div>
<p>Конкатенация добавляет элементы второго списка в конец первого. Например, для 
  двух списков:
</p>
<div class="lang-cpp"><![CDATA[(4)( 0 1 1 2 ) // listl
(4)( 2 3 5 8 ) // list2]]></div>
<p>операция
</p>
<div class="lang-cpp"><![CDATA[listl.concat( list2 );]]></div>
<p>превращает list1 в
</p>
<div class="lang-cpp"><![CDATA[(8) ( 0 1 1 2 2 3 5 8 )]]></div>
<p>Чтобы сделать из этого списка последовательность чисел Фибоначчи, мы можем 
  воспользоваться функцией remove():

  listl.remove( 2 );
</p>

<p>Мы определили поведение нашего списка, теперь можно приступать к реализации. 
  Пусть список (list) и элемент списка (list_item) будут представлены двумя разными 
  классами. (Ограничимся теми элементами, которые способны хранить только целые 
  значения. Отсюда названия наших классов – ilist и ilist_item.)
</p>

<p>Наш список содержит следующие члены: _at_front – адрес первого элемента, _at_end 
  – адрес последнего элемента и _size – количество элементов. При определении 
  объекта типа ilist все три члена должны быть инициализированы 0. Это обеспечивается 
  конструктором по умолчанию:
  class ilist_item;
</p>

<div class="lang-cpp"><![CDATA[
class ilist {
public:
   // конструктор по умолчанию
   ilist() : _at_front( 0 ),
   _at_end( 0 ), _size( 0 ) {}
// ...
private:
  ilist_item *_at_front;
  ilist_item *_at_end;
  int _size;
};
]]></div>

<p>Теперь мы можем определять объекты типа ilist, например:
</p>

<div class="lang-cpp"><![CDATA[ilist mylist;]]></div>

<p>но пока ничего больше. Добавим возможность запрашивать размер списка. Включим 
  объявление функции size() в открытый интерфейс списка и определим эту функцию 
  так:

  inline int ilist::size() { return _size; }

  Теперь мы можем использовать:

  int size = mylist.size();
</p>

<p>Пока не будем позволять присваивать один список другому и инициализировать один 
  список другим (впоследствии мы реализуем и это, причем такие изменения не потребуют 
  модификации пользовательских программ). Объявим копирующий конструктор и копирующий 
  оператор присваивания в закрытой части определения списка без их реализации. 
  Теперь определение класса ilist выглядит таким образом:
</p>

<div class="lang-cpp"><![CDATA[
class ilist {
public:
   // определения не показаны
   ilist();
   int size();
   // ...
private:
   // запрещаем инициализацию
   // и присваивание одного списка другому
   ilist(const ilist&);
   ilist& operator=(const ilist&);
   // данные-члены без изменения
};
]]></div>

<p>Обе строки следующей программы вызовут ошибки компиляции, потому что функция 
  main() не может обращаться к закрытым членам класса ilist:
</p>

<div class="lang-cpp"><![CDATA[
int main() {
   ilist yourlist( mylist ); // ошибка
   mylist = mylist; // ошибка
}
]]></div>

<p>Следующий шаг – вставка элемента, для представления которого мы выбрали отдельный 
  класс:
</p>
<div class="lang-cpp"><![CDATA[class ilist_item {
public:
   // ...
private:
   int _value;
   ilist_item *_next;
};]]></div>
<p>Член _value хранит значение, а _next – адрес следующего элемента или 0.

  Конструктор ilist_item требует задания значения и необязательного параметра 
  – адреса существующего объекта ilist_item. Если этот адрес задан, то создаваемый 
  объект ilist_item будет помещен в список после указанного. Например, для списка
</p>
<div class="lang-cpp"><![CDATA[0 1 1 2 5]]></div>
<p>вызов конструктора

  ilist_item ( 3, pointer_to_2 );

  модифицирует последовательность так:
</p>
<div class="lang-cpp"><![CDATA[0 1 1 2 3 5]]></div>
<p>Вот реализация ilist_item. Напомним, что второй параметр конструктора является необязательным.
Если пользователь не задал второй аргумент при вызове конструктора, по умолчанию употребляется 0.
Значение по умолчанию указывается в объявлении функции, а не в ее определении.
</p>

<div class="lang-cpp"><![CDATA[
class ilist_item {
public:
   ilist_item( int value, ilist_-item *item_to_link_to = 0 );
   // ...
};

inline ilist_item::ilist_item( int value, ilist_item *item )
  : _value( value )
{
  if ( item )
     _next = 0;
  else {
     _next = item->_next;
  item->_next = this;
}
]]></div>

<p>Операция insert() в общем случае работает с двумя параметрами – значением и 
  адресом элемента, после которого производится вставка. Наш первый вариант реализации 
  имеет два недочета. Сможете ли вы их найти?
</p>

<div class="lang-cpp"><![CDATA[
inline void ilist::insert(ilist_item *ptr, int value) {
   new ilist_item( value, ptr );
   ++_size;
}
]]></div>

<p>Одна из проблем заключается в том, что указатель не проверяется на нулевое 
  значение. Мы обязаны распознать и обработать такую ситуацию, иначе это приведет 
  к краху программы во время исполнения. Как реагировать на нулевой указатель? 
  Можно аварийно закончить выполнение, вызвав стандартную функцию abort(), объявленную 
  в заголовочном файле cstdlib:
</p>
<div class="lang-cpp"><![CDATA[#include <cstdlib>
// ...
if ( ! ptr )
   abort();]]></div>
<p>Кроме того, можно использовать макрос assert(). Это также приведет к аварийному 
  завершению, но с выводом диагностического сообщения:
</p>
<div class="lang-cpp"><![CDATA[#include <cassert>
// ...
assert( ptr != 0 );]]></div>
<p>Третья возможность – возбудить исключение:

  if ( ! ptr )

  throw "Panic: ilist::insert(): ptr == O";

  В общем случае желательно избегать аварийного завершения программы: в такой 
  ситуации мы заставляем пользователя беспомощно сидеть и ждать, пока служба поддержки 
  обнаружит и исправит ошибку.

  Если мы не можем продолжать выполнение там, где обнаружена ошибка, лучшим решением 
  будет возбуждение исключения: оно передает управление вызвавшей программе в 
  надежде, что та сумеет выйти из положения.

  Мы же поступим совсем другим способом: рассмотрим передачу нулевого указателя 
  как запрос на вставку элемента перед первым в списке:
</p>
<div class="lang-cpp"><![CDATA[if ( ! ptr )
   insert_front( value );]]></div>
<p>Второй изъян в нашей версии можно назвать философским. Мы реализовали size() 
  и _size как пробный вариант, который может впоследствии измениться. Если мы 
  преобразуем функции size() таким образом, что она будет просто пересчитывать 
  элементы списка, член _size перестанет быть нужным. Написав: ++_size;
</p>

<p>мы тесно связали реализацию insert() с текущей конструкцией алгоритма пересчета 
  элементов списка. Если мы изменим алгоритм, нам придется переписывать эту функцию, 
  как и insert_front(), insert_end() и все операции удаления из списка. Вместо 
  того чтобы распространять детали текущей реализации на разные функции класса, 
  лучше инкапсулировать их в паре:
</p>

<div class="lang-cpp"><![CDATA[inline void ilist::bump_up_size() { ++_size; }
inline void ilist::bump_down_size() { --_size; }]]></div>

<p>Поскольку мы объявили эти функции встроенными, эффективность не пострадала. 
  Вот окончательный вариант insert():

</p>
<div class="lang-cpp"><![CDATA[inline void
   ilist::
      insert( ilist_item *ptr, int value )
      if ( !ptr )
         insert_front( value );
      else {
         bump_up_size();
         new ilist_item( value, ptr );
      }
   }]]></div>
<p>Реализация функций insert_front() и insert_end() достаточно очевидна. В каждой 
  из них мы должны предусмотреть случай, когда список пуст.
</p>
<div class="lang-cpp"><![CDATA[inline void
   ilist::
   insert_front( int value )
   {
      ilist_item *ptr = new ilist_item( value );
      if ( !_at_front )
        _at_front = _at_end = ptr;
      else {
        ptr->next( _at_front );
        _at_front = ptr;
       }
      bump_up_size();
  }
inl-ine void
ilist::
  insert_end( int value )
  {
     if ( !_at_end )
        _at_end = _at_front = new ilist_item( value );
     else _at_end = new ilist_item( value, _at_end );
     bump_up_s-ize();
  }]]></div>
<p>find() ищет значение в списке. Если элемент с указанным значением найден, возвращается 
  его адрес, иначе find() возвращает 0. Реализация find()выглядит так:
</p>
<div class="lang-cpp"><![CDATA[ilist_item*
ilist::
find( int value )
{
   ilist_item *ptr = _at_front;
   while ( ptr )
   {
      if ( ptr->value() == value )
      break;
      ptr = ptr->next();
   }
   return ptr;
}]]></div>
<p>Функцию find() можно использовать следующим образом:
</p>
<div class="lang-cpp"><![CDATA[ilist_item *ptr = mylist.find( 8 );
mylist.insert( ptr, some_value );]]></div>
<p>или в более компактной записи:

  mylist.insert( mylist.find( 8 ), some_value );

  

  Перед тем как тестировать операции вставки элементов, нам нужно написать функцию 
  display(), которая поможет нам при отладке. Алгоритм display() достаточно прост: 
  печатаем все элементы, с первого до последнего. Можете ли вы сказать, где в 
  данной реализации ошибка?

  // не работает правильно!
</p>
<div class="lang-cpp"><![CDATA[for ( ilist_item *iter = _at_front; // начнем с первого
   iter != _at_end; // пока не последний
      ++iter ) // возьмем следующий
         cout << iter->value() << ' ';

// теперь напечатаем последний
cout << iter->value();]]></div>
<p>Список – это не массив, его элементы не занимают непрерывную область памяти. 
  Инкремент итератора
</p>
<div class="lang-cpp"><![CDATA[++iter;]]></div>
<p>вовсе не сдвигает его на следующий элемент списка. Вместо этого он указывает 
  на место в памяти, непосредственно следующее за данным элементом, а там может 
  быть все что угодно. Для изменения значения итератора нужно воспользоваться 
  членом _next объекта ilist_item:
</p>
<div class="lang-cpp"><![CDATA[iter = iter->_next;]]></div>
<p>Мы инкапсулировали доступ к членам ilist_item набором встраиваемых функций. 
  Определение класса ilist_item теперь выглядит так:
</p>
<div class="lang-cpp"><![CDATA[class ilist_item {
public:
   ilist_item( int value, ilist_item *item_to_link_to = 0 );
   int value() { return _value; }
   iilst_item* next() { return _next; }
   void next( ilist_item *link ) { _next = link; }
   void value( int new_value ) { _value = new_value; }
private:
   int _value;
   ilist_item *_next;
};
]]></div>

<p>Вот определение функции display(), использующее последнюю реализацию класса ilist_item:
</p>

<div class="lang-cpp"><![CDATA[
#include <iostream>
class ilist {
public:
   void display( ostream &os = cout );
   // ...
};

void ilist::display(ostream &os) {
  os << "\n( " << _size << " )( ";
  ilist_item *ptr = _at_front;
  while ( ptr ) {
     os << ptr->value() << " ";
     ptr = ptr->next();
  }
  os << ")\n";
}
]]></div>

<p>Тестовую программу для нашего класса ilist в его текущей реализации можно представить 
  таким образом:
</p>
<div class="lang-cpp"><![CDATA[#include <iostream>
#include "ilist.h"
int main()
{
   ilist mylist;
   for ( int ix = 0; ix < 10; ++ix ) {
  mylist.insert_front( ix );
  mylist.insert_end( ix );
 }
    cout <<
   "Ok: после insert_front() и insert_end()\n";
     mylist.display();
   ilist_item *it = mylist.find( 8 );
   cout << "\n"
   << "Ищем значение 8: нашли?"
   << ( it ? " да!\n" : " нет!\n" );
   mylist.insert( it, 1024 );
   cout << "\n" <<
   "Вставка элемента 1024 после 8\n";
   mylist.display();
   int elem_cnt = mylist.remove( 8 );
   cout << "\n"
   << "Удалено " << elem_cnt
   << " элемент(ов) со значением 8\n";
   mylist.display();
   cout << "\n" << "Удален первый элемент\n";
   mylist.remove_front(); mylist.display();
   cout << "\n" << "Удалены все элементы\n";
   mylist.remove_all(); mylist.display();
}]]></div>
<p>Результат работы программы:
</p>
<div class="lang-cpp"><![CDATA[Ok: после insert_front() и insert_end()
(20)( 9 8 7 6 5 4 3 2 1 0 0 1 2 3 4 5 6 7 8 9 )

Ищем значение 8: нашли? да!
Вставка элемента 1024 после 8
( 21 )( 9 8 1024 7 6 5 4 3 2 1 0 0 1 2 3 4 5 6 7 8 9 )
Удалено 2 элемент(ов) со значением 8
( 19 )( 9 1024 7 6 5 4 3 2 1 0 0 1 2 3 4 5 6 7 9 )
Удален первый элемент
( 18 )( 1024 7 6 5 4 3 2 1 0 0 1 2 3 4 5 6 7 9 )
Удалены все элементы
( 0 )( )]]></div>
<p>Помимо вставки элементов, необходима возможность их удаления. Мы реализуем 
  три таких операции:
</p>

<div class="lang-cpp"><![CDATA[
void remove_front();
void remove_all ();
int remove( int value );
]]></div>

<p>Вот как выглядит реализация remove_front():
</p>

<div class="lang-cpp"><![CDATA[inline void
i1ist::remove_front() {
   if ( _at_front ) {
      ilist_item *ptr = _at_front;
      _at_front = _at_front->next();
      bump_down_size() ;

     delete ptr;
   }
}

// remove_all() вызывает remove_front() до тех пор, пока все элементы не будут удалены:
void ilist::remove_all() {
  while ( _at_front )
    remove_front();
 _size = 0;
  _at_front = _at_end = 0;
}
]]></div>

<p>Общая функция remove() также использует remove_front() для обработки специального 
  случая, когда удаляемый элемент (элементы) находится в начале списка. Для удаления 
  из середины списка используется итерация. У элемента, предшествующего удаляемому, 
  необходимо модифицировать указатель _next. Вот реализация функции:
</p>

<div class="lang-cpp"><![CDATA[
int ilist::remove( int value ) {
   ilist_item *plist = _at_front;
   int elem_cnt = 0;
   while ( plist && plist->value() == value) {
      plist = plist->next();
      remove_front();
      ++elem_cnt;
  }
if ( ! plist )
   return elem_cnt;
ilist_item *prev = plist;
plist = plist->next();
while ( plist ) {
   if ( plist->value() == value ) {
      prev->next( plist->next() );
      delete plist;
      ++elem_cnt;
      bump_down_size();
      plist = prev->next();
      if ( ! plist ) {
         _at_end = prev;
         return elem_cnt;
      }
   } else {
      prev = plist;
      plist = plist->next();
   }
   return elem_cnt;
}
]]></div>

<p>Следующая программа проверяет работу операций в четырех случаях: когда удаляемые 
  элементы расположены в конце списка, удаляются все элементы, таких элементов 
  нет или они находятся и в начале, и в конце списка.
</p>
<div class="lang-cpp"><![CDATA[
#include <iostream>
#include "ilist.h"
int main() {
   ilist mylist;
   cout << "\n-----------------------------------------------\n"
   << "тест #1: - элементы в конце\n"
   << "-----------------------------------------------\n";
   mylist.insert_front( 1 ); mylist.insert_front( 1 );
   mylist.insert_front( 1 );

   my1ist.insert_front( 2 ); mylist.insert_front( 3 );
   my1ist.insert_front( 4 );
   mylist.display();
   int elem_cnt = mylist.remove( 1 );
   cout << "\n" << "Удалено " << elem_cnt
   << " элемент(ов) со значением 1\n";
   mylist.display();
   mylist.remove_all();
   cout << "\n-----------------------------------------------\n"
   << "тест #2: - элементы в начале\n"
   << "-----------------------------------------------\n";
   mylist.insert_front( 1 ); mylist.insert_front( 1 );
   mylist.insert_front( 1 );
   mylist.display();
   elem_cnt = mylist.remove( 1 );
   cout << "\n" << "Удалено " << elem_cnt
   << " элемент(ов) со значением 1\n";
   mylist.display();
   mylist.remove_all () ;
   cout << "\n-----------------------------------------------\n"
   << "тест #3: - элементов нет в списке\n"
   << "-----------------------------------------------\n";
   mylist.insert_front( 0 ); mylist.insert_front( 2 );
   mylist.insert_front( 4 );
   mylist.display();
   elem_cnt = mylist.remove( 1 );
   cout << "\n" << "Удалено " << elem_cnt
   << " элемент(ов) со значением 1\n";
   mylist.display();
   mylist.remove_all () ;
   cout << "\n-----------------------------------------------\n"
   << "тест #4: - элементы в конце и в начале\n"
   << "-----------------------------------------------\n";
   my1ist.insert_front( 1 ); mylist.insert_front( 1 );
   my1ist.insert_front( 1 );
   my1ist.insert_front( 0 ); mylist.insert_front( 2 );
   my1ist.insert_front( 4 );
   mylist.insert_front( 1 ); my1ist.insert_front( 1 );
   mylist.insert_front( 1 );
   mylist.display() ;
   elem_cnt = mylist.remove( 1 );
   cout << "\n" << "Удалено " << elem_cnt
   << " элемент(ов) со значением 1\n";
   mylist.display();
}]]></div>
<p>Результат работы программы:
</p>
<div class="lang-cpp"><![CDATA[-----------------------------------------------
тест #1: - элементы в конце
-----------------------------------------------
( 6 )( 4 3 2 1 1 1 )
Удалено 3 элемент(ов) со значением 1
( 3 )( 4 3 2 )
-----------------------------------------------
тест #2: - элементы в начале
-----------------------------------------------
( 3 )( 1 1 1 )
Удалено 3 элемент(ов) со значением 1
( 0 )( )
-----------------------------------------------
тест #3: - элементов нет в списке
-----------------------------------------------
( 3 )( 4 2 0 )
Удалено 0 элемент(ов) со значением 1
( 3 )( 4 2 0 )
-----------------------------------------------
тест #4: - элементы в конце и в начале
-----------------------------------------------
(9 )( 1 1 1 4 2 0 1 1 1 )
Удалено 6 элемент(ов) со значением 1
( 3 )( 4 2 0 )]]></div>
<p>Последние две операции, которые мы хотим реализовать, – конкатенация двух списков 
  (добавление одного списка в конец другого) и инверсия (изменение порядка элементов 
  на противоположный). Первый вариант concat() содержит ошибку. Сможете ли вы 
  ее найти?
</p>
<div class="lang-cpp"><![CDATA[
void ilist::concat(const ilist& i1) {
   if ( ! _at_end )
   _at_front = i1._at_front;
   else _at_end->next( i1._at_front );
   _at_end = i1._at_end;
}
]]></div>

<p>Проблема состоит в том, что теперь два объекта ilist содержат последовательность 
  одних и тех же элементов. Изменение одного из списков, например вызов операций 
  insert() и remove(), отражается на другом, приводя его в рассогласованное состояние. 
  Простейший способ обойти эту проблему – скопировать каждый элемент второго списка. 
  Сделаем это при помощи функции insert_end():
</p>

<div class="lang-cpp"><![CDATA[
void ilist::concat(const ilist &i1) {
   i1ist_item *ptr = i1._at_front;
   while ( ptr ) {
      insert_end( ptr->value() );
      ptr = ptr->next();
   }
}]]></div>

<p>Вот реализация функции reverse():

</p>
<div class="lang-cpp"><![CDATA[void
   ilist::
   reverse()
   {
   ilist_item *ptr = _at_front;
   ilist_item *prev = 0;
   _at_front = _at_end;
   _at_end = ptr;
   while ( ptr != _at_front )
  {
      ilist_item *tmp = ptr->next();
      ptr->next( prev );
      prev = ptr;
      ptr = tmp;
   }
  _at_front->next( prev );
}

//Тестовая программа для проверки этих операций выглядит так:

#include <iostream>
#include "ilist.h"
int main() {
  ilist mylist;
  for ( int ix = 0; ix < 10; ++ix )
  { mylist.insert_front( ix ); }
   mylist.display();
   cout << "\n" << "инвертирование списка\n";
   mylist.reverse(); mylist.display();
   ilist mylist_too;
   mylist_too.insert_end(0); mylist_too.insert_end(1);
   mylist_too.insert_end(1); mylist_too.insert_end(2);
   mylist_too.insert_end(3); mylist_too.insert_end(5);
   cout << "\n" << "mylist_too:\n";
   mylist_too.display();
   mylist.concat( mylist_too );
   cout << "\n"
   << "mylist после concat с mylist_too:\n";
   mylist.disp1ay();
}
]]></div>

<p>Результат работы программы:
</p>

<div class="lang-cpp"><![CDATA[( 10 ) ( 9 8 7 6 5 4 3 2 1 0 )
инвертирование списка
( 10 ) ( 0 1 2 3 4 5 6 7 8 9 )
mylist_too:
( 6 )( 0 1 1 2 3 5 )
mylist после concat с mylist_too:

( 16 ) ( 0 1 2 3 4 5 6 7 8 9 0 1 1 2 3 5 )]]></div>

<p>С одной стороны, задачу можно считать выполненной: мы не только реализовали 
  все запланированные функции, но и проверили их работоспособность. С другой стороны, 
  мы не обеспечили всех операций, которые необходимы для практического использования 
  списка.
</p>

<p>Одним из главных недостатков является то, что у пользователя нет способа перебирать 
  элементы списка и он не может обойти это ограничение, поскольку реализация от 
  него скрыта. Другим недостатком является отсутствие поддержки операций инициализации 
  одного списка другим и присваивания одного списка другому. Мы сознательно не 
  стали их реализовывать в первой версии, но теперь начнем улучшать наш класс.
</p>

<p>Для реализации первой операции инициализации необходимо определить копирующий 
  конструктор. Поведение такого конструктора, построенного компилятором по умолчанию, 
  совершенно неправильно для нашего класса (как, собственно, и для любого класса, 
  содержащего указатель в качестве члена), именно поэтому мы с самого начала запретили 
  его использование. Лучше уж полностью лишить пользователя какой-либо операции, 
  чем допустить возможные ошибки. (В разделе 14.5 объясняется, 
  почему действия копирующего конструктора по умолчанию в подобных случаях неверны.) 
  Вот реализация конструктора, использующая функцию insert_end():
</p>

<div class="lang-cpp"><![CDATA[
ilist::ilist( const ilist &rhs) {
   ilist_item *pt = rhs._at_front;
   while ( pt ) {
      insert_end( pt->value() );
      pt = pt->next();
   }
}
]]></div>

<p>Оператор присваивания должен сначала вызвать remove_all(), а затем с помощью 
  insert_end() вставить все элементы второго списка. Поскольку эта операция повторяется 
  в обеих функциях, вынесем ее в отдельную функцию insert_all():
</p>

<div class="lang-cpp"><![CDATA[
void ilist::insert_all (const ilist &rhs) {
   ilist_item *pt = rhs._at_front;
   while ( pt ) {
      insert_end( pt->value() );
      pt = pt->next();
   }
}
]]></div>

<p>после чего копирующий конструктор и оператор присваивания можно реализовать так:
</p>

<div class="lang-cpp"><![CDATA[
inline ilist::ilist(const ilist& rhs)
   : _at_front( 0 ), _at_end( 0 )
   { insert_all ( rhs ); }
]]></div>

<div class="lang-cpp"><![CDATA[
inline ilist& ilist::operator=(const ilist &rhs) {
   remove_all();
   insert_all( rhs );
   return *this;
}
]]></div>

<p>Теперь осталось обеспечить пользователя возможностью путешествовать по списку, 
  например с помощью доступа к члену _at_front:
</p>

<p>ilist_item *ilist::front() { return _at_front(); } 

  После этого можно применить ilist_item::next(), как мы делали в функциях-членах:
</p>

<div class="lang-cpp"><![CDATA[
ilist_item *pt = mylist.front();
   while ( pt ) {
      do_something( pt->value() );
   pt = pt->next();
}
]]></div>

<p>Хотя это решает проблему, лучше поступить иначе: реализовать общую концепцию 
  прохода по элементам контейнера. В данном разделе мы расскажем об использовании 
  цикла такого вида:

  for ( ilist_item *iter = mylist.init_iter();

  iter;

  iter = mylist.next_iter() )

  do_something( iter->value() );
</p>

<p>Наш итератор представляет собой несколько больше, чем просто указатель. Он должен 
  уметь запоминать текущий элемент, возвращать следующий и определять, когда все 
  элементы кончились. По умолчанию итератор инициализируется значением _at_front, 
  однако пользователь может задать в качестве начального любой элемент списка. 
  next_iter() возвращает следующий элемент или 0, если элементов больше нет. Для 
  реализации пришлось ввести дополнительный член класса:
</p>

<div class="lang-cpp"><![CDATA[
class ilist {
public:
  // ...
  init_iter( ilist_item *it = 0 );
private: 
  //...
  ilist_item *_current;
};

// init_iter() выглядит так:

inline ilist_item* ilist::init_iter(i1ist_item *it) {
  return _current = it ? it : _at_front;
}
]]></div>

<p>next_iter() перемещает указатель _current на следующий элемент и возвращает 
  его адрес, если элементы не кончились. В противном случае он возвращает 0 и 
  устанавливает _current в 0. Его реализацию можно представить следующим образом:
</p>

<div class="lang-cpp"><![CDATA[
inline ilist_item* ilist::next_iter() {
   ilist_item *next = _current
    ? _current = _current->next()
    : _current;
    return next;
}
]]></div>

<p>Если элемент, на который указывает _current, удален, могут возникнуть проблемы. 
  Их преодолевают модификацией кода функций remove() и remove_front(): они должны 
  проверять значение _current. Если он указывает на удаляемый элемент, функции 
  изменят его так, чтобы он адресовал следующий элемент либо был равен 0, когда 
  удаляемый элемент – последний в списке или список стал пустым. Модифицированная 
  remove_front() выглядит так:
</p>

<div class="lang-cpp"><![CDATA[
inline void ilist::remove_front() {
   if ( _at_front ) {
   ilist_item *ptr = _at_front;
   _at_front = _at_front->next();
   // _current не должен указывать на удаленный элемент
   if ( _current == ptr )
      _current = _at_front;
      bump_down_size();
      delete ptr;
   }
}

  // Вот модифицированный фрагмент кода remove():

  while ( plist ) {
  if ( plist->value() == value ) {
  prev->next( plist->next() );
  if ( _current == plist )
  _current = prev->next();
]]></div>

<p>Что произойдет, если элемент будет вставлен перед тем, на который указывает 
  _current? Значение _current не изменяется. Пользователь должен начать проход 
  по списку с помощью вызова init_iter(), чтобы новый элемент попал в число перебираемых. 
  При инициализации списка другим и при присваивании значение _current не копируется, 
  а сбрасывается в 0.
</p>

<p>Тестовая программа для проверки работы копирующего конструктора и оператора 
  присваивания выглядит так::
</p>

<div class="lang-cpp"><![CDATA[
#include <iostream>
#include "ilist.h"
int main() {
   ilist mylist;
   for (int ix = 0; ix < 10; ++ix) {
      mylist.insert_front( ix );
      mylist.insert_end( ix );
   }
   cout << "\n" << "Применение init_iter() и next_iter()"
        << "для обхода всех элементов списка:\n";

   ilist_item *iter;
   for ( iter = mylist.init_iter();
      iter; iter = mylist.next_iter() )
   cout << iter->value() << " ";
   cout << "\n" << "Применение копирующего конструктора\n";
   ilist mylist2( mylist );
   mylist.remove_all();
   for ( iter = mylist2.init_iter();
     iter; iter = mylist2.next_iter() )
   cout << iter->value() << " ";
   cout << "\n" << "Применение копирующего оператора  присваивания\n";
   mylist = mylist2;
   for (iter = mylist.init_iter(); iter; iter = mylist.next_iter())
     cout << iter->value() << " ";
   cout << "\n";
}
]]></div>

<p>Результат работы программы:
</p>

<div class="lang-cpp"><![CDATA[
Применение init_iter() и next_iter() для обхода всех элементов списка:
9 8 7 6 5 4 3 2 1 0 0 1 2 3 4 5 6 7 8 9
Применение копирующего конструктора
9 8 7 6 5 4 3 2 1 0 0 1 2 3 4 5 6 7 8 9
Применение копирующего оператора присваивания
9 8 7 6 5 4 3 2 1 0 0 1 2 3 4 5 6 7 8 9
]]></div>

<h3>5.11.1. Обобщенный список</h3>

<p>Наш класс ilist имеет серьезный недостаток: он может хранить элементы только 
  целого типа. Если бы он мог содержать элементы любого типа – как встроенного, 
  так и определенного пользователем, – то его область применения была бы гораздо 
  шире. Модифицировать ilist для поддержки произвольных типов данных позволяет 
  механизм шаблонов (см. главу 16).
</p>

<p>При использовании шаблона вместо параметра подставляется реальный тип данных. 
  Например:
</p>

<div class="lang-cpp"><![CDATA[list< string > slist;]]></div>

<p>создает экземпляр списка, способного содержать объекты типа string, а
</p>

<div class="lang-cpp"><![CDATA[list< int > ilist;]]></div>
<p>создает список, в точности повторяющий наш ilist. С помощью шаблона класса 
  можно обеспечить поддержку произвольных типов данных одним экземпляром кода. 
  Рассмотрим последовательность действий, уделив особое внимание классу list_item.
</p>

<p>Определение шаблона класса начинается ключевым словом template, затем следует 
  список параметров в угловых скобках. Параметр представляет собой идентификатор, 
  перед которым стоит ключевое слово class или typename. Например:
</p>

<div class="lang-cpp"><![CDATA[template <class elemType>
class list_item;]]></div>

<p>Эта инструкция объявляет list_item шаблоном класса с единственным параметром-типом. 
  Следующее объявление эквивалентно предыдущему:
</p>

<div class="lang-cpp"><![CDATA[template <typename elemType>
class list_item;]]></div>

<p>Ключевые слова class и typename имеют одинаковое значение, можно использовать 
  любое из них. Более удобное для запоминания typename появилось в стандарте С++ 
  сравнительно недавно и поддерживается еще не всеми компиляторами. Поскольку 
  наши тексты были написаны до появления этого ключевого слова, в них употребляется 
  class. Шаблон класса list_item выглядит так:
</p>

<div class="lang-cpp"><![CDATA[
  template <class elemType>

  class list_item {

  public:

  list_item( elemType value, list_item *item = 0 )

  : _value( value ) {

  if ( !item )

  _next = 0;

  else {

  _next = item->_next;

  item->_next = this;

  }

  }
  elemType value() { return _value; }

  list_item* next() { return _next; }

 void next( list_item *link ) { _next = link; }

  void value( elemType new_value ) { _value = new_value; }
private:

  elemType _value;

  list_item *_next;

  };]]></div>

<p>Все упоминания типа int в определении класса ilist_item заменены на параметр 
  elemType. Когда мы пишем:
</p>

<div class="lang-cpp"><![CDATA[
  list_item<doub1e> *ptr = new list_item<doub1e>( 3.14 );
]]></div>

<p>компилятор подставляет double вместо elemType и создает экземпляр list_item, 
  поддерживающий данный тип.
</p>
<p>Аналогичным образом модифицируем класс ilist в шаблон класса list:
</p>

<div class="lang-cpp"><![CDATA[template <class elemType>
class list {
public:
  list() : _at_front( 0 ), _at_end( 0 ), _current( 0 ),

  _size( 0 ) {}

  1ist(const list&);

  list& operator=(const list&);

  ~list() { remove_all(); }
  void insert ( list_item<elemType> *ptr, elemType value );

  void insert_end( elemType value );

  void insert_front( elemType value );

  void insert_all( const list& rhs );
  int remove( elemType value );

  void remove_front();

  void remove_all();
  list_item<elemType> *find( elemType value );

  list_item<elemType> *next_iter();

  list_item<elemType>* init_iter( list_item<elemType> *it );
  void disp1ay( ostream &os = cout );
  void concat( const list&);

  void reverse ();

  int size() { return _size; }
private:

  void bump_up_size() { ++_size; }

  void bump_down_size() { --_size; }
  list_item<elemType> *_at_front;

  1ist_item<elemType> *_at_end;

  list_item<elemType> *_current;

  int _size;

  };
]]></div>

<p>Объекты шаблона класса list используются точно так же, как и объекты класса 
  ilist. Основное преимущество шаблона в том, что он обеспечивает поддержку произвольных 
  типов данных с помощью единственного определения.
</p>

<p>(Шаблоны являются важной составной частью концепции программирования на С++. 
  В главе 6 мы рассмотрим набор классов контейнерных типов, 
  предоставляемых стандартной библиотекой С++.
Неудивительно, что она содержит шаблон класса, реализующего операции со списками, равно как и шаблон класса, поддерживающего векторы)
</p>

<p>Наличие класса списка в стандартной библиотеке представляет некоторую проблему. 
  Мы выбрали для нашей реализации название list, но, к сожалению, стандартный 
  класс также носит это название. Теперь мы не можем использовать в программе 
  одновременно оба класса. Конечно, проблему решит переименование нашего шаблона, 
  однако во многих случаях эта возможность отсутствует.
</p>

<p>Более общее решение состоит в использовании механизма пространства имен, который 
  позволяет разработчику библиотеки заключить все свои имена в некоторое поименованное 
  пространство и таким образом избежать конфликта с именами из глобального пространства. 
  Применяя нотацию квалифицированного доступа, мы можем употреблять эти имена 
  в программах. Стандартная библиотека С++ помещает свои имена в пространство 
  std. Мы тоже поместим наш код в собственное пространство:
</p>

<div class="lang-cpp"><![CDATA[
namespace Primer_Third_Edition {
  template <typename elemType>
  class list_item{ ... };
  template <typename elemType>

  class list{ ... };
  // ...

  }
]]></div>


<p>Для использования такого класса в пользовательской программе необходимо написать 
  следующее:
</p>

<div class="lang-cpp"><![CDATA[
// наш заголовочный файл
#include "list.h"
// сделаем наши определения видимыми в программе

using namespace Primer_Third_Edition;
// теперь можно использовать наш класс list

list< int > ilist;

// ...
]]></div>

<h4>Упражнение 5.16</h4>

<p>Мы не определили деструктор для ilist_item, хотя класс содержит указатель на 
  динамическую область памяти. Причина заключается в том, что класс не выделяет 
  память для объекта, адресуемого указателем _next, и, следовательно, не несет 
  ответственности за ее освобождение. Начинающий программист мог бы допустить 
  ошибку, вызвав деструктор для ilist_item:
</p>

<div class="lang-cpp"><![CDATA[
  ilist_item::~ilist_item() {
      delete _next;
  }
]]></div>

<p>Посмотрите на функции remove_all() и remove_front() и объясните, почему наличие 
  такого деструктора является ошибочным.
</p>

<h4>Упражнение 5.17</h4>
<p>Наш класс ilist не поддерживает следующие операции:
</p>

<div class="lang-cpp"><![CDATA[
  void ilist::remove_end();
  void ilist::remove( ilist_item* );
]]></div>

<p>Как вы думаете, почему мы их не включили? Реализуйте их.</p>

<h4>Упражнение 5.18</h4>

<p>Модифицируйте функцию find() так, чтобы вторым параметром она принимала адрес 
  элемента, с которого нужно начинать поиск. Если этот параметр не задан, поиск 
  начинается с первого элемента. (Поскольку мы добавляем второй параметр, имеющий 
  значение по умолчанию, открытый интерфейс данной функции не меняется. Программы, 
  использующие предыдущую версию find(), будут работать без модификации.)
</p>

<div class="lang-cpp"><![CDATA[
class ilist {
public:
  // ...
  ilist_item* find( int value, ilist_item *start_at = 0 );
  // ...
};
]]></div>

<h4>Упражнение 5.19</h4>

<p>Используя новую версию find(), напишите функцию count(), которая подсчитывает 
  количество вхождений элементов с заданным значением. Подготовьте тестовую программу.
</p>

<h4>Упражнение 5.20</h4>

<p>Модифицируйте insert(int value) так, чтобы она возвращала указатель на вставленный объект ilist_item.
</p>

<h4>Упражнение 5.21</h4>

<p>Используя модифицированную версию insert(), напишите функцию:

  void ilist::insert( ilist_item *begin, int *array_of_value, int elem_cnt );

  где array_of_value указывает на массив значений, который нужно вставить в ilist, 
  elem_cnt – на размер этого массива, а begin – на элемент, после которого производится 
  вставка. Например, если есть ilist:
</p>

<p> (3)( 0 1 21 )
</p>

<p>и массив:

  int ia[] = { 1, 2, 3, 5, 8, 13 };

  вызов этой новой функции

  ilist_item *it = mylist.find( 1 );

  mylist.insert( it, ia, 6 );

  изменит список таким образом:
</p>

<p> (9) ( 0 1 1 2 3 5 8 13 21 )
</p>

<h4>Упражнение 5.22</h4>

<p>Функции concat() и reverse() модифицируют оригинальный список. Это не всегда 
  желательно. Напишите аналогичную пару функций, которые создают новый объект ilist:
</p>

<div class="lang-cpp"><![CDATA[
  ilist ilist::reverse_copy();
  // и
  ilist ilist::concat_copy( const ilist& rhs);
]]></div>

</section>
</chapter>
