<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="xhtml.xsl"?>

<chapter xmlns="http://www.example.com/postrisc"
 id="visibility_scope"
 description="Область видимости и время жизни"
>
<title>Область видимости и время жизни</title>

<preface>

<p>В этой главе обсуждаются два важных вопроса, касающиеся объявлений в С++. Где 
  употребляется объявленное имя? Когда можно безопасно использовать объект или 
  вызывать функцию, т.е. каково время жизни сущности в программе? Для ответа на 
  первый вопрос мы введем понятие областей видимости и покажем, как они ограничивают 
  применение имен в исходном файле программы. Мы рассмотрим разные типы таких 
  областей: глобальную и локальную, а также более сложное понятие областей видимости 
  пространств имен, которое появится в конце главы. Отвечая на второй вопрос, 
  мы опишем, как объявления вводят глобальные объекты и функции (сущности, <q>живущие</q> 
  в течение всего времени работы программы), локальные (<q>живущие</q> на определенном 
  отрезке выполнения) и динамически размещаемые объекты (временем жизни которых 
  управляет программист). Мы также исследуем свойства времени выполнения, характерные 
  для этих объектов и функций. 
</p>

</preface>

<section id="visibily_area">
<title>Область видимости</title>

<p>Каждое имя в С++ программе должно относиться к уникальной сущности (объекту, 
  функции, типу или шаблону). Это не значит, что оно встречается только один раз 
  во всей программе: его можно повторно использовать для обозначения другой сущности, 
  если только есть некоторый <em>контекст</em>, помогающий различить разные значения 
  одного и того же имени. Контекстом, служащим для такого различения, служит <em>область видимости</em>.
В С++ поддерживается три их типа: <em>локальная</em> область видимости,
область видимости <em>пространства имен</em> и область видимости <em>класса</em>.
</p>

<p>
  Локальная область – это часть исходного текста программы, содержащаяся в определении 
  функции (или в блоке). Любая функция имеет собственную такую часть, и каждая 
  составная инструкция (или блок) внутри функции также представляет собой отдельную 
  локальную область.
</p>

<p>
  Область видимости пространства имен – часть исходного текста программы, не содержащаяся 
  внутри объявления или определения функции или определения класса. Самая внешняя 
  часть называется глобальной областью видимости или глобальной областью видимости 
  пространства имен.
</p>

<p>Объекты, функции, типы и шаблоны могут быть определены в глобальной области видимости.
Программисту разрешено задать <em>пользовательские</em> пространства имен,
заключенные внутри глобальной области с помощью <em>определения пространства имен</em>.
Каждое такое пространство является отдельной областью видимости.
Пользовательское пространство, как и глобальное, может содержать объявления
и определения объектов, функций, типов и шаблонов, а также вложенные пользовательские пространства имен.
</p>

<p>Каждое определение класса представляет собой <em>отдельную область видимости класса</em>.
</p>

<p>
  Имя может обозначать различные сущности в зависимости от области видимости. 
  В следующем фрагменте программы имя s1 относится к четырем разным сущностям:
</p>

<div class="lang-cpp"><![CDATA[
#include <iostream>
#include <string>

// сравниваем s1 и s2 лексикографически
int lexicoCompare(const string& sl, const string& s2) { ... }

// сравниваем длины s1 и s2
int sizeCompare(const string& sl, const string& s2) { ... }

typedef int (PFI)(const string&, const string&);
// сортируем массив строк
void sort( string *s1, string *s2, PFI compare =lexicoCompare )
{ ... }

string sl[10] = { "a", "light", "drizzle", "was", "falling",
                  "when", "they", "left", "the", "school" };

int main() {
    // вызов sort() со значением по умолчанию параметра compare
    // s1 - глобальный массив
    sort( s1, s1 + sizeof(s1)/sizeof(s1[0]) - 1 );

    // выводим результат сортировки
    for ( int i = 0; i < sizeof(s1) / sizeof(s1[0]); ++i )
         cout << s1[ i ].c_str() << "\n\t";
}
]]></div>

<p>Поскольку определения функций lexicoCompare(), sizeCompare() и sort() представляют 
  собой различные области видимости и все они отличны от глобальной, в каждой 
  из этих областей можно завести переменную с именем s1.
</p>
<p>
  Имя, введенное с помощью объявления, можно использовать от точки объявления 
  до конца области видимости (включая вложенные области). Так, имя s1 параметра 
  функции lexicoCompare() разрешается употреблять до конца ее области видимости, 
  то есть до конца ее определения.
</p>

<p>
  Имя глобального массива s1 видимо с точки его объявления до конца исходного 
  файла, включая вложенные области, такие, как определение функции main().
</p>
<p>
  В общем случае имя должно обозначать одну сущность внутри одной области видимости. 
  Если в предыдущем примере после объявления массива s1 добавить следующую строку, 
  компилятор выдаст сообщение об ошибке:
</p>

<div class="lang-cpp"><![CDATA[void s1(); // ошибка: повторное объявление s1]]></div>

<p>Перегруженные функции являются исключением из правила: можно завести несколько
  одноименных функций в одной области видимости, если они отличаются списком параметров.
</p>

<p>
  В С++ имя должно быть объявлено до момента его первого использования в выражении. 
  В противном случае компилятор выдаст сообщение об ошибке. Процесс сопоставления 
  имени, используемого в выражении, с его объявлением называется разрешением. 
  С помощью этого процесса имя получает конкретный смысл. Разрешение имени зависит 
  от способа его употребления и от его области видимости. Мы рассмотрим этот процесс 
  в различных контекстах. (В следующем подразделе описывается разрешение имен 
  в локальной области видимости)
</p>
<p>
  Области видимости и разрешение имен – понятия времени компиляции. Они применимы 
  к отдельным частям текста программы. Компилятор интерпретирует текст программы 
  согласно правилам областей видимости и правилам разрешения имен.
</p>

<h3>8.1.1. Локальная область видимости</h3>

<p>Локальная область видимости – это часть исходного текста программы, содержащаяся 
  в определении функции (или блоке внутри тела функции). Все функции имеют свои 
  локальные области видимости. Каждая составная инструкция (или блок) внутри функции 
  также представляет собой отдельную локальную область. Такие области могут быть 
  вложенными. Например, следующее определение функции содержит два их уровня (функция 
  выполняет двоичный поиск в отсортированном векторе целых чисел):
</p>

<div class="lang-cpp"><![CDATA[
const int notFound = -1; // глобальная область видимости
int binSearch( const vector<int> &vec, int val) {
 // локальная область видимости: уровень #1
    int low = 0;
    int high = vec.size() - 1;
    while ( low <= high )
    { // локальная область видимости: уровень #2
        int mid = ( low + high ) / 2;
        if ( val < vec[ mid ] )
            high = mid - 1;
        else low = mid + 1;
    }
    return notFound; // локальная область видимости: уровень #1
}]]></div>

<p>Первая локальная область видимости – тело функции binSearch(). В ней объявлены 
  параметры функции vec и val, а также переменные low и high. Цикл while внутри 
  функции задает вложенную локальную область, в которой определена одна переменная 
  mid. Параметры vec и val и переменные low и high видны во вложенной области. 
  Глобальная область видимости включает в себя обе локальных. В ней определена 
  одна целая константа notFound.
</p>
<p>
  Имена параметров функции vec и val принадлежат к первой локальной области видимости 
  тела функции, и в ней использовать те же имена для других сущностей нельзя. 
  Например:
</p>

<div class="lang-cpp"><![CDATA[
int binSearch(const vector<int>& vec, int val) {
    // локальная область видимости: уровень #1
    int val; // ошибка: неверное переопределение val
    // ...
]]></div>

<p>Имена параметров употребляются как внутри тела функции binSearch(), так и внутри 
  вложенной области видимости цикла while. Параметры vec и val недоступны вне 
  тела функции binSearch().
</p>
<p>
  Разрешение имени в локальной области видимости происходит следующим образом: 
  просматривается та область, где оно встретилось. Если объявление найдено, имя 
  разрешено. Если нет, просматривается область видимости, включающая текущую. 
  Этот процесс продолжается до тех пор, пока объявление не будет найдено либо 
  не будет достигнута глобальная область видимости. Если и там имени нет, оно 
  будет считаться ошибочным.
</p>
<p>
  Из-за порядка просмотра областей видимости в процессе разрешения имен объявление 
  из внешней области может быть скрыто объявлением того же имени во вложенной 
  области. Если бы в предыдущем примере переменная low была объявлена в глобальной 
  области видимости перед определением функции binSearch(), то использование low 
  в локальной области видимости цикла while все равно относилось бы к локальному 
  объявлению, скрывающему глобальное:
</p>

<div class="lang-cpp"><![CDATA[
int low;
int binSearch( const vector<int>& vec, int val) {
    // локальное объявление low
    // скрывает глобальное объявление
    int low = 0;
    // ...
    // low - локальная переменная
    while ( low <= high ) {
         //...
    }
    // ...
}
]]></div>

<p>Для некоторых инструкций языка C++ разрешено объявлять переменные внутри управляющей 
  части. Например, в цикле for переменную можно определить внутри инструкции инициализации:
</p>

<div class="lang-cpp"><![CDATA[
for ( int index = 0; index < vecSize; ++index ) {
   // переменная index видна только здесь
   if ( vec[ index ] == someValue )
     break;
}
// ошибка: переменная index не видна
if ( index != vecSize ) // элемент найден
]]></div>

<p>Подобные переменные видны только в локальной области самого цикла for и вложенных 
  в него (это верно для стандарта С++, в предыдущих версиях языка поведение было 
  иным). Компилятор рассматривает это объявление так же, как если бы оно было 
  записано в виде:
</p>

<div class="lang-cpp"><![CDATA[
// представление компилятора
{ // невидимый блок
   int index = 0;
   for ( ; index < vecSize; ++index ) {
     // ...
   }
}]]></div>
<p>Тем самым программисту запрещается применять управляющую переменную вне локальной 
  области видимости цикла. Если нужно проверить index, чтобы определить, было 
  ли найдено значение, то данный фрагмент кода следует переписать так:
</p>
<div class="lang-cpp"><![CDATA[
int index = 0;
for ( ; index < vecSize; ++index) {
   // ...
}
// правильно: переменная index видна
if ( index != vecSize ) // элемент найден]]></div>
<p>Поскольку переменная, объявленная в инструкции инициализации цикла for, является 
  локальной для цикла, то же самое имя допустимо использовать аналогичным образом 
  и в других циклах, расположенных в данной локальной области видимости:
</p>
<div class="lang-cpp"><![CDATA[
void fooBar(int *ia, int sz) {
   for (int i=0; i < sz; ++i) ... // правильно
   for (int i=0; i < sz; ++i) ... // правильно, другое i
   for (int i=0; i < sz; ++i) ... // правильно, другое i
}
]]></div>

<p>Аналогично переменная может быть объявлена внутри условия инструкций if и switch, 
  а также внутри условия циклов while и for. Например:
</p>
<div class="lang-cpp"><![CDATA[
if (int *pi = getValue()) {
   // pi != 0 -- *pi можно использовать здесь
   int result = calc(*pi);
   // ...
} else {
   // здесь pi тоже видна
   // pi == 0
   cout << "ошибка: getValue() завершилась неудачно" << endl;
}
]]></div>

<p>Переменные, определенные в условии инструкции if, как переменная pi, видны 
  только внутри if и соответствующей части else, а также во вложенных областях. 
  Значением условия является значение этой переменной, которое она получает в 
  результате инициализации. Если pi равна 0 (нулевой указатель), условие ложно 
  и выполняется ветвь else. Если pi инициализируется любым другим значением, условие 
  истинно и выполняется ветвь if.
</p>

<p>Упражнение 8.1:
Найдите различные области видимости в следующем примере. Какие объявления ошибочны и почему?
</p>

<div class="lang-cpp"><![CDATA[
int ix = 1024;
int ix();

void func( int ix, int iy ) {
  int ix = 255;
  if (int ix=0) {
    int ix = 79;
    {
      int ix = 89;
    }
  } else {
    int ix = 99;
  }
}
]]></div>

<p>Упражнение 8.2:
К каким объявлениям относятся различные использования переменных ix и iy в следующем примере:
</p>

<div class="lang-cpp"><![CDATA[
int ix = 1024;

void func( int ix, int iy ) {
  ix = 100;
  for( int iy = 0; iy < 400; iy += 100 ) {
    iy += 100;
    ix = 300;
  }
  iy = 400;
}
]]></div>

</section>

<section id="globals">
<title>Глобальные объекты и функции</title>

<p>Объявление функции в глобальной области видимости вводит <em>глобальную функцию</em>, 
  а объявление переменной – <em>глобальный объект</em>. Глобальный объект существует 
  на протяжении всего времени выполнения программы. <em>Время жизни</em> глобального 
  объекта начинается с момента запуска программы и заканчивается с ее завершением.
</p>
<p>
  Для того чтобы глобальную функцию можно было вызвать или взять ее адрес, она 
  должна иметь определение. Любой глобальный объект, используемый в программе, 
  должен быть определен, причем только один раз. Встроенные функции могут определяться 
  несколько раз, если только все определения совпадают. Такое требование единственности 
  или точного совпадения получило название правила одного определения (ПОО). В 
  этом разделе мы покажем, как следует вводить глобальные объекты и функции в 
  программе, чтобы ПОО соблюдалось.
</p>

<h3>8.2.1. Объявления и определения</h3>

<p>Как было сказано в главе 7, объявление функции устанавливает ее имя, а также 
  тип возвращаемого значения и список параметров. Определение функции, помимо 
  этой информации, задает еще и тело – набор инструкций, заключенных в фигурные 
  скобки. Функция должна быть объявлена перед вызовом. Например:
</p>

<div class="lang-cpp"><![CDATA[
// объявление функции calc()
// определение находится в другом файле
void calc(int);
int main() {
    int loc1 = get(); // ошибка: get() не объявлена
    calc(loc1);       // правильно: calc() объявлена
    // ...
}
]]></div>

<p>Определение объекта имеет две формы:
</p>

<div class="lang-cpp"><![CDATA[
type_specifier object_name;
type_specifier object_name = initializer;
]]></div>

<p>Вот, например, определение obj1. Здесь obj1 инициализируется значением 97:
</p>
<p>int obj1 = 97;</p>

<p>Следующая инструкция задает obj2, хотя начальное значение не задано:</p>
<p>
  </p>
<p>
  int obj2;</p>
<p>
  </p>
<p>
  Объект, определенный в глобальной области видимости без явной инициализации, 
  гарантированно получит нулевое значение. Таким образом, в следующих двух примерах 
  и var1, и var2 будут равны нулю:</p>

<div class="lang-cpp"><![CDATA[int var1 = 0;
int var2;]]></div>

<p>Глобальный объект можно определить в программе только один раз. Поскольку он 
  должен быть объявлен в исходном файле перед использованием, то для программы, 
  состоящей из нескольких файлов, необходима возможность объявить объект, не определяя 
  его. Как это сделать?
</p>
<p>
  С помощью ключевого слова extern, аналогичного объявлению функции: оно указывает, 
  что объект определен в другом месте – в этом же исходном файле или в другом. 
  Например:
</p>

<div class="lang-cpp"><![CDATA[extern int i;]]></div>

<p>Эта инструкция <q>обещает</q>, что в программе имеется определение, подобное</p>

<div class="lang-cpp"><![CDATA[int i;]]></div>

<p>extern-объявление не выделяет места под объект. Оно может встретиться несколько 
  раз в одном и том же исходном файле или в разных файлах одной программы. Однако 
  обычно находится в общедоступном заголовочном файле, который включается в те 
  модули, где необходимо использовать глобальный объект:
</p>

<div class="lang-cpp"><![CDATA[
// заголовочный файл
extern int obj1;
extern int obj2;
// исходный файл
int obj1 = 97;
int obj2;
]]></div>

<p>Объявление глобального объекта с указанием ключевого слова extern и с явной 
  инициализацией считается определением. Под этот объект выделяется память, и 
  другие определения не допускаются:
</p>

<div class="lang-cpp"><![CDATA[
extern const double pi = 3.1416; // определение
const double pi; // ошибка: повторное определение pi
]]></div>

<p>Ключевое слово extern может быть указано и при объявлении функции – для явного 
обозначения его подразумеваемого смысла: <q>определено в другом месте</q>.
Например:
</p>

<div class="lang-cpp"><![CDATA[extern void putValues( int*, int );]]></div>

<h3>8.2.2. Сопоставление объявлений в разных файлах</h3>

<p>Одна из проблем, вытекающих из возможности объявлять объект или функцию в разных 
  файлах, – вероятность несоответствия объявлений или их расхождения в связи с 
  модификацией программы. В С++ имеются средства, помогающие обнаружить такие 
  различия.
</p>
<p>
  Предположим, что в файле token.C функция addToken() определена как имеющая один 
  параметр типа unsigned char. В файле lex.C, где эта функция вызывается, в ее 
  определении указан параметр типа char.
</p>

<div class="lang-cpp"><![CDATA[// ---- в файле token.C ----
int addToken( unsigned char tok ) { /* ... */ }

// ---- в файле lex.C ----
extern int addToken( char );]]></div>
<p>Вызов addToken() в файле lex.C вызывает ошибку во время связывания программы. 
  Если бы такое связывание прошло успешно, можно представить дальнейшее развитие 
  событий: скомпилированная программа была протестирована на рабочей станции Sun 
  Sparc, а затем перенесена на IBM 390. Первый же запуск потерпел неудачу: даже 
  самые простые тесты не проходили. Что случилось?
</p>
<p>Вот часть объявлений набора лексем:
</p>

<div class="lang-cpp"><![CDATA[
const unsigned char INLINE = 128;
const unsigned char VIRTUAL = 129;
]]></div>

<p>Вызов addToken() выглядит так:
</p>

<div class="lang-cpp"><![CDATA[curTok = INLINE;
// ...
addToken( curTok );]]></div>
<p>Тип char реализован как знаковый в одном случае и как беззнаковый в другом. 
  Неверное объявление addToken() приводит к переполнению на той машине, где тип 
  char является знаковым, всякий раз, когда используется лексема со значением 
  больше 127. Если бы такой программный код компилировался и связывался без ошибки, 
  во время выполнения могли обнаружиться серьезные последствия.
</p>
<p>
  В С++ информация о количестве и типах параметров функций помещается в имя функции 
  – это называется безопасным связыванием (type-safe linkage). Оно помогает обнаружить 
  расхождения в объявлениях функций в разных файлах. Поскольку типы параметров 
  unsigned char и char различны, в соответствии с принципом безопасного связывания 
  функция addToken(), объявленная в файле lex.C, будет считаться неизвестной. 
  Согласно стандарту определение в файле token.C задает другую функцию.
</p>
<p>Подобный механизм обеспечивает некоторую степень проверки типов при вызове функций из разных файлов.
Безопасное связывание также необходимо для поддержки перегруженных функций.
</p>
<p>
  Прочие типы несоответствия объявлений одного и того же объекта или функции в 
  разных файлах не обнаруживаются во время компиляции или связывания. Поскольку 
  компилятор обрабатывает отдельно каждый файл, он не способен сравнить типы в 
  разных файлах. Несоответствия могут быть источником серьезных ошибок, проявляющихся, 
  подобно приведенным ниже, только во время выполнения программы (к примеру, путем 
  возбуждения исключения или из-за вывода неправильной информации).
</p>

<div class="lang-cpp"><![CDATA[// в token. C
unsigned char lastTok = 0;
unsigned char peekTok() { /* ... */ }

// в lex.C
extern char lastTok;
extern char peekTok();]]></div>
<p>Избежать подобных неточностей поможет прежде всего правильное использование 
  заголовочных файлов. Мы поговорим об этом в следующем подразделе.
</p>

<h3>8.2.3. Несколько слов о заголовочных файлах</h3>

<p>Заголовочный файл предоставляет место для всех extern-объявлений объектов, 
  объявлений функций и определений встроенных функций. Это называется локализацией 
  объявлений. Те исходные файлы, где объект или функция определяется или используется, 
  должны <em>включать </em>заголовочный файл.
</p>
<p>
  Такие файлы позволяют добиться двух целей. Во-первых, гарантируется, что все 
  исходные файлы содержат одно и то же объявление для глобального объекта или 
  функции. Во-вторых, при необходимости изменить объявление это изменение делается 
  в одном месте, что исключает возможность забыть внести правку в какой-то из 
  исходных файлов.
</p>
<p>
  Пример с addToken() имеет следующий заголовочный файл:
</p>

<div class="lang-cpp"><![CDATA[
// ----- token.h -----
typedef unsigned char uchar;
const uchar INLINE = 128;
// ...
const uchar IT = ...;
const uchar GT = ...;

extern uchar lastTok;
extern int addToken( uchar );
inline bool is_relational( uchar tok )
{ return (tok >= LT && tok <= GT); }

// ----- lex.C -----
#include "token.h"
// ...

// ----- token.C -----
#include "token.h"
// ...
]]></div>

<p>При проектировании заголовочных файлов нужно учитывать несколько моментов. 
  Все объявления такого файла должны быть логически связанными. Если он слишком 
  велик или содержит слишком много не связанных друг с другом элементов, программисты 
  не станут включать его, экономя на времени компиляции. Для уменьшения временных 
  затрат в некоторых реализациях С++ предусматривается использование предкомпилированных 
  заголовочных файлов. В руководстве к компилятору сказано, как создать такой 
  файл из обычного. Если в вашей программе используются большие заголовочные файлы, 
  применение предкомпиляции может значительно сократить время обработки.
</p>
<p>
  Чтобы это стало возможным, заголовочный файл не должен содержать объявлений 
  встроенных (inline) функций и объектов. Любая из следующих инструкций является 
  определением и, следовательно, не может быть использована в заголовочном файле:
</p>

<div class="lang-cpp"><![CDATA[extern int ival = 10;
double fica_rate;
extern void dummy () {}]]></div>

<p>Хотя переменная i объявлена с ключевым словом extern, явная инициализация превращает 
  ее объявление в определение. Точно так же и функция dummy(), несмотря на явное 
  объявление как extern, определяется здесь же: пустые фигурные скобки содержат 
  ее тело. Переменная fica_rate определяется и без явной инициализации: об этом 
  говорит отсутствие ключевого слова extern. Включение такого заголовочного файла 
  в два или более исходных файла одной программы вызовет ошибку связывания – повторные 
  определения объектов.
</p>
<p>
  В файле token.h, приведенном выше, константа INLINE и встроенная функция is_relational() 
  кажутся нарушающими правило. Однако это не так.
</p>
<p>
  Определения символических констант и встроенных функций являются специальными 
  видами определений: те и другие могут появиться в программе несколько раз.
</p>
<p>
  При возможности компилятор заменяет имя символической константы ее значением. 
  Этот процесс называют подстановкой константы. Например, компилятор подставит 
  128 вместо INLINE везде, где это имя встретится в исходном файле. Для того чтобы 
  компилятор произвел такую замену, определение константы (значение, которым она 
  инициализирована) должно быть видимо в том месте, где она используется. Определение 
  символической константы может появиться несколько раз в разных файлах, потому 
  что в результирующем исполняемом файле благодаря подстановке оно будет только 
  одно.
</p>
<p>
  В некоторых случаях, однако, такая подстановка невозможна. Тогда лучше вынести 
  инициализацию константы в отдельный исходный файл. Это делается с помощью явного 
  объявления константы как extern. Например:
</p>

<div class="lang-cpp"><![CDATA[
// ----- заголовочный файл -----
const int buf_chunk = 1024;
extern char *const bufp;

// ----- исходный файл -----
char *const bufp = new char[buf_chunk];
]]></div>

<p>Хотя bufp объявлена как const, ее значение не может быть вычислено во время 
  компиляции (она инициализируется с помощью оператора new, который требует вызова 
  библиотечной функции). Такая конструкция в заголовочном файле означала бы, что 
  константа определяется каждый раз, когда этот заголовочный файл включается. 
  Символическая константа – это любой объект, объявленный со спецификатором const. 
  Можете ли вы сказать, почему следующее объявление, помещенное в заголовочный 
  файл, вызывает ошибку связывания, если такой файл включается в два различных 
  исходных?
</p>

<div class="lang-cpp"><![CDATA[
// ошибка: не должно быть в заголовочном файле
const char* msg = "?? oops: error: ";
]]></div>

<p>Проблема вызвана тем, что msg не константа.
Это неконстантный указатель, адресующий константу.
Правильное объявление выглядит так:
</p>

<div class="lang-cpp"><![CDATA[const char *const msg = "?? oops: error: ";]]></div>

<p>Такое определение может появиться в разных файлах.
</p>
<p>
  Схожая ситуация наблюдается и со встроенными функциями. Для того чтобы компилятор 
  мог подставить тело функции <q>по месту</q>, он должен видеть ее определение.
</p>

<p>Следовательно, встроенная функция, необходимая в нескольких исходных файлах, должна быть определена в заголовочном файле.
Однако спецификация inline – только <q>совет</q> компилятору.
Будет ли функция встроенной везде или только в данном конкретном месте, зависит от множества обстоятельств.
Если компилятор пренебрегает спецификацией inline, он генерирует определение функции в исполняемом файле.
Если такое определение появится в данном файле больше одного раза, это будет означать ненужную трату памяти.
</p>

<p>
  Большинство компиляторов выдают предупреждение в любом из следующих случаев 
  (обычно это требует включения режима выдачи предупреждений):
</p>

<ul>
  <li>само определение функции не позволяет встроить ее. Например, она слишком 
    сложна. В таком случае попробуйте переписать функцию или уберите спецификацию 
    inline и поместите определение функции в исходный файл;</li>
  <li> конкретный вызов функции может не быть <q>подставлен по месту</q>.
    В такой ситуации выражение следует переписать, разделив вызовы встроенных функций.</li>
</ul>
<p>Перед тем как употребить спецификацию inline, изучите поведение функции во 
  время выполнения. Убедитесь, что ее действительно можно встроить. Мы не рекомендуем 
  объявлять функции встроенными и помещать их определения в заголовочный файл, 
  если они не могут быть таковыми по своей природе.
</p>

<p>Упражнение 8.3:
Какие из приведенных ниже инструкций являются объявлениями, а какие определениями, и почему:
</p>

<div class="lang-cpp"><![CDATA[
extern int ix = 1024;
int iy;
extern void reset( void *p ) { /* ... */ }
extern const int *pi;
void print(const matrix&);
]]></div>

<p>Упражнение 8.4:
Какие из приведенных ниже объявлений и определений вы поместили бы в заголовочный файл?
В исходный файл? Почему?
</p>

<div class="lang-cpp"><![CDATA[
(a) int var;
(b) inline bool is_equal( const SmallInt&, const SmallInt&) { }
(c) void putValues( int *arr, int size );
(d) const double pi = 3.1416;
(e) extern int total = 255;
]]></div>

</section>

<section id="locals">
<title>Локальные объекты</title>

<p>Объявление переменной в локальной области видимости вводит локальный объект. 
  Существует три вида таких объектов: <em>автоматические</em>, <em>регистровые 
  </em>и <em>статические</em>, различающиеся временем жизни и характеристиками 
  занимаемой памяти. Автоматический объект существует с момента активизации функции, 
  в которой он определен, до выхода из нее. Регистровый объект – это автоматический 
  объект, для которого поддерживается быстрое считывание и запись его значения. 
  Локальный статический объект располагается в области памяти, существующей на 
  протяжении всего времени выполнения программы. В этом разделе мы рассмотрим 
  свойства всех этих объектов. 
</p>

<h3>8.3.1. Автоматические объекты</h3>

<p>Автоматический объект размещается в памяти во время вызова функции, в которой 
  он определен. Память для него отводится из программного стека в записи активации 
  функции. Говорят, что такие объекты имеют <em>автоматическую продолжительность 
  хранения</em>, или <em>автоматическую протяженность</em>. Неинициализированный 
  автоматический объект содержит случайное, или неопределенное, значение, оставшееся 
  от предыдущего использования области памяти. После завершения функции ее запись 
  активации выталкивается из программного стека, т.е. память, ассоциированная 
  с локальным объектом, освобождается. Время жизни такого объекта заканчивается 
  с завершением работы функции, и его значение теряется.
</p>
<p>
  Поскольку память, отведенная локальному объекту, освобождается при завершении 
  работы функции, адрес автоматического объекта следует использовать с осторожностью. 
  Например, этот адрес не может быть возвращаемым значением, так как после выполнения 
  функции будет относиться к несуществующему объекту:
</p>

<div class="lang-cpp"><![CDATA[
#include "Matrix.h"
Matrix* trouble( Matrix *pm ) {
    Matrix res;
    // какие-то действия
    // результат присвоим res
    return &res; // плохо!
}
int main() {
    Matrix m1;
    // ...
    Matrix *mainResult = trouble(&m1);
    // ...
}
]]></div>

<p>mainResult получает значение адреса автоматического объекта res. К несчастью, 
  память, отведенная под res, освобождается по завершении функции trouble(). После 
  возврата в main() mainResult указывает на область памяти, не отведенную никакому 
  объекту. (В данном примере эта область все еще может содержать правильное значение, 
  поскольку мы не вызывали других функций после trouble() и запись ее активации, 
  вероятно, еще не затерта.) Подобные ошибки обнаружить весьма трудно. Дальнейшее 
  использование mainResult в программе скорее всего даст неверные результаты.
</p>
<p>
  Передача в функцию trouble() адреса m1 автоматического объекта функции main() 
  безопасна. Память, отведенная main(), во время вызова trouble()находится в стеке, 
  так что m1 остается доступной внутри trouble().
</p>
<p>
  Если адрес автоматического объекта сохраняется в указателе, время жизни которого 
  больше, чем самого объекта, такой указатель называют <em>висячим</em>. Работа 
  с ним – это серьезная ошибка, поскольку содержимое адресуемой области памяти 
  непредсказуемо. Если комбинация бит по этому адресу оказывается в какой-то степени 
  допустимой (не приводит к нарушению защиты памяти), то программа будет выполняться, 
  но результаты ее будут неправильными.
</p>

<h3>8.3.2. Регистровые автоматические объекты</h3>

<p>Автоматические объекты, интенсивно используемые в функции, можно объявить с 
  ключевым словом register, тогда компилятор будет их загружать в машинные регистры. 
  Если же это невозможно, объекты останутся в основной памяти. Индексы массивов 
  и указатели, встречающиеся в циклах, – хорошие кандидаты в регистровые объекты.
</p>

<div class="lang-cpp"><![CDATA[for ( register int ix =0; ix < sz; ++-ix ) // ...
for ( register int *p = array ; p < arraySize; ++p ) // ...]]></div>

<p>Параметры также можно объявлять как регистровые переменные:
</p>

<div class="lang-cpp"><![CDATA[
bool find( register int *pm, int Val ) {
   while ( *pm )
     if ( *pm++ == Val ) return true;
   return false;
}
]]></div>

<p>Их активное использование может заметно увеличить скорость выполнения функции.
</p>
<p>
  Указание ключевого слова register – только подсказка компилятору. Некоторые 
  компиляторы игнорируют такой запрос, применяя специальные алгоритмы для определения 
  наиболее подходящих кандидатов на размещение в свободных регистрах.
</p>
<p>
  Поскольку компилятор учитывает архитектуру машины, на которой будет выполняться 
  программа, он зачастую может принять более обоснованное решение об использовании 
  машинных регистров.
</p>

<h3>8.3.3. Статические локальные объекты</h3>

<p>Внутри функции или составной инструкции можно объявить объект с локальной областью 
  видимости, который, однако, будет существовать в течение всего времени выполнения 
  программы. Если значение локального объекта должно сохраняться между вызовами 
  функции, то обычный автоматический объект не подойдет: ведь его значение теряется 
  каждый раз после выхода.
</p>
<p>
  В таком случае локальный объект необходимо объявить как static (со статической 
  продолжительностью хранения). Хотя значение такого объекта сохраняется между 
  вызовами функции, в которой он определен, видимость его имени ограничена локальной 
  областью. Статический локальный объект инициализируется во время первого выполнения 
  инструкции, где он объявлен. Вот, например, версия функции gcd(),устанавливающая 
  глубину рекурсии с его помощью:
</p>

<div class="lang-cpp"><![CDATA[#include <iostream&gt;
int traceGcd( int vl, int v2 )
{
    static int depth = 1;
    cout << "глубина #" << depth++ << endl;
    if ( v2 == 0 ) {
        depth = 1;
        return vl;
    }
    return traceGcd( v2, vl%v2 );
}]]></div>
<p>Значение, ассоциированное со статическим локальным объектом depth, сохраняется 
  между вызовами traceGcd(). Его инициализация выполняется только один раз – когда 
  к этой функции обращаются впервые. В следующей программе используется traceGcd():
</p>
<div class="lang-cpp"><![CDATA[#include <iostream&gt;
extern int traceGcd(int, int);

int main() {
  int rslt = traceCcd( 15, 123 );
  cout << "НОД (15,123): " << rslt << endl;
  return 0;
}]]></div>
<p>Результат работы программы:
</p>
<div class="lang-cpp"><![CDATA[глубина #1
глубина #2
глубина #3
глубина #4
НОД (15,123): 3]]></div>
<p>Неинициализированные статические локальные объекты получают значение 0. А автоматические 
  объекты в подобной ситуации получают случайные значения. Следующая программа 
  иллюстрирует разницу инициализации по умолчанию для автоматических и статических 
  объектов и опасность, подстерегающую программиста в случае ее отсутствия для 
  автоматических объектов.
</p>
<div class="lang-cpp"><![CDATA[
#include <iostream>

const int iterations = 2;
void func() {
    int value1, value2; // не инициализированы
    static int depth;   // неявно инициализирован нулем

    if ( depth < iterations )
        { ++depth; func(); }
    else depth = 0;
    cout << "\nvaluel:\t" << value1;
    cout << "\tvalue2:\t" << value2;
    cout << "\tsum:\t" << value1 + value2;
}
int main() {
    for ( int ix = 0; ix < iterations; ++ix ) func();
    return 0;
}
]]></div>

<p>Вот результат работы программы:</p>

<div class="lang-cpp"><![CDATA[
	valuel:  0           value2:  74924      sum:  74924
	valuel:  0           value2:  68748      sum:  68748
	valuel:  0           value2:  68756      sum:  68756
	valuel:  148620      value2:  2350       sum:  150970
	valuel:  2147479844  value2:  671088640  sum:  -1476398812
	valuel:  0           value2:  68756      sum:  68756
]]></div>

<p>value1 и value2 – неинициализированные автоматические объекты. Их начальные 
  значения, как можно видеть из приведенной распечатки, оказываются случайными, 
  и потому результаты сложения непредсказуемы. Объект depth, несмотря на отсутствие 
  явной инициализации, гарантированно получает значение 0, и функция func() рекурсивно 
  вызывает сама себя только дважды.
</p>

</section>

<section id="dynamics">
<title>Динамически размещаемые объекты</title>

<p>Время жизни глобальных и локальных объектов четко определено. Программист неспособен 
  хоть как-то изменить его. Однако иногда необходимо иметь объекты, временем жизни 
  которых можно управлять. Выделение памяти под них и ее освобождение зависят 
  от действий выполняющейся программы. Например, можно отвести память под текст 
  сообщения об ошибке только в том случае, если ошибка действительно имела место. 
  Если программа выдает несколько таких сообщений, размер выделяемой строки будет 
  разным в зависимости от длины текста, т.е. подчиняется типу ошибки, произошедшей 
  во время исполнения программы.
</p>
<p>
  Третий вид объектов позволяет программисту полностью управлять выделением и 
  освобождением памяти. Такие объекты называют <em>динамически размещаемыми </em>или, 
  для краткости, просто <em>динамическими</em>. Динамический объект <q>живет</q> в 
  пуле свободной памяти, называемой хипом. Программист создает его с помощью оператора 
  new, а уничтожает с помощью оператора delete. Динамически размещаться может 
  как единичный объект, так и массив объектов. Размер массива, размещаемого в 
  хипе, разрешается задавать во время выполнения.
</p>
<p>
  В этом разделе, посвященном динамическим объектам, мы рассмотрим три формы оператора 
  new: для размещения единичного объекта, для размещения массива и третью форму, 
  называемую <em>оператором размещения </em>new (placement new expression). Когда 
  хип исчерпан, этот оператор возбуждает исключение. (Разговор об исключениях 
  будет продолжен в главе 11. В главе 15 мы расскажем об операторах new и delete 
  применительно к классам.)
</p>

<h3>8.4.1. Динамическое создание и уничтожение единичных объектов</h3>

<p>Оператор new состоит их ключевого слова new, за которым следует спецификатор 
  типа. Этот спецификатор может относиться к встроенным типам или к типам классов. 
  Например:
</p>

<div class="lang-cpp"><![CDATA[new int;]]></div>

<p>размещает в хипе один объект типа int. Аналогично в результате выполнения инструкции
</p>

<div class="lang-cpp"><![CDATA[new iStack;]]></div>

<p>там появится один объект класса iStack.
</p>

<p>
  Сам по себе оператор new не слишком полезен. Как можно реально воспользоваться 
  созданным объектом? Одним из аспектов работы с памятью из хипа является то, 
  что размещаемые в ней объекты не имеют имени. Оператор new возвращает не сам 
  объект, а указатель на него. Все манипуляции с этим объектом производятся косвенно 
  через указатели:
</p>

<div class="lang-cpp"><![CDATA[int *pi = new int;]]></div>

<p>Здесь оператор new создает один объект типа int, на который ссылается указатель 
  pi. Выделение памяти из хипа во время выполнения программы называется динамическим 
  выделением. Мы говорим, что память, адресуемая указателем pi, выделена динамически.
</p>
<p>
  Второй аспект, относящийся к использованию хипа, состоит в том, что эта память 
  не инициализируется. Она содержит <q>мусор</q>, оставшийся после предыдущей работы. 
  Проверка условия:
</p>

<div class="lang-cpp"><![CDATA[if ( *pi == 0 )]]></div>

<p>вероятно, даст false, поскольку объект, на который указывает pi, содержит случайную 
  последовательность битов. Следовательно, объекты, создаваемые с помощью оператора 
  new, рекомендуется инициализировать. Программист может инициализировать объект 
  типа int из предыдущего примера следующим образом:
</p>

<div class="lang-cpp"><![CDATA[int *pi = new int( 0 );]]></div>

<p>Константа в скобках задает начальное значение для создаваемого объекта; теперь 
  pi ссылается на объект типа int, имеющий значение 0. Выражение в скобках называется 
  инициализатором. Это может быть любое выражение (не обязательно константа), 
  возвращающее значение, приводимое к типу int.
</p>

<p>Оператор new выполняет следующую последовательность действий: выделяет из хипа 
  память для объекта, затем инициализирует его значением, стоящим в скобках. Для 
  выделения памяти вызывается библиотечная функция new(). Предыдущий оператор 
  приблизительно эквивалентен следующей последовательности инструкций:
</p>

<div class="lang-cpp"><![CDATA[
int ival = 0; // создаем объект типа int и инициализируем его 0
int *pi = &ival; // указатель ссылается на этот объект
]]></div>

<p>не считая, конечно, того, что объект, адресуемый pi, создается библиотечной 
  функцией new() и размещается в хипе. Аналогично
</p>

<div class="lang-cpp"><![CDATA[iStack *ps = new iStack( 512 );]]></div>

<p>создает объект типа iStack на 512 элементов. В случае объекта класса значение 
  или значения в скобках передаются соответствующему конструктору, который вызывается 
  в случае успешного выделения памяти. (Динамическое создание объектов классов 
  более подробно рассматривается в разделе 15.8. Оставшаяся часть 
  данного раздела посвящена созданию объектов встроенных типов.)
</p>
<p>
  Описанные операторы new могут вызывать одну проблему: хип, к сожалению, является 
  конечным ресурсом, и в некоторой точке выполнения программы мы можем исчерпать 
  его. Если функция new() не может выделить затребованного количества памяти, 
  она возбуждает исключение bad_alloc. (Обработка исключений рассматривается в 
  главе 11.)
</p>
<p>Время жизни объекта, на который указывает pi, заканчивается при освобождении 
  памяти, где этот объект размещен. Это происходит, когда pi передается оператору 
  delete. Например,</p>

<div class="lang-cpp"><![CDATA[delete pi;]]></div>

<p>освобождает память, на которую ссылается pi, завершая время жизни объекта типа 
  int. Программист управляет окончанием жизни объекта, используя оператор delete 
  в нужном месте программы. Этот оператор вызывает библиотечную функцию delete(), 
  которая возвращает выделенную память в хип. Поскольку хип конечен, очень важно 
  возвращать ее своевременно.
</p>

<p>Глядя на предыдущий пример, вы можете спросить: а что случится, если значение 
  pi по какой-либо причине было нулевым? Не следует ли переписать этот код таким 
  образом:
</p>
<div class="lang-cpp"><![CDATA[
// необходимо ли это?
if ( pi != 0 )
   delete pi;
]]></div>

<p>Нет. Язык С++ гарантирует, что оператор delete не будет вызывать функцию delete() 
  в случае нулевого операнда. Следовательно, проверка на 0 необязательна. (Если 
  вы явно добавите такую проверку, в большинстве реализаций она фактически будет 
  выполнена дважды.)
</p>
<p>
  Важно понимать разницу между временем жизни указателя pi и объекта, который 
  он адресует. Сам объект pi является глобальным и объявлен в глобальной области 
  видимости. Следовательно, память под него выделяется до выполнения программы 
  и сохраняется за ним до ее завершения. Совсем не так определяется время жизни 
  адресуемого указателем pi объекта, который создается с помощью оператора new 
  во время выполнения. Область памяти, на которую указывает pi, выделена динамически, 
  следовательно, pi является указателем на динамически размещенный объект типа 
  int. Когда в программе встретится оператор delete, эта память будет освобождена. 
  Однако память, отведенная самому указателю pi, не освобождается, а ее содержимое 
  не изменяется. После выполнения delete объект pi становится висячим указателем, 
  то есть ссылается на область памяти, не принадлежащую программе. Такой указатель 
  служит источником трудно обнаруживаемых ошибок, поэтому сразу после уничтожения 
  объекта ему полезно присвоить 0, обозначив таким образом, что указатель больше 
  ни на что не ссылается.
</p>
<p>
  Оператор delete может использоваться только по отношению к указателю, который 
  содержит адрес области памяти, выделенной в результате выполнения оператора 
  new. Попытка применить delete к указателю, не ссылающемуся на такую память, 
  приведет к непредсказуемому поведению программы. Однако, как было сказано выше, 
  этот оператор можно применять к нулевому указателю.
</p>

<p>Ниже приведены примеры опасных и безопасных операторов delete:
</p>
<div class="lang-cpp"><![CDATA[
void f() {
   int i;
   string str = "dwarves";
   int *pi = &i;
   short *ps = 0;
   double *pd = new doub1e(33);

   delete str; // плохо: str не является динамическим объектом
   delete pi; // плохо: pi ссылается на локальный объект
   delete ps; // безопасно
   delete pd; // безопасно
}
]]></div>

<p>Вот три основные ошибки, связанные с динамическим выделением памяти:
</p>

<ul>
  <li> не освободить выделенную память. В таком случае память не возвращается 
    в хип. Эта ошибка получила название утечки памяти;</li>
  <li> дважды применить оператор delete к одной и той же области памяти. Такое 
    бывает, когда два указателя получают адрес одного и того же динамически размещенного 
    объекта. В результате подобной ошибки мы вполне можем удалить нужный объект. 
    Действительно, память, освобожденная с помощью одного из адресующих ее указателей, 
    возвращается в хип и затем выделяется под другой объект. Затем оператор delete 
    применяется ко второму указателю, адресовавшему старый объект, а удаляется 
    при этом новый;</li>
  <li> изменять объект после его удаления. Такое часто случается, поскольку указатель, 
    к которому применяется оператор delete, не обнуляется.</li>
</ul>

<p>Эти ошибки при работе с динамически выделяемой памятью гораздо легче допустить, 
  нежели обнаружить и исправить. Для того чтобы помочь программисту, стандартная 
  библиотека С++ представляет класс auto_ptr. Мы рассмотрим его в следующем подразделе. 
  После этого мы покажем, как динамически размещать и уничтожать массивы, используя 
  вторую форму операторов new и delete.
</p>

<h3>8.4.2. Шаблон auto_ptr А</h3>

<p>В стандартной библиотеке С++ auto_ptr является шаблоном класса, призванным 
  помочь программистам в манипулировании объектами, которые создаются посредством 
  оператора new. (К сожалению, подобного шаблона для манипулирования динамическими 
  массивами нет. Использовать auto_ptr для создания массивов нельзя, это приведет 
  к непредсказуемым результатам.)
</p>
<p>
  Объект auto_ptr инициализируется адресом динамического объекта, созданного с 
  помощью оператора new. Такой объект автоматически уничтожается, когда заканчивается 
  время жизни auto_ptr. В этом подразделе мы расскажем, как ассоциировать auto_ptr 
  с динамически размещаемыми объектами.
</p>
<p>
  Для использования шаблона класса auto_ptr необходимо включить заголовочный файл:
</p>
<div class="lang-cpp"><![CDATA[#include <memory>]]></div>
<p>Определение объекта auto_ptr имеет три формы:
</p>

<div class="lang-cpp"><![CDATA[
auto_ptr<type_pointed_to> identifier( ptr_allocated_by_new );
auto_ptr<type_pointed_to> identifier( auto_ptr_of_same_type );
auto_ptr<type_pointed_to> identifier;
]]></div>

<p>Здесь type_pointed_to представляет собой тип нужного объекта. Рассмотрим последовательно 
  каждое из этих определений. Как правило, мы хотим непосредственно инициализировать 
  объект auto_ptr адресом объекта, созданного с помощью оператора new. Это можно 
  сделать следующим образом:
</p>

<div class="lang-cpp"><![CDATA[auto_ptr<int> pi ( new int( 1024 ) );]]></div>

<p>В результате значением pi является адрес созданного объекта, инициализированного 
  числом 1024. С объектом, на который указывает auto_ptr, можно работать обычным 
  способом:
</p>
<div class="lang-cpp"><![CDATA[if ( *pi != 1024 )
// ошибка, что-то не так
else *pi *= 2;]]></div>

<p>Объект, на который указывает pi, будет автоматически уничтожен по окончании 
  времени жизни pi. Если указатель pi является локальным, то объект, который он 
  адресует, будет уничтожен при выходе из блока, где он определен. Если же pi 
  глобальный, то объект, на который он ссылается, уничтожается при выходе из программы.
</p>
<p>
  Что будет, если мы инициализируем auto_ptr адресом объекта класса, скажем, стандартного 
  класса string? Например:
</p>

<div class="lang-cpp"><![CDATA[
auto_ptr<string> pstr_auto( new string( "Brontosaurus" ) );
]]></div>

<p>Предположим, что мы хотим выполнить какую-то операцию со строками. С обычной 
  строкой мы бы поступили таким образом:
</p>

<div class="lang-cpp"><![CDATA[string *pstr_type = new string( "Brontosaurus" );
if ( pstr_type->empty() )
// ошибка, что-то не так]]></div>

<p>А как обратиться к операции empty(), используя объект auto_ptr? Точно так же:
</p>

<div class="lang-cpp"><![CDATA[
auto_ptr<string> pstr_auto(new string("Brontosaurus"));
if ( pstr_type->empty())
// ошибка, что-то не так
]]></div>

<p>Создатели шаблона класса auto_ptr не в последнюю очередь стремились сохранить 
  привычный синтаксис, употребляемый с обычными указателями, а также обеспечить 
  дополнительные возможности автоматического удаления объекта, на который ссылается 
  auto_ptr. При этом время выполнения не увеличивается. Применение встроенных 
  функций (которые подставляются по месту вызова) позволило сделать использование 
  объекта auto_ptr немногим более дорогим, чем непосредственное употребление указателя.
</p>
<p>
  Что произойдет, если мы проинициализируем pstr_auto2 значением pstr_auto, который 
  является объектом auto_ptr, указывающим на строку?
</p>

<div class="lang-cpp"><![CDATA[
// кто несет ответственность за уничтожение строки?
auto_ptr<string> pstr_auto2( pstr_auto );
]]></div>

<p>Представим, что мы непосредственно инициализировали один указатель на строку другим:
</p>

<div class="lang-cpp"><![CDATA[string *pstr_type2( pstr_type );]]></div>

<p>Оба указателя теперь содержат адрес одной и той же строки, и мы должны быть 
  внимательными, чтобы не удалить строку дважды.
</p>

<p>В противоположность этому шаблон класса auto_ptr поддерживает понятие владения. 
  Когда мы определили pstr_auto, он стал владельцем строки, адресом которой был 
  инициализирован, и принял на себя ответственность за ее уничтожение.
</p>

<p>Вопрос в том, кто станет владельцем строки, когда мы инициализируем pstr_auto2 
  адресом, указывающим на тот же объект, что и pstr_auto? Нежелательно, чтобы 
  оба объекта владели одной и той же строкой: это вернет нас к проблемам повторного 
  удаления, от которых мы стремились уйти с помощью шаблона класса auto_ptr.
</p>
<p>
  Когда один объект auto_ptr инициализируется другим или получает его значение 
  в результате присваивания, одновременно он получает и право владения адресуемым 
  объектом. Объект auto_ptr, стоящий справа от оператора присваивания, передает 
  право владения и ответственность auto_ptr, стоящему слева. В нашем примере ответственность 
  за уничтожение строки несет pstr_auto2, а не pstr_auto. pstr_auto больше не 
  может употребляться для ссылки на эту строку.
</p>
<p>
  Аналогично ведет себя и операция присваивания. Пусть у нас есть два объекта 
  auto_ptr:
</p>

<div class="lang-cpp"><![CDATA[
auto_ptr<int> p1( new int( 1024 ) );
auto_ptr<int> p2( new int( 2048 ) );
]]></div>

<p>Мы можем скопировать один объекта auto_ptr в другой с помощью этой операции:</p>
<p>p1 = p2;</p>
<p>Перед присваиванием объект, на который ссылался p1, удаляется.
</p>

<p>После присваивания p1 владеет объектом типа int со значением 2048. p2 больше 
  не может использоваться как ссылка на этот объект.
</p>

<p>Третья форма определения объекта auto_ptr создает его, но не инициализирует 
  значением указателя на область памяти из хипа. Например:
</p>

<div class="lang-cpp"><![CDATA[
// пока не ссылается ни на какой объект
auto_ptr<int> p_auto_int;
]]></div>

<p>Поскольку p_auto_int не инициализирован адресом какого-либо объекта, значение 
  хранящегося внутри него указателя равно 0. Разыменование таких указателей приводит 
  к непредсказуемому поведению программы:
</p>
<div class="lang-cpp"><![CDATA[// ошибка: разыменование нулевого указателя
if ( *p_auto_int != 1024 )
   *p_auto_int = 1024;
Обычный указатель можно проверить на равенство 0:
int *pi = 0;
if ( pi ! = 0 ) ...;]]></div>
<p>А как проверить, адресует auto_ptr какой-либо объект или нет? Операция get() 
  возвращает внутренний указатель, использующийся в объекте auto_ptr. Значит, 
  мы должны применить следующую проверку:
</p>

<div class="lang-cpp"><![CDATA[
// проверяем, указывает ли p_auto_int на объект
if ( p_auto_int.get() != 0 &&
        *p_auto_int != 1024 )
   *p_auto_int = 1024;
]]></div>

<p>Если auto_ptr ни на что не указывает, то как заставить его адресовать что-либо? 
  Другими словами, как мы можем присвоить значение внутреннему указателю объекта 
  auto_ptr? Это делается с помощью операции reset(). Например:
</p>

<div class="lang-cpp"><![CDATA[
else
  // хорошо, присвоим ему значение
  p_auto_int.reset( new int( 1024 ) );
]]></div>

<p>Объекту auto_ptr нельзя присвоить адрес объекта, созданного с помощью оператора 
  new:
</p>

<div class="lang-cpp"><![CDATA[
void example() {
  // инициализируется нулем по умолчанию
   auto_ptr<int> pi;
   {
      // не поддерживается
      pi = new int( 5 ) ;
   }
}
]]></div>

<p>В этом случае надо использовать функцию reset(), которой можно передать указатель 
  или 0, если мы хотим обнулить объект auto_ptr. Если auto_ptr указывает на объект 
  и является его владельцем, то этот объект уничтожается перед присваиванием нового 
  значения внутреннему указателю auto_ptr. Например:
</p>

<div class="lang-cpp"><![CDATA[
auto_ptr<string> pstr_auto(new string("Brontosaurus"));

// "Brontosaurus" уничтожается перед присваиванием
pstr_auto.reset( new string( "Long-neck" ) );
]]></div>

<p>В последнем случае лучше, используя операцию assign(), присвоить новое значение 
  существующей строке, чем уничтожать одну строку и создавать другую:
</p>

<div class="lang-cpp"><![CDATA[
// более эффективный способ присвоить новое значение
// используем операцию assign()
pstr_auto->assign( "Long-neck" );
]]></div>

<p>Одна из трудностей программирования состоит в том, что получить правильный 
  результат не всегда достаточно. Иногда накладываются и временные ограничения. 
  Такая мелочь, как удаление и создание заново строкового объекта, вместо использования 
  функции assign() при определенных обстоятельствах может вызвать значительное 
  замедление работы. Подобные детали не должны вас беспокоить при проектировании, 
  но при доводке программы на них следует обращать внимание.
</p>
<p>
  Шаблон класса auto_ptr обеспечивает значительные удобства и безопасность использования 
  динамически выделяемой памяти. Однако все равно надо не терять бдительности, 
  чтобы не навлечь на себя неприятности:
</p>

<ul>
  <li>нельзя инициализировать объект auto_ptr указателем, полученным не с помощью 
    оператора new, или присвоить ему такое значение. В противном случае после 
    применения к этому объекту оператора delete поведение программы непредсказуемо;</li>
  <li> два объекта auto_ptr не должны получать во владение один и тот же объект. 
    Очевидный способ допустить такую ошибку – присвоить одно значение двум объектам. 
    Менее очевидный – с помощью операции get(). Вот пример:

<div class="lang-cpp"><![CDATA[
auto_ptr<string>
pstr_auto( new string( "Brontosaurus" ) );
// ошибка: теперь оба указывают на один объект
// и оба являются его владельцами
auto_ptr<string> pstr_auto2( pstr_auto.get() );
]]></div>

  </li>
</ul>

<p>Операция release() гарантирует, что несколько указателей не являются владельцами 
  одного и того же объекта. release() не только возвращает адрес объекта, на который 
  ссылается auto_ptr, но и передает владение им. Предыдущий фрагмент кода нужно 
  переписать так:
</p>

<div class="lang-cpp"><![CDATA[
// правильно: оба указывают на один объект,
// но pstr_auto больше не является его владельцем
auto_ptr<string>
pstr_auto2( pstr_auto.release() );
]]></div>

<h3>8.4.3. Динамическое создание и уничтожение массивов</h3>

<p>Оператор new может выделить из хипа память для размещения массива. В этом случае 
  после спецификатора типа в квадратных скобках указывается размер массива. Он 
  может быть задан сколь угодно сложным выражением. new возвращает указатель на 
  первый элемент массива. Например:
</p>

<div class="lang-cpp"><![CDATA[
// создание единственного объекта типа int
// с начальным значением 1024
int *pi = new int( 1024 );
]]></div>

<div class="lang-cpp"><![CDATA[
// создание массива из 1024 элементов
// элементы не инициализируются
int *pia = new int[ 1024 ];
]]></div>

<div class="lang-cpp"><![CDATA[
// создание двумерного массива из 4x1024 элементов
int (*pia2)[ 1024 ] = new int[ 4 ][ 1024 ];
]]></div>

<p>pi содержит адрес единственного элемента типа int, инициализированного значением 
  1024; pia – адрес первого элемента массива из 1024 элементов; pia2 – адрес начала 
  массива, содержащего четыре массива по 1024 элемента, т.е. pia2 адресует 4096 
  элементов.
</p>

<p>
  В общем случае массив, размещаемый в хипе, не может быть инициализирован. (В 
  разделе 15.8 мы покажем, как с помощью конструктора по умолчанию присвоить начальное 
  значение динамическому массиву объектов типа класса.) Задавать инициализатор 
  при выделении оператором new памяти под массив не разрешается. Массиву элементов 
  встроенного типа, размещенному в хипе, начальные значения присваиваются с помощью 
  цикла for:
</p>

<div class="lang-cpp"><![CDATA[
for (int index = 0; index < 1024; ++index)
   pia[ index ] = 0;
]]></div>

<p>Основное преимущество динамического массива состоит в том, что количество элементов 
  в его первом измерении не обязано быть константой, т.е. может не быть известным 
  во время компиляции. Для массивов, определяемых в локальной или глобальной области 
  видимости, это не так: здесь размер задавать необходимо.
</p>
<p>
  Например, если указатель в ходе выполнения программы ссылается на разные C-строки, 
  то область памяти под текущую строку обычно выделяется динамически и ее размер 
  определяется в зависимости от длины строки. Как правило, это более эффективно, 
  чем создавать массив фиксированного размера, способный вместить самую длинную 
  строку: ведь все остальные строки могут быть значительно короче. Более того, 
  программа может аварийно завершиться, если длина хотя бы одной из строк превысит 
  отведенный лимит.
</p>
<p>
  Оператор new допустимо использовать для задания первого измерения массива с 
  помощью значения, вычисляемого во время выполнения. Предположим, у нас есть 
  следующие C-строки:
</p>

<div class="lang-cpp"><![CDATA[
const char *noerr = "success";
// ...
const char *err189 = "Error: a function declaration must "
             "specify a function return type!";
]]></div>

<p>Размер создаваемого с помощью оператора new массива может быть задан значением, 
  вычисляемым во время выполнения:
</p>

<div class="lang-cpp"><![CDATA[
#include <cstring>
const char *errorTxt;
if (errorFound)
  errorTxt = errl89;
else
  errorTxt = noerr;
int dimension = strlen( errorTxt ) + 1;
char *strl = new char[ dimension ];
// копируем текст ошибки в strl
strcpy( strl, errorTxt );
dimension разрешается заменить выражением:
// обычная для С++ идиома,
// иногда удивляющая начинающих программистов
char *strl = new char[ str1en( errorTxt ) + 1 ];
]]></div>

<p>Единица, прибавляемая к значению, которое возвращает strlen(), необходима для 
  учета завершающего нулевого символа в C-строке. Отсутствие этой единицы – весьма 
  распространенная ошибка, которую достаточно трудно обнаружить, поскольку она 
  проявляет себя косвенно: происходит затирание какой-либо другой области программы. 
  Почему? Большинство функций, которые обрабатывают массивы, представляющие собой 
  С-строки символов, пробегают по элементам, пока не встретят завершающий нуль.
</p>
<p>
  Если в конце строки нуля нет, то возможно чтение или запись в случайную область 
  памяти. Избежать подобных проблем позволяет класс string из стандартной библиотеки С++.
</p>
<p>
  Отметим, что только первое измерение массива, создаваемого с помощью оператора 
  new, может быть задано значением, вычисляемым во время выполнения. Остальные 
  измерения должны задаваться константами, известными во время компиляции. Например:
</p>

<div class="lang-cpp"><![CDATA[int getDim();
// создание двумерного массива
int (*pia3)[ 1024 ] = new int[ getDim() ][ 1024 ]; // правильно

// ошибка: второе измерение задано не константой
int **pia4 = new int[ 4 ][ getDim() ];]]></div>
<p>Оператор delete для уничтожения массива имеет следующую форму:
</p>
<div class="lang-cpp"><![CDATA[delete[] str1;]]></div>
<p>Пустые квадратные скобки необходимы. Они говорят компилятору, что указатель 
  адресует массив, а не единичный элемент. Поскольку тип str1 – указатель на char, 
  без этих скобок компилятор не поймет, что удалять следует целый массив.
</p>
<p>
  Отсутствие скобок не является синтаксической ошибкой, но правильность выполнения 
  программы не гарантируется (это особенно справедливо для массивов, которые содержат 
  объекты классов, имеющих деструкторы, как это будет показано в разделе 14.4).
</p>
<p>
  Чтобы избежать проблем, связанных с управлением динамически выделяемой памятью 
  для массивов, рекомендуется пользоваться контейнерными типами из стандартной 
  библиотеки, такими, как vector, list или string. Они управляют памятью автоматически.
</p>

<h3>8.4.4. Динамическое создание и уничтожение константных объектов</h3>

<p>Программист способен создать объект в хипе и запретить изменение его значения 
  после инициализации. Этого можно достичь, объявляя объект константным. Для этого 
  применяется следующая форма оператора new:
</p>

<div class="lang-cpp"><![CDATA[const int *pci = new const int(1024);]]></div>

<p>Константный динамический объект имеет несколько особенностей. Во-первых, он 
  должен быть инициализирован, иначе компилятор сигнализирует об ошибке (кроме 
  случая, когда объект принадлежит к типу класса, имеющего конструктор по умолчанию; 
  в такой ситуации инициализатор можно опустить).
</p>

<p>Во-вторых, указатель, возвращаемый выражением new, должен адресовать константу. 
  В предыдущем примере pci служит указателем на const int.
</p>
<p>
  Константность динамически созданного объекта подразумевает, что значение, полученное 
  при инициализации, в дальнейшем не может быть изменено. Но поскольку объект 
  динамический, временем его жизни управляет оператор delete. Например:
</p>

<div class="lang-cpp"><![CDATA[delete pci;]]></div>

<p>Хотя операнд оператора delete имеет тип указателя на const int, эта инструкция 
  является корректной и освобождает область памяти, на которую ссылается pci.
</p>
<p>
  Невозможно создать динамический массив константных элементов встроенного типа 
  потому, что, как мы отмечали выше, элементы такого массива нельзя проинициализировать 
  в операторе new. Следующая инструкция приводит к ошибке компиляции:
</p>

<div class="lang-cpp"><![CDATA[const int *pci = new const int[100]; // ошибка
]]></div>

<h3>8.4.5. Оператор размещения new А</h3>

<p>Существует третья форма оператора new, которая создает объект без отведения 
  для него памяти, то есть в памяти, которая уже была выделена. Эту форму называют 
  <em>оператором размещения </em>new. Программист указывает адрес области памяти, 
  в которой размещается объект:
</p>

<div class="lang-cpp"><![CDATA[new (place_address) type-specifier]]></div>

<p>place_address должен быть указателем. Такая форма (она включается заголовочным 
  файлом &lt;new&gt;) позволяет программисту предварительно выделить большую область 
  памяти, которая впоследствии будет содержать различные объекты. Например:
</p>

<div class="lang-cpp"><![CDATA[
#include <iostream>
#include <new>
const int chunk = 16;
class Foo {
public:
    int val() { return _val; }
    FooQ(){ _val = 0; }
private:
    int _val;
};
// выделяем память, но не создаем объектов Foo
char *buf = new char[ sizeof(Foo) * chunk ];
int main() {
    // создаем объект Foo в buf
    Foo *pb = new (buf) Foo;
    // проверим, что объект помещен в buf
    if ( pb.val() == 0 )
        cout << "Оператор new сработал!" << endl;
    // здесь нельзя использовать pb
    delete[] buf;
    return 0;
}
]]></div>

<p>Результат работы программы:</p>

<div class="lang-cpp"><![CDATA[Оператор new сработал!]]></div>
<p>Для оператора размещения new нет парного оператора delete: он не нужен, поскольку 
  эта форма не выделяет память. В предыдущем примере необходимо освободить память, 
  адресуемую указателем buf, а не pb. Это происходит в конце программы, когда 
  буфер больше не нужен. Поскольку buf ссылается на символьный массив, оператор 
  delete имеет форму
</p>

<div class="lang-cpp"><![CDATA[
delete[] buf;
]]></div>

<p>При уничтожении buf прекращают существование все объекты, созданные в нем. 
  В нашем примере pb больше не ссылается на существующий объект класса Foo.
</p>

<p>Упражнение 8.5:
Объясните, почему приведенные операторы new ошибочны:</p>

<div class="lang-cpp"><![CDATA[
const float *pf = new const float[100];
double *pd = new double[10] [getDim()];
int (*pia2)[ 1024 ] = new int[ ][ 1024 ];
const int *pci = new const int;
]]></div>

<p>Упражнение 8.6:
Как бы вы уничтожили pa?</p>

<div class="lang-cpp"><![CDATA[
typedef int arr[10];
int *pa = new arr;
]]></div>


<p>Упражнение 8.7:
Какие из следующих операторов delete содержат потенциальные ошибки времени выполнения и почему:
</p>

<div class="lang-cpp"><![CDATA[
int globalObj;
char buf[1000];
void f() {
  int *pi = &global0bj;
  double *pd = 0;
  float *pf = new float(O);
  int *pa = new(buf)int[20];
  delete pi; // (a)
  delete pd; // (b)
  delete pf; // (c)
  de1ete[] pa; // (d)
}
]]></div>

<p>Упражнение 8.8: Какие из данных объявлений auto_ptr неверны или грозят ошибками времени выполнения?
Объясните каждый случай.
</p>

<div class="lang-cpp"><![CDATA[
int ix = 1024;
int *pi = &ix;
int *pi2 = new int ( 2048 );
]]></div>

<div class="lang-cpp"><![CDATA[(a) auto_ptr<int> p0(ix);
(b) auto_ptr<int> pl(pi);
(c) auto_ptr<int> p2(pi2);
(d) auto_ptr<int> p3(&ix);
(e) auto_ptr<int> p4(new int(2048));
(f) auto_ptr<int> p5(p2.get());
(9) auto_ptr<int> p6(p2.release());
(h) auto_ptr<int> p7(p2);
]]></div>

<p>Упражнение 8.9:
Объясните разницу между следующими инструкциями.
Для каких случаев более приемлем тот или иной вызов?</p>

<div class="lang-cpp"><![CDATA[
int *pi0 = p2.get();
int *pi1 = p2.release();
]]></div>

<p>Упражнение 8.10:
В чем разница между этими двумя вызовами assign()?
Какой их них предпочтительнее и почему?
</p>

<div class="lang-cpp"><![CDATA[
auto_ptr<string> ps(new string("Daniel"));

ps.get()->assign("Danny");
ps->assign("Danny");
]]></div>

</section>
</chapter>

