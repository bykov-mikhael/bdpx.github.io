<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="xhtml.xsl"?>

<chapter xmlns="http://www.example.com/postrisc"
 id="operator_overloading"
 description="Перегруженные операторы"
>
<title>Перегруженные операторы</title>

<preface>

<p>В этой главе мы рассмотрим два вида специальных функций: перегруженные операторы и определенные пользователем преобразования.
Они дают возможность употреблять объекты классов в выражениях так же интуитивно,
как и объекты встроенных типов. В этой главе мы сначала изложим общие
концепции проектирования перегруженных операторов. Затем представим
понятие друзей класса со специальными правами доступа и обсудим, зачем
они применяются, обратив особое внимание на то, как реализуются
некоторые перегруженные операторы: присваивание, взятие индекса, вызов,
стрелка для доступа к члену класса, инкремент и декремент, а также
специализированные для класса операторы new и delete. Другая категория
специальных функций, которая рассматривается в этой главе, – это
функции преобразования членов (конвертеры), составляющие набор
стандартных преобразований для типа класса. Они неявно применяются
компилятором, когда объекты классов используются в качестве фактических
аргументов функции или операндов встроенных или перегруженных
операторов. Завершается глава развернутым изложением правил разрешения
перегрузки функций с учетом передачи объектов в качестве аргументов,
функций-членов класса и перегруженных операторов.
</p>

</preface>

<section id="operator_overload">
<title>Перегрузка операторов</title>

<p>В предыдущих главах мы уже показывали, что перегрузка операторов
позволяет программисту вводить собственные версии предопределенных
операторов (см. главу 4) для операндов типа классов.
Например, в классе String задано много перегруженных операторов.
Ниже приведено его определение:
</p>

<div class="lang-cpp"><![CDATA[
#include <iostream>
class String;
istream& operator>>(istream&, const String&);
ostream& operator<<(ostream&, const String&);

class String {
public:
     // набор перегруженных конструкторов
     // для автоматической инициализации
    String(const char* = 0 );
    String(const String &);

     // деструктор: автоматическое уничтожение
    ~String();

     // набор перегруженных операторов присваивания
    String& operator=( const String &);
    String& operator=( const char * );

     // перегруженный оператор взятия индекса
    char& operator[]( int );

     // набор перегруженных операторов равенства
     // str1 == str2;
    bool operator==( const char * );
    bool operator==( const String &);

     // функции доступа к членам
    int size() { return _size; };
    char * c_str() { return _string; }
private:
    int   _size;
    char *_string;
};
]]></div>

<p>В классе String есть три набора перегруженных операторов. Первый – это набор операторов присваивания:
</p>

<div class="lang-cpp"><![CDATA[
// набор перегруженных операторов присваивания
String& operator=( const String&);
String& operator=( const char * );
]]></div>

<p>Сначала идет копирующий оператор присваивания.
Следующий оператор поддерживает присваивание C-строки символов объекту типа String:
</p>

<div class="lang-cpp"><![CDATA[
String name;
name = "Sherlock";   // использование оператора operator=( char * )
]]></div>

<p>(Операторы присваивания, отличные от копирующих, мы рассмотрим в разделе 15.3.)
</p>
<p>Во втором наборе есть всего один оператор – взятия индекса:
</p>

<div class="lang-cpp"><![CDATA[
// перегруженный оператор взятия индекса
char& operator[]( int );
]]></div>

<p>Он позволяет программе индексировать объекты класса String точно так же, как массивы объектов встроенного типа:
</p>
<div class="lang-cpp"><![CDATA[if ( name[0] != 'S' )
   cout <<"увы, что-то не так\n";]]></div>
<p>(Детально этот оператор описывается в разделе 15.4.)
</p>
<p>В третьем наборе определены перегруженные операторы равенства
для объектов класса String. Программа может проверить равенство двух
таких объектов или объекта и C-строки:
</p>

<div class="lang-cpp"><![CDATA[
// набор перегруженных операторов равенства
// str1 == str2;
bool operator==( const char * );
bool operator==( const String &);
]]></div>

<p>Перегруженные операторы позволяют использовать объекты типа класса с
операторами, определенными в главе 4, и манипулировать ими так же
интуитивно, как объектами встроенных типов. Например, желая определить
операцию конкатенации двух объектов класса String, мы могли бы
реализовать ее в виде функции-члена concat(). Но почему concat(), а не,
скажем, append()? Выбранное нами имя логично и легко запоминается, но
пользователь все же может забыть, как мы назвали функцию. Зачастую имя
проще запомнить, если определить перегруженный оператор. К примеру,
вместо concat() мы назвали бы новую операцию operator+=(). Такой
оператор используется следующим образом:
</p>
<div class="lang-cpp"><![CDATA[#include "String.h"
int main() {
   String name1 "Sherlock";
   String name2 "Holmes";

   name1 += " ";
   name1 += name2;

   if (! ( name1 == "Sherlock Holmes" ) )
      cout << "конкатенация не сработала\n";
}]]></div>
<p>Перегруженный оператор объявляется в теле класса точно так же, как
обычная функция-член, только его имя состоит из ключевого слова
operator, за которым следует один из множества предопределенных в языке
C++ операторов (см. табл. 15.1). Так можно объявить operator+=() в
классе String:
</p>

<div class="lang-cpp"><![CDATA[
class String {
public:
   // набор перегруженных операторов +=
   String& operator+=( const String &);
   String& operator+=( const char * );
   // ...
private:
   // ...
};
]]></div>

<p>и определить его следующим образом:
</p>
<div class="lang-cpp"><![CDATA[
#include <cstring>

inline String& String::operator+=(const String& rhs) {
     // Если строка, на которую ссылается rhs, непуста
    if ( rhs._string) {
        String tmp( *this );

        // выделить область памяти, достаточную
        // для хранения конкатенированных строк
        _size += rhs._size;
        delete [] _string;
        _string = new char[ _size + 1 ];

        // сначала скопировать в выделенную область исходную строку
        // затем дописать в конец строку, на которую ссылается rhs
        strcpy( _string, tmp._string );
        strcpy( _string + tmp._size, rhs._string );
    }
    return *this;
}

inline String& String::operator+=(const char *s) {
     // Если указатель s ненулевой
    if ( s ) {
        String tmp( *this );

        // выделить область памяти, достаточную
        // для хранения конкатенированных строк
        _size += strlen( s );
        delete [] _string;
        _string = new char[ _size + 1 ];
        // сначала скопировать в выделенную область исходную строку
        // затем дописать в конец C-строку, на которую ссылается s
        strcpy( _string, tmp._string );
        strcpy( _string + tmp._size, s );
     }
    return *this;
}]]></div>

</section>

<section id="operator_members_and_not">
<title>Члены и не члены класса</title>

<p>Рассмотрим операторы равенства в нашем классе String более
внимательно. Первый оператор позволяет устанавливать равенство двух
объектов, а второй – объекта и C-строки:
</p>

<div class="lang-cpp"><![CDATA[
#include "String.h"
int main() {
   String flower;
   // что-нибудь записать в переменную flower

   if ( flower == "lily" )  // правильно
      // ...
   else
   if ( "tulip" == flower )  // ошибка
      // ...
}
]]></div>

<p>При первом использовании оператора равенства в main() вызывается
перегруженный operator==(const char *) класса String. Однако на второй
инструкции if компилятор выдает сообщение об ошибке. В чем дело?
</p>

<p>Перегруженный оператор, являющийся членом некоторого класса,
применяется только тогда, когда левым операндом служит объект этого
класса. Поскольку во втором случае левый операнд не принадлежит к
классу String, компилятор пытается найти такой встроенный оператор, для
которого левым операндом может быть C-строка, а правым – объект класса
String. Разумеется, его не существует, поэтому компилятор говорит об
ошибке.
</p>

<p>Но можно же создать объект класса String из C-строки с помощью
конструктора класса. Почему компилятор не выполнит неявно такое
преобразование:
</p>

<div class="lang-cpp"><![CDATA[if ( String( "tulip" ) == flower )  //правильно: вызывается оператор-член]]></div>

<p>Причина в его неэффективности. Перегруженные операторы не требуют,
чтобы оба операнда имели один и тот же тип. К примеру, в классе Text
определяются следующие операторы равенства:
</p>
<div class="lang-cpp"><![CDATA[class Text {
public:
   Text( const char * = 0 );
   Text( const Text &);

   // набор перегруженных операторов равенства
   bool operator==( const char * ) const;
   bool operator==( const String &) const;
   bool operator==( const Text &) const;

   // ...
};]]></div>
<p>и выражение в main() можно переписать так:
</p>
<div class="lang-cpp"><![CDATA[if ( Text( "tulip" ) == flower )  // вызывается Text::operator==()]]></div>

<p>Следовательно, чтобы найти подходящий для сравнения оператор
равенства, компилятору придется просмотреть все определения классов в
поисках конструктора, способного привести левый операнд к некоторому
типу класса. Затем для каждого из таких типов нужно проверить все
ассоциированные с ним перегруженные операторы равенства, чтобы понять,
может ли хоть один из них выполнить сравнение. А после этого компилятор
должен решить, какая из найденных комбинаций конструктора и оператора
равенства (если таковые нашлись) лучше всего соответствует операнду в
правой части! Если потребовать от компилятора выполнения всех этих
действий, то время трансляции программ C++ резко возрастет. Вместо
этого компилятор просматривает только перегруженные операторы,
определенные как члены класса левого операнда (и его базовых классов,
как мы покажем в главе 19).
</p>

<p>Разрешается, однако, определять перегруженные операторы, не
являющиеся членами класса. При анализе строки в main(), вызвавшей
ошибку компиляции, подобные операторы принимались во внимание. Таким
образом, сравнение, в котором C-строка стоит в левой части, можно
сделать корректным, если заменить операторы равенства, являющиеся
членами класса String, на операторы равенства, объявленные в области
видимости пространства имен:
</p>

<div class="lang-cpp"><![CDATA[
bool operator==(const String&, const String&);
bool operator==(const String&, const char *);
]]></div>

<p>Обратите внимание, что эти глобальные перегруженные операторы имеют
на один параметр больше, чем операторы-члены. Если оператор является
членом класса, то первым параметром неявно передается указатель this.
То есть для операторов-членов выражение
</p>

<div class="lang-cpp"><![CDATA[flower == "lily"]]></div>

<p>переписывается компилятором в виде:
</p>

<div class="lang-cpp"><![CDATA[flower.operator==( "lily" )]]></div>

<p>и на левый операнд flower в определении перегруженного
оператора-члена можно сослаться с помощью this. (Указатель this введен
в разделе 13.4.) В случае глобального перегруженного оператора
параметр, представляющий левый операнд, должен быть задан явно.
</p>

<p>Тогда выражение
</p>

<div class="lang-cpp"><![CDATA[flower == "lily"]]></div>
<p>вызывает оператор
</p>
<div class="lang-cpp"><![CDATA[bool operator==( const String &, const char * );]]></div>
<p>Непонятно, какой оператор вызывается для второго случая использования оператора равенства:
</p>
<div class="lang-cpp"><![CDATA["tulip" == flower]]></div>
<p>Мы ведь не определили такой перегруженный оператор:
</p>
<div class="lang-cpp"><![CDATA[bool operator==( const char *, const String &);]]></div>
<p>Но это необязательно. Когда перегруженный оператор является функцией
в пространстве имен, то как для первого, так и для второго его
параметра (для левого и правого операндов) рассматриваются возможные
преобразования, т.е. компилятор интерпретирует второе использование
оператора равенства как
</p>
<div class="lang-cpp"><![CDATA[operator==( String("tulip"), flower );]]></div>
<p>и вызывает для выполнения сравнения следующий перегруженный оператор:
bool operator==( const String &amp;, const String &amp; );
Но тогда зачем мы предоставили второй перегруженный оператор:
</p>
<div class="lang-cpp"><![CDATA[bool operator==( const String &, const char * );]]></div>
<p>Преобразование типа из C-строки в класс String может быть применено
и к правому операнду. Функция main() будет компилироваться без ошибок,
если просто определить в пространстве имен перегруженный оператор,
принимающий два операнда String:
</p>
<div class="lang-cpp"><![CDATA[bool operator==( const String &, const String &);]]></div>
<p>Предоставлять ли только этот оператор или еще два:
</p>

<div class="lang-cpp"><![CDATA[
bool operator==( const char *, const String &);
bool operator==( const String &, const char * );
]]></div>

<p>зависит от того, насколько велики затраты на преобразование из
C-строки в String во время выполнения, то есть от <q>стоимости</q>
дополнительных вызовов конструктора в программах, пользующихся нашим
классом String. Если оператор равенства будет часто использоваться для
сравнения C-строк и объектов , то лучше предоставить все три варианта.
(Мы вернемся к вопросу эффективности в разделе, посвященном друзьям.
</p>
<p>Подробнее о приведении к типу класса с помощью конструкторов мы
расскажем в разделе 15.9; в разделе 15.10 речь пойдет о разрешении
перегрузки функций с помощью описанных преобразований, а в разделе
15.12 – о разрешении перегрузки операторов.)
</p>
<p>Итак, на основе чего принимается решение, делать ли оператор
членом класса или членом пространства имен? В некоторых случаях у
программиста просто нет выбора:
</p>
<ul>
<li>если перегруженный оператор является членом класса, то он
вызывается лишь при условии, что левым операндом служит член этого
класса. Если же левый операнд имеет другой тип, оператор обязан быть
членом пространства имен;</li>
<li>язык требует, чтобы операторы присваивания ("="), взятия индекса
("[]"), вызова ("()") и доступа к членам по стрелке ("->") были
определены как члены класса. В противном случае выдается сообщение об
ошибке компиляции:</li>
</ul>

<div class="lang-cpp"><![CDATA[
// ошибка: должен быть членом класса
char& operator[](String&, int ix );
]]></div>

<p>(Подробнее оператор присваивания рассматривается в разделе 15.3,
взятия индекса – в разделе 15.4, вызова – в разделе 15.5, а оператор
доступа к члену по стрелке – в разделе 15.6.)
</p>
<p>В остальных случаях решение принимает проектировщик класса.
Симметричные операторы, например оператор равенства, лучше определять в
пространстве имен, если членом класса может быть любой операнд (как в
String).
</p>
<p>Прежде чем закончить этот подраздел, определим операторы равенства для класса String в пространстве имен:
</p>

<div class="lang-cpp"><![CDATA[
bool operator==(const String& str1, const String& str2) {
   if ( str1.size() != str2.size() )
      return false;
   return strcmp( str1.c_str(), str2.c_str() ) ? false : true ;
}

inline bool operator==(const String& str, const char *s) {
   return strcmp( str.c_str(), s ) ? false : true ;
}
]]></div>

</section>

<section id="operator_overloaded_names">
<title>Имена перегруженных операторов</title>

<p>Перегружать можно только предопределенные операторы языка C++ (см. табл. 15.1).
</p>
<p>Таблица 15.1. Перегружаемые операторы
</p>

<div class="lang-cpp"><![CDATA[
+    -    *    /    %    ^    &    |    ~
!    ,    =    <    >    <=    >=    ++    --
<<    >>    ==    !=    &&    ||    +=    -=    /=
%=    ^=    &=    |=    *=    >=    >>=    []    ()
->    ->*    new    new[]    delete    delete[]
]]></div>

<p>Проектировщик класса не вправе объявить перегруженным оператор с
другим именем. Так, при попытке объявить оператор ** для возведения в
степень компилятор выдаст сообщение об ошибке.
</p>
<p>Следующие четыре оператора языка C++ не могут быть перегружены:
</p>
<div class="lang-cpp"><![CDATA[// неперегружаемые операторы
:: .* . ?:]]></div>
<p>Предопределенное назначение оператора нельзя изменить для встроенных
типов. Например, не разрешается переопределить встроенный оператор
сложения целых чисел так, чтобы он проверял результат на переполнение.
</p>
<div class="lang-cpp"><![CDATA[// ошибка: нельзя переопределить встроенный оператор сложения int
int operator+( int, int );]]></div>
<p>Нельзя также определять дополнительные операторы для встроенных
типов данных, например добавить к множеству встроенных операций
operator+ для сложения двух массивов.
</p>
<p>Перегруженный оператор определяется исключительно для операндов
типа класса или перечисления и может быть объявлен только как член
класса или пространства имен, принимая хотя бы один параметр типа
класса или перечисления (переданный по значению или по ссылке).
</p>
<p>Предопределенные приоритеты операторов изменить нельзя.
Независимо от типа класса и реализации оператора в инструкции
</p>
<div class="lang-cpp"><![CDATA[x == y + z;]]></div>
<p>всегда сначала выполняется operator+, а затем operator==; однако помощью скобок порядок можно изменить.
</p>
<p>Предопределенная арность операторов также должна быть сохранена.
К примеру, унарный логический оператор НЕ нельзя определить как
бинарный оператор для двух объектов класса String. Следующая реализация
некорректна и приведет к ошибке компиляции:
</p>

<div class="lang-cpp"><![CDATA[
// некорректно: ! - это унарный оператор
bool operator!(const String& s1, const String& s2)
{
   return ( strcmp( s1.c_str(), s2.c_str() ) != 0 );
}
]]></div>

<p>Для встроенных типов четыре предопределенных оператора ("+", "-",
"*" и "&amp;") используются либо как унарные, либо как бинарные. В
любом из этих качеств они могут быть перегружены.
</p>

<p>Для всех перегруженных операторов, за исключением operator(), недопустимы аргументы по умолчанию.
</p>

</section>

<section id="operator_overloaded_dev">
<title>Разработка перегруженных операторов</title>

<p>Операторы присваивания, взятия адреса и оператор <q>запятая</q> имеют
предопределенный смысл, если операндами являются объекты типа класса.
Но их можно и перегружать. Семантика всех остальных операторов, когда
они применяются к таким операндам, должна быть явно задана
разработчиком. Выбор предоставляемых операторов зависит от ожидаемого
использования класса.
</p>
<p>Начинать следует с определения его открытого интерфейса. Набор
открытых функций-членов формируется с учетом операций, которые класс
должен предоставлять пользователям. Затем принимается решение, какие
функции стоит реализовать в виде перегруженных операторов.
</p>

<p>После определения открытого интерфейса класса проверьте, есть ли логическое соответствие между операциями и операторами:
</p>

<ul>
<li>isEmpty() становится оператором <q>ЛОГИЧЕСКОЕ НЕ</q>, operator!().</li>
<li>isEqual() становится оператором равенства, operator==().</li>
<li>copy() становится оператором присваивания, operator=().</li>
</ul>

<p>У каждого оператора есть некоторая естественная семантика. Так,
бинарный + всегда ассоциируется со сложением, а его отображение на
аналогичную операцию с классом может оказаться удобной и краткой
нотацией. Например, для матричного типа сложение двух матриц является
вполне подходящим расширением бинарного плюса.
</p>
<p>Примером неправильного использования перегрузки операторов
является определение operator+() как операции вычитания, что
бессмысленно: не согласующаяся с интуицией семантика опасна.
</p>
<p>Такой оператор одинаково хорошо поддерживает несколько
различных интерпретаций. Безупречно четкое и обоснованное объяснение
того, что делает operator+(), вряд ли устроит пользователей класса
String, полагающих, что он служит для конкатенации строк. Если
семантика перегруженного оператора неочевидна, то лучше его не
предоставлять.
</p>
<p>Эквивалентность семантики составного оператора и
соответствующей последовательности простых операторов для встроенных
типов (например, эквивалентность оператора +, за которым следует =, и
составного оператора +=) должна быть явно поддержана и для класса.
Предположим, для String определены как operator+(), так и operator=()
для поддержки операций конкатенации и почленного копирования:
</p>
<div class="lang-cpp"><![CDATA[String s1( "C");
String s2( "++" );
s1 = s1 + s2;    // s1 == "C++"]]></div>

<p>Но этого недостаточно для поддержки составного оператора присваивания
</p>

<div class="lang-cpp"><![CDATA[s1 += s2;]]></div>

<p>Его следует определить явно, так, чтобы он поддерживал ожидаемую семантику.
</p>
<p>Упражнение 15.1
</p>
<p>Почему при выполнении следующего сравнения не вызывается
перегруженный оператор operator==(const String&amp;, const
String&amp;):
</p>
<div class="lang-cpp"><![CDATA["cobble" == "stone"]]></div>

<p>Упражнение 15.2:
Напишите перегруженные операторы неравенства, которые могут быть использованы в таких сравнениях:
</p>

<div class="lang-cpp"><![CDATA[
String != String
String != С-строка
C-строка != String
]]></div>

<p>Объясните, почему вы решили реализовать один или несколько операторов.
</p>

<p>Упражнение 15.3:
Выявите те функции-члены класса Screen, реализованного ранее, которые можно перегружать.
</p>

<p>Упражнение 15.4:
Объясните, почему перегруженные операторы ввода и вывода,
определенные для класса String из раздела 3.15, объявлены как
глобальные функции, а не функции-члены.
</p>

<p>Упражнение 15.5:
Реализуйте перегруженные операторы ввода и вывода для класса Screen из главы 13.
</p>

</section>

<section id="operator_friends">
<title>Друзья</title>

<p>Рассмотрим еще раз перегруженные операторы равенства для класса
String, определенные в области видимости пространства имен. Оператор
равенства для двух объектов String выглядит следующим образом:
</p>

<div class="lang-cpp"><![CDATA[
bool operator==(const String& str1, const String& str2) {
   if ( str1.size() != str2.size() )
      return false;
   return strcmp( str1.c_str(), str2.c_str() ) ? false : true;
}
]]></div>

<p>Сравните это определение с определением того же оператора как функции-члена:
</p>

<div class="lang-cpp"><![CDATA[
bool String::operator==(const String& rhs) const {
   if ( _size != rhs._size )
      return false;
   return strcmp( _string, rhs._string ) ? false : true;
}]]></div>
<p>Нам пришлось модифицировать способ обращения к закрытым членам
класса String. Поскольку новый оператор равенства – это глобальная
функция, а не функция-член, у него нет доступа к закрытым членам класса
String. Для получения размера объекта String и лежащей в его основе
C-строки символов используются функции-члены size() и c_str().
</p>
<p>Альтернативной реализацией является объявление глобальных
операторов равенства друзьями класса String. Если функция или оператор
объявлены таким образом, им предоставляется доступ к неоткрытым членам.
</p>
<p>Объявление друга (оно начинается с ключевого слова friend)
встречается только внутри определения класса. Поскольку друзья не
являются членами класса, объявляющего дружественные отношения, то
безразлично, в какой из секций – public, private или protected – они
объявлены. В примере ниже мы решили поместить все подобные объявления
сразу после заголовка класса:
</p>

<div class="lang-cpp"><![CDATA[
class String {
   friend bool operator==( const String&, const String&);
   friend bool operator==( const char *, const String&);
   friend bool operator==( const String&, const char * );
public:
   // ... остальная часть класса String
};
]]></div>

<p>В этих трех строчках три перегруженных оператора сравнения,
принадлежащие глобальной области видимости, объявляются друзьями класса
String, а следовательно, в их определениях можно напрямую обращаться к
закрытым членам данного класса:
</p>

<div class="lang-cpp"><![CDATA[
// дружественные операторы напрямую обращаются к закрытым членам
// класса String
bool operator==(const String& str1, const String& str2) {
   if ( str1._size != str2._size )
      return false;
   return strcmp( str1._string, str2._string ) ? false : true;
}

inline bool operator==(const String& str, const char *s) {
   return strcmp( str._string, s ) ? false : true;
}
// и т.д.
]]></div>

<p>Можно возразить, что в данном случае прямой доступ к членам _size и
_string необязателен, так как встроенные функции c_str() и size() столь
же эффективны и при этом сохраняют инкапсуляцию, а значит, нет особой
нужды объявлять операторы равенства для класса String его друзьями.
</p>
<p>Как узнать, следует ли сделать оператор, не являющийся членом
класса, его другом или воспользоваться функциями доступа? В общем
случае разработчик должен сократить до минимума число объявленных
функций и операторов, которые имеют доступ к внутреннему представлению
класса. Если имеются функции доступа, обеспечивающие равную
эффективность, то предпочтение следует отдать им, тем самым изолируя
операторы в пространстве имен от изменений представления класса, как
это делается и для других функций. Если же разработчик класса не
предоставляет функций доступа для некоторых членов, а объявленный в
пространстве имен оператор должен к этим членам обращаться, то
использование механизма друзей становится неизбежным.
</p>
<p>Наиболее часто такой механизм применяется для того, чтобы
разрешить перегруженным операторам, не являющимся членами класса,
доступ к его закрытым членам. Если бы не необходимость обеспечить
симметрию левого и правого операндов, то перегруженный оператор был бы
функцией-членом с полными правами доступа.
</p>
<p>Хотя объявления друзей обычно употребляются по отношению к
операторам, бывают случаи, когда функцию в пространстве имен,
функцию-член другого класса или даже целый класс приходится объявлять
таким образом. Если один класс объявлен другом второго, то все
функции-члены первого класса получают доступ к неоткрытым членам
другого. Рассмотрим это на примере функций, не являющихся операторами.
</p>
<p>Класс должен объявлять другом каждую из множества перегруженных функций, которой он хочет дать неограниченные права доступа:
</p>

<div class="lang-cpp"><![CDATA[
extern ostream& storeOn(ostream&, Screen&);
extern BitMap& storeOn(BitMap&, Screen&);
// ...

class Screen {
   friend ostream& storeOn(ostream&, Screen&);
   friend BitMap& storeOn(BitMap&, Screen&);
   // ...
};
]]></div>

<p>Если функция манипулирует объектами двух разных классов и ей нужен
доступ к их неоткрытым членам, то такую функцию можно либо объявить
другом обоих классов, либо сделать членом одного и другом второго.
</p>
<p>Объявление функции другом двух классов должно выглядеть так:
</p>

<div class="lang-cpp"><![CDATA[
class Window;   // это всего лишь объявление
class Screen {
   friend bool is_equal( Screen&, Window&);
   // ...
};

class Window {
   friend bool is_equal( Screen&, Window&);
   // ...
};
]]></div>

<p>Если же мы решили сделать функцию членом одного класса и другом второго, то объявления будут построены следующим образом:
</p>

<div class="lang-cpp"><![CDATA[
class Window;
class Screen {
   // copy() - член класса Screen
   Screen& copy( Window & );
   // ...
};

class Window {
   // Screen::copy() - друг класса Window
   friend Screen& Screen::copy( Window& );
   // ...
};

Screen& Screen::copy( Window &) { /* ... */ }
]]></div>

<p>Функция-член одного класса не может быть объявлена другом второго,
пока компилятор не увидел определения ее собственного класса. Это не
всегда возможно. Предположим, что Screen должен объявить некоторые
функции-члены Window своими друзьями, а Window – объявить таким же
образом некоторые функции-члена Screen. В таком случае весь класс
Window объявляется другом Screen:
</p>

<div class="lang-cpp"><![CDATA[
class Window;
class Screen {
   friend class Window;
   // ...
};
]]></div>

<p>К закрытым членам класса Screen теперь можно обращаться из любой функции-члена Window.
</p>

<p>Упражнение 15.6:
Реализуйте операторы ввода и вывода, определенные для класса
Screen в упражнении 15.5, в виде друзей и модифицируйте их определения
так, чтобы они напрямую обращались к закрытым членам. Какая реализация
лучше? Объясните почему.
</p>

</section>

<section id="operator_assignment">
<title>Оператор присваивания <q>=</q></title>

<p>Присваивание одного объекта другому объекту того же класса
выполняется с помощью копирующего оператора присваивания. (Этот
специальный случай был рассмотрен в разделе 14.7.)
</p>
<p>Для класса могут быть определены и другие операторы
присваивания. Если объектам класса надо присваивать значения типа,
отличного от этого класса, то разрешается определить такие операторы,
принимающие подобные параметры. Например, чтобы поддержать присваивание
C-строки объекту String:
</p>

<div class="lang-cpp"><![CDATA[
String car ("Volks");
car = "Studebaker";
]]></div>

<p>мы предоставляем оператор, принимающий параметр типа const char*. Эта операция уже была объявлена в нашем классе:
</p>

<div class="lang-cpp"><![CDATA[
class String {
public:
   // оператор присваивания для char*
   String& operator=( const char * );
   // ...
private:
   int  _size;
   char *string;
};
]]></div>

<p>Такой оператор реализуется следующим образом. Если объекту String
присваивается нулевой указатель, он становится "пустым". В противном
случае ему присваивается копия C-строки:
</p>

<div class="lang-cpp"><![CDATA[
String& String::operator=(const char *sobj) {
   // sobj - нулевой указатель
   if (! sobj ) {
      _size = 0;
      delete[] _string;
      _string = 0;
   } else {
      _size = strlen( sobj );
      delete[] _string;
      _string = new char[ _size + 1 ];
      strcpy( _string, sobj );
   }
   return *this;
}
]]></div>

<p>_string ссылается на копию той C-строки, на которую указывает sobj.
Почему на копию? Потому что непосредственно присвоить sobj члену
_string нельзя:
</p>
<p>_string = sobj;   // ошибка: несоответствие типов
</p>

<p>sobj – это указатель на const и, следовательно, не может быть присвоен указателю на "не-const".
Изменим определение оператора присваивания:
</p>

<div class="lang-cpp"><![CDATA[String& String::operator=( const *sobj ) { // ... }]]></div>

<p>Теперь _string прямо ссылается на C-строку, адресованную sobj.
Однако при этом возникают другие проблемы. Напомним, что C-строка имеет
тип const char*. Определение параметра как указателя на не-const делает
присваивание невозможным:
</p>
<div class="lang-cpp"><![CDATA[
    car = "Studebaker";  // недопустимо с помощью operator=( char *) !
]]></div>

<p>Итак, выбора нет. Чтобы присвоить C-строку объекту типа String, параметр должен иметь тип const char*.
</p>

<p>Хранение в _string прямой ссылки на C-строку, адресуемую sobj,
порождает и иные сложности. Мы не знаем, на что именно указывает sobj.
Это может быть массив символов, который модифицируется способом,
неизвестным объекту String. Например:
</p>
<div class="lang-cpp"><![CDATA[char ia[] = { 'd', 'a', 'n', 'c', 'e', 'r' };
String trap = ia;   // trap._string ссылается на ia
ia[3] = 'g';  // а вот это нам не нужно:
              // модифицируется и ia, и trap._string]]></div>
<p>Если trap._string напрямую ссылался на ia, то объект trap
демонстрировал бы своеобразное поведение: его значение может изменяться
без вызова функций-членов класса String. Поэтому мы полагаем, что
выделение области памяти для хранения копии значения C-строки менее
опасно.
</p>

<p>Обратите внимание, что в операторе присваивания используется
delete. Член _string содержит ссылку на массив символов, расположенный
в хипе. Чтобы предотвратить утечку, память, выделенная под старую
строку, освобождается с помощью delete до выделения памяти под новую.
Поскольку _string адресует массив символов, следует использовать версию delete[] для массивов.
</p>

<p>И последнее замечание об операторе присваивания. Тип
возвращаемого им значения – это ссылка на класс String. Почему именно
ссылка? Дело в том, что для встроенных типов операторы присваивания
можно сцеплять:
</p>

<div class="lang-cpp"><![CDATA[
// сцепление операторов присваивания
int iobj, jobj;
iobj = jobj = 63;
]]></div>

<p>Они ассоциируются справа налево, т.е. в предыдущем примере присваивания выполняются так:
</p>
<div class="lang-cpp"><![CDATA[iobj = (jobj = 63);]]></div>
<p>Это удобно и при работе с объектами класса String: поддерживается, к примеру, следующая конструкция:
</p>
<div class="lang-cpp"><![CDATA[String ver, noun;
verb = noun = "count";]]></div>
<p>При первом присваивании из этой цепочки вызывается определенный
ранее оператор для const char*. Тип полученного результата должен быть
таким, чтобы его можно было использовать как аргумент для копирующего
оператора присваивания класса String. Поэтому, хотя параметр данного
оператора имеет тип const char *, возвращается все же ссылка на String.
</p>
<p>Операторы присваивания бывают перегруженными. Например, в нашем классе String есть такой набор:
</p>

<div class="lang-cpp"><![CDATA[
// набор перегруженных операторов присваивания
String& operator=( const String &);
String& operator=( const char * );
]]></div>

<p>Отдельный оператор присваивания может существовать для каждого типа,
который разрешено присваивать объекту String. Однако все такие
операторы должны быть определены как функции-члены класса.
</p>

</section>

<section id="operator_index">
<title>Оператор взятия индекса</title>

<p>Оператор взятия индекса operator[]() можно определять для классов,
представляющих абстракцию контейнера, из которого извлекаются отдельные
элементы. Примерами таких контейнеров могут служить наш класс String,
класс IntArray, представленный в главе 2, или шаблон класса vector,
определенный в стандартной библиотеке C++. Оператор взятия индекса
обязан быть функцией-членом класса.
</p>

<p>У пользователей String должна иметься возможность чтения и
записи отдельных символов члена _string. Мы хотим поддержать следующий
способ применения объектов данного класса:
</p>

<div class="lang-cpp"><![CDATA[
String entry( "extravagant" );
String mycopy;

for ( int ix = 0; ix < entry.size(); ++ix )
   mycopy[ ix ] = entry[ ix ];
]]></div>

<p>Оператор взятия индекса может появляться как слева, так и справа от
оператора присваивания. Чтобы быть в левой части, он должен возвращать
l-значение индексируемого элемента. Для этого мы возвращаем ссылку:
</p>

<div class="lang-cpp"><![CDATA[
#include <cassert>

inine char& String::operator[](int elem) const {
   assert( elem >= 0 && elem < _size );
   return _string[ elem ];
}
]]></div>

<p>В следующем фрагменте нулевому элементу массива color присваивается символ 'V':
</p>

<div class="lang-cpp"><![CDATA[
String color( "violet" );
color[ 0 ] = 'V';
]]></div>

<p>Обратите внимание, что в определении оператора проверяется выход
индекса за границы массива. Для этого используется библиотечная
C-функция assert(). Можно также возбудить исключение, показывающее, что
значение elem меньше 0 или больше длины C-строки, на которую ссылается
_string. (Возбуждение и обработка исключений обсуждались в главе 11.)
</p>

</section>

<section id="operator_function">
<title>Оператор вызова функции</title>

<p>Оператор вызова функции может быть перегружен для объектов типа класса.
(Мы уже видели, как он используется, при рассмотрении объектов-функций)
Если определен класс, представляющий некоторую операцию, то для ее вызова
перегружается соответствующий оператор. Например, для взятия
абсолютного значения числа типа int можно определить класс absInt:
</p>

<div class="lang-cpp"><![CDATA[
class absInt {
public:
   int operator()( int val ) {
      int result = val < 0 ? -val : val;
      return result;
   }
};
]]></div>

<p>Перегруженный оператор operator() должен быть объявлен как
функция-член с произвольным числом параметров.
Параметры и возвращаемое значение могут иметь любые типы, допустимые для функций.
operator() вызывается путем применения списка аргументов к
объекту того класса, в котором он определен.
Мы рассмотрим, как он используется в одном из обобщенных алгоритмов.
В следующем примере обобщенный алгоритм transform() вызывается для применения
определенной в absInt операции к каждому элементу вектора ivec, т.е.
для замены элемента его абсолютным значением.
</p>

<div class="lang-cpp"><![CDATA[
#include <vector>
#include <algoritm>

int main() {
   int ia[] = { -0, 1, -1, -2, 3, 5, -5, 8 };
   vector<int> ivec( ia, ia+8 );

   // заменить каждый элемент его абсолютным значением
   transform( ivec.begin(), ivec.end(), ivec.begin(), absInt() );

   // ...
}]]></div>
<p>Первый и второй аргументы transform() ограничивают диапазон
элементов, к которым применяется операция absInt. Третий указывает на
начало вектора, где будет сохранен результат применения операции.
</p>
<p>Четвертый аргумент – это временный объект класса absInt,
создаваемый с помощью конструктора по умолчанию. Конкретизация
обобщенного алгоритма transform(), вызываемого из main(), могла бы
выглядеть так:
</p>
<div class="lang-cpp"><![CDATA[typedef vector<int>::iterator iter_type;
// конкретизация transform()
// операция absInt применяется к элементу вектора int
iter_type transform( iter_type iter, iter_type last,
                   iter_type result, absInt func )
{
   while ( iter != last )
      *result++ = func( *iter++ );  // вызывается absInt::operator()

   return iter;
}]]></div>

<p>func – это объект класса, который предоставляет операцию absInt,
заменяющую число типа int его абсолютным значением. Он используется для
вызова перегруженного оператора operator() класса absInt. Этому
оператору передается аргумент *iter, указывающий на тот элемент
вектора, для которого мы хотим получить абсолютное значение.
</p>

</section>

<section id="operator_arrow">
<title>Оператор <q>стрелка</q></title>

<p>Оператор "стрелка", разрешающий доступ к членам, может перегружаться
для объектов класса. Он должен быть определен как функция-член и
обеспечивать семантику указателя. Чаще всего этот оператор используется
в классах, которые предоставляют "интеллектуальный указатель" (smart
pointer), ведущий себя аналогично встроенным, но поддерживают и
некоторую дополнительную функциональность.
</p>

<p>Допустим, мы хотим определить тип класса для представления указателя на объект Screen:
</p>

<div class="lang-cpp"><![CDATA[
class ScreenPtr {
   // ...
private:
   Screen *ptr;
};
]]></div>

<p>Определение ScreenPtr должно быть таким, чтобы объект этого класса
гарантировано указывал на объект Screen: в отличие от встроенного
указателя, он не может быть нулевым. Тогда приложение сможет
пользоваться объектами типа ScreenPtr, не проверяя, указывают ли они на
какой-нибудь объект Screen. Для этого нужно определить класс ScreenPtr
с конструктором, но без конструктора по умолчанию:
</p>

<div class="lang-cpp"><![CDATA[
class ScreenPtr {
public:
   ScreenPtr( const Screen& s) : ptr(&s) { }
   // ...
};
]]></div>

<p>В любом определении объекта класса ScreenPtr должен присутствовать
инициализатор – объект класса Screen, на который будет ссылаться объект
ScreenPtr:
</p>

<div class="lang-cpp"><![CDATA[
ScreenPtr p1;   // ошибка: у класса ScreenPtr нет конструктора по умолчанию

Screen myScreen( 4, 4 );
ScreenPtr ps( myScreen );  // правильно
]]></div>

<p>Чтобы класс ScreenPtr вел себя как встроенный указатель, необходимо
определить некоторые перегруженные операторы – разыменования (*) и
<q>стрелку</q> для доступа к членам:
</p>

<div class="lang-cpp"><![CDATA[
// перегруженные операторы для поддержки поведения указателя
class ScreenPtr {
public:
   Screen& operator*()  { return *ptr; }
   Screen* operator->() { return ptr; }
   // ...
};
]]></div>

<p>Оператор доступа к членам унарный, поэтому параметры ему не передаются. При
использовании в составе выражения его результат зависит только от типа
левого операнда. Например, в инструкции
point-&gt;action();
исследуется тип point. Если это указатель на некоторый тип класса, то
применяется семантика встроенного оператора доступа к члену. Если же
это объект или ссылка на объект, то проверяется, есть ли в этом классе
перегруженный оператор доступа. Когда перегруженный оператор "стрелка"
определен, он вызывается для объекта point, иначе инструкция неверна,
поскольку для обращения к членам самого объекта (в том числе по ссылке)
следует использовать оператор "точка".
</p>
<p>
Перегруженный оператор "стрелка" должен возвращать либо указатель на
тип класса, либо объект класса, в котором он определен. Если
возвращается указатель, то к нему применяется семантика встроенного
оператора "стрелка". В противном случае процесс продолжается
рекурсивно, пока не будет получен указатель или определена ошибка.
Например, так можно воспользоваться объектом ps класса ScreenPtr для
доступа к членам Screen:
ps-&gt;move( 2, 3 );
</p>
<p>
Поскольку слева от оператора "стрелка" находится объект типа ScreenPtr,
то употребляется перегруженный оператор этого класса, который
возвращает указатель на объект Screen. Затем к полученному значению
применяется встроенный оператор "стрелка" для вызова функции-члена
move().
</p>
<p>
Ниже приводится небольшая программа для тестирования класса ScreenPtr.
Объект типа ScreenPtr используется точно так же, как любой объект типа
Screen*:
</p>

<div class="lang-cpp"><![CDATA[
#include <iostream>
#include <string>
#include "Screen.h"
void printScreen(const ScreenPtr& ps) {
    cout << "Screen Object ( " << ps->height() << "," << ps->width() << " )\n\n";
    for ( int ix = 1; ix <= ps->height(); ++ix ) {
        for ( int iy = 1; iy <= ps->width(); ++iy )
            cout << ps->get( ix, iy ); cout << "\n"; }
}

int main() {
    Screen sobj( 2, 5 );
    string init( "HelloWorld" );
    ScreenPtr ps( sobj ); // Установить содержимое экрана string::size_type
    initpos = 0; for ( int ix = 1; ix <= ps->height(); ++ix )
    for (int iy = 1; iy <= ps->width(); ++iy ) {
        ps->move( ix, iy );
        ps->set( init[ initpos++ ] );
    } // Вывести содержимое экрана
    printScreen( ps ); return 0;
}
]]></div>

<p>Разумеется, подобные манипуляции с указателями на объекты классов
не так эффективны, как работа со встроенными указателями. Поэтому
интеллектуальный указатель должен предоставлять дополнительную
функциональность, важную для приложения, чтобы оправдать сложность
своего использования.
</p>

</section>

<section id="operator_incdec">
<title>Операторы инкремента и декремента</title>

<p>Продолжая развивать реализацию класса ScreenPtr, введенного в
предыдущем разделе, рассмотрим еще два оператора, которые
поддерживаются для встроенных указателей и которые желательно иметь и
для нашего интеллектуального указателя: инкремент (++) и декремент
(--). Чтобы использовать класс ScreenPtr для ссылки на элементы массива
объектов Screen, туда придется добавить несколько дополнительных
членов.
</p>

<p>Сначала мы определим новый член size, который содержит либо
нуль (это говорит о том, что объект ScreenPtr указывает на единственный
объект), либо размер массива, адресуемого объектом ScreenPtr. Нам также
понадобится член offset, запоминающий смещение от начала данного
массива:
</p>

<div class="lang-cpp"><![CDATA[class ScreenPtr {
public:
   // ...
private:
   int size;         // размер массива: 0, если единственный объект
   int offset;       // смещение ptr от начала массива
   Screen *ptr;
};]]></div>
<p>Модифицируем конструктор класса ScreenPtr с учетом его новой
функциональности и дополнительных членов,. Пользователь нашего класса
должен передать конструктору дополнительный аргумент, если создаваемый
объект указывает на массив:
</p>

<div class="lang-cpp"><![CDATA[
class ScreenPtr {
public:
    ScreenPtr(Screen& s , int arraySize = 0 )
      : ptr(&s), size ( arraySize ), offset( 0 ) { }
private:
   int size;
   int offset;
   Screen *ptr;
};
]]></div>

<p>С помощью этого аргумента задается размер массива. Чтобы сохранить
прежнюю функциональность, предусмотрим для него значение по умолчанию,
равное нулю. Таким образом, если второй аргумент конструктора опущен,
то член size окажется равен 0 и, следовательно, такой объект будет
указывать на единственный объект Screen. Объекты нового класса
ScreenPtr можно определять следующим образом:
</p>

<div class="lang-cpp"><![CDATA[
Screen myScreen( 4, 4 );
ScreenPtr pobj( myScreen );  // правильно: указывает на один объект
const int arrSize = 10;
Screen *parray = new Screen[ arrSize ];
ScreenPtr parr( *parray, arrSize );  // правильно: указывает на массив
]]></div>

<p>Теперь мы готовы определить в ScreenPtr перегруженные операторы
инкремента и декремента. Однако они бывают двух видов: префиксные и
постфиксные. К счастью, можно определить оба варианта. Для префиксного
оператора объявление не содержит ничего неожиданного:
</p>

<div class="lang-cpp"><![CDATA[
class ScreenPtr {
public:
   Screen& operator++();
   Screen& operator--();
   // ...
};
]]></div>

<p>Такие операторы определяются как унарные операторные функции.
Использовать префиксный оператор инкремента можно, к примеру, следующим
образом:
</p>

<div class="lang-cpp"><![CDATA[
const int arrSize = 10;
Screen *parray = new Screen[ arrSize ];
ScreenPtr parr( *parray, arrSize );
for ( int ix = 0; ix < arrSize; ++ix, ++parr ) // эквивалентно
    parr.operator++() } printScreen( parr );
]]></div>

<p>Определения этих перегруженных операторов приведены ниже:
</p>

<div class="lang-cpp"><![CDATA[
Screen& ScreenPtr::operator++() {
   if ( size == 0 ) {
      cerr <<"не могу инкрементировать указатель для одного объекта\n";
      return *ptr;
   }
   if ( offset >= size - 1 ) {
      cerr << "уже в конце массива\n";
      return *ptr;
   }

   ++offset;
   return *++ptr;
}

Screen& ScreenPtr::operator--() {
   if ( size == 0 ) {
      cerr << "не могу декрементировать указатель для одного объекта\n";
      return *ptr;
   }
   if ( offset <= 0 ) {
      cerr << "уже в начале массива\n";
      return *ptr;
   }

   --offset;
   return *--ptr;
}
]]></div>

<p>Чтобы отличить префиксные операторы от постфиксных, в объявлениях
последних имеется дополнительный параметр типа int. В следующем
фрагменте объявлены префиксные и постфиксные варианты операторов
инкремента и декремента для класса ScreenPtr:
</p>

<div class="lang-cpp"><![CDATA[
class ScreenPtr {
public:
   Screen& operator++();    // префиксные операторы
   Screen& operator--();
   Screen& operator++(int); // постфиксные операторы
   Screen& operator--(int);
   // ...
};
]]></div>

<p>Ниже приведена возможная реализация постфиксных операторов:
</p>

<div class="lang-cpp"><![CDATA[
Screen& ScreenPtr::operator++(int) {
   if ( size == 0 ) {
      cerr << "не могу инкрементировать указатель для одного объекта\n";
      return *ptr;
   }
   if ( offset == size ) {
      cerr << "уже на один элемент дальше конца массива\n";
      return *ptr;
   }

   ++offset;
   return *ptr++;
}

Screen& ScreenPtr::operator--(int) {
   if ( size == 0 ) {
      cerr << "не могу декрементировать указатель для одного объекта\n";
      return *ptr;
   }
   if ( offset == -1 ) {
      cerr <<"уже на один элемент раньше начала массива\n";
      return *ptr;
   }

   --offset;
   return *ptr--;
}
]]></div>

<p>Обратите внимание, что давать название второму параметру нет
необходимости, поскольку внутри определения оператора он не
употребляется. Компилятор сам подставляет для него значение по
умолчанию, которое можно игнорировать. Вот пример использования
постфиксного оператора:
</p>

<div class="lang-cpp"><![CDATA[
const int arrSize = 10;
Screen *parray = new Screen[ arrSize ];
ScreenPtr parr( *parray, arrSize );
for ( int ix = 0; ix < arrSize; ++ix)
    printScreen( parr++ );
]]></div>

<p>При его явном вызове необходимо все же передать значение второго
целого аргумента. В случае нашего класса ScreenPtr это значение
игнорируется, поэтому может быть любым:
</p>
<div class="lang-cpp"><![CDATA[parr.operator++(1024);   // вызов постфиксного operator++]]></div>
<p>Перегруженные операторы инкремента и декремента разрешается
объявлять как дружественные функции. Изменим соответствующим образом
определение класса ScreenPtr:
</p>

<div class="lang-cpp"><![CDATA[
class ScreenPtr {
   // объявления не членов
   // ...
   // префиксные операторы
   friend Screen& operator++(Screen &);
   friend Screen& operator--(Screen &);
   // постфиксные операторы
   friend Screen& operator++(Screen &, int);
   friend Screen& operator--(Screen &, int);
public:
   // определения членов
};
]]></div>

<p>Упражнение 15.7: Напишите определения перегруженных операторов инкремента и
декремента для класса ScreenPtr, предположив, что они объявлены как
друзья класса.
</p>

<p>Упражнение 15.8: С помощью ScreenPtr можно представить указатель на массив
объектов класса Screen. Модифицируйте перегруженные operator*() и
operator >() (см. раздел 15.6) так, чтобы указатель ни при каком
условии не адресовал элемент перед началом или за концом массива.
Совет: в этих операторах следует воспользоваться новыми членами size и
offset.
</p>

</section>

<section id="operator_newdelete">
<title>Операторы new и delete</title>

<p>По умолчанию выделение объекта класса из хипа и освобождение занятой им памяти выполняются с помощью глобальных операторов new() и delete(),
определенных в стандартной библиотеке C++.
Но класс может реализовать и собственную стратегию управления памятью, предоставив одноименные операторы-члены. Если они определены в классе, то вызываются вместо глобальных операторов с целью выделения и освобождения памяти для объектов этого класса.
</p>
<p>Определим операторы new() и delete() в нашем классе Screen.
</p>
<p>Оператор-член new() должен возвращать значение типа void* и принимать в качестве первого параметра значение типа size_t, где size_t – это typedef, определенный в системном заголовочном файле &lt;cstddef&gt;.
Вот его объявление:
</p>

<div class="lang-cpp"><![CDATA[
class Screen {
public:
   void *operator new( size_t );
   // ...
};
]]></div>

<p>Когда для создания объекта типа класса используется new(), компилятор проверяет, определен ли в этом классе такой оператор.
Если да, то для выделения памяти под объект вызывается именно он, в противном случае – глобальный оператор new(). Например, следующая инструкция
</p>

<div class="lang-cpp"><![CDATA[Screen *ps = new Screen;]]></div>

<p>создает объект Screen в хипе, а поскольку в этом классе есть оператор new(), то вызывается он.
Параметр size_t оператора автоматически инициализируется значением, равным размеру Screen в байтах.
</p>
<p>Добавление оператора new() в класс или его удаление оттуда не отражаются на пользовательском коде.
Вызов new выглядит одинаково как для глобального оператора, так и для оператора-члена.
Если бы в классе Screen не было собственного new(), то обращение осталось бы правильным, только вместо оператора-члена вызывался бы глобальный оператор.
</p>
<p>С помощью оператора разрешения глобальной области видимости можно вызвать глобальный new(), даже если в классе Screen определена собственная версия:
</p>

<div class="lang-cpp"><![CDATA[Screen *ps = ::new Screen;]]></div>

<p>Оператор delete(), являющийся членом класса, должен иметь тип void, а в качестве первого параметра принимать void*. Вот как выглядит его объявление для Screen:
</p>
<div class="lang-cpp"><![CDATA[class Screen {
public:
   void operator delete( void * );
};]]></div>
<p>Когда операндом delete служит указатель на объект типа класса, компилятор проверяет, определен ли в этом классе оператор delete(). Если да, то для освобождения памяти вызывается именно он, в противном случае – глобальная версия оператора. Следующая инструкция
</p>

<div class="lang-cpp"><![CDATA[delete ps;]]></div>

<p>освобождает память, занятую объектом класса Screen, на который указывает ps. Поскольку в Screen есть оператор-член delete(), то применяется именно он. Параметр оператора типа void* автоматически инициализируется значением ps.
Добавление delete() в класс или его удаление оттуда никак не сказываются на пользовательском коде. Вызов delete выглядит одинаково как для глобального оператора, так и для оператора-члена. Если бы в классе Screen не было собственного оператора delete(), то обращение осталось бы правильным, только вместо оператора-члена вызывался бы глобальный оператор.
</p>

<p>С помощью оператора разрешения глобальной области видимости можно вызвать глобальный delete(), даже если в Screen определена собственная версия:
</p>

<div class="lang-cpp"><![CDATA[::delete ps;]]></div>

<p>В общем случае используемый оператор delete() должен соответствовать тому оператору new(), с помощью которого была выделена память. Например, если ps указывает на область памяти, выделенную глобальным new(), то для ее освобождения следует использовать глобальный же delete().
</p>
<p>Оператор delete(), определенный для типа класса, может содержать два параметра вместо одного.
Первый параметр по-прежнему должен иметь тип void*, а второй – предопределенный тип size_t (не забудьте включить заголовочный файл &lt;cstddef&gt;):
</p>

<div class="lang-cpp"><![CDATA[
class Screen {
public:
   // заменяет
   // void operator delete( void * );
   void operator delete( void *, size_t );
};]]></div>
<p>Если второй параметр есть, компилятор автоматически инициализирует его значением, равным размеру адресованного первым параметром объекта в байтах.
Этот параметр важен в иерархии классов, когда оператор delete() может наследоваться производным классом.
</p>

<p>Рассмотрим реализацию операторов new() и delete() в классе Screen более детально. В основе нашей стратегии распределения памяти будет лежать связанный список объектов Screen, на начало которого указывает член freeStore. При каждом обращении к оператору-члену new() возвращается следующий объект из списка. При вызове delete() объект возвращается в список. Если при создании нового объекта список, адресованный freeStore, пуст, то вызывается глобальный оператор new(), чтобы получить блок памяти, достаточный для хранения screenChunk объектов класса Screen.
</p>

<p>Как screenChunk, так и freeStore представляют интерес только для Screen, поэтому мы сделаем их закрытыми членами. Кроме того, для всех создаваемых объектов нашего класса значения этих членов должны быть одинаковыми, а следовательно, нужно объявить их статическими. Чтобы поддержать структуру связанного списка объектов Screen, нам понадобится третий член next:
</p>

<div class="lang-cpp"><![CDATA[class Screen {
public:
   void *operator new( size_t );
   void operator delete( void *, size_t );
   // ...
private:
   Screen *next;
   static Screen *freeStore;
   static const int screenChunk;
};]]></div>

<p>Вот одна из возможных реализаций оператора new() для класса Screen:
</p>

<div class="lang-cpp"><![CDATA[
#include "Screen.h"
#include <cstddef>

// статические члены инициализируются
// в исходных файлах программы, а не в заголовочных файлах
Screen *Screen::freeStore = 0;
const int Screen::screenChunk = 24;

void *Screen::operator new(size_t size) {
   Screen *p;

   if ( !freeStore ) {
      // связанный список пуст: получить новый блок
      // вызывается глобальный оператор new
      size_t chunk = screenChunk * size;
      freeStore = p = reinterpret_cast<Screen*>( new char[ chunk ] );

      // включить полученный блок в список
      for ( ;
            p != &freeStore[ screenChunk - 1 ];
            ++p )
          p->next = p+1;
      p->next = 0;
    }

    p = freeStore;
    freeStore = freeStore->next;
    return p;
}
А вот реализация оператора delete():
void Screen::operator delete( void *p, size_t )
{
   // вставить "удаленный" объект назад,
   // в список свободных

   ( static_cast<Screen*>( p ) )->next = freeStore;
   freeStore = static_cast<Screen*>( p );
}
]]></div>

<p>Оператор new() можно объявить в классе и без соответствующего delete(). В таком случае объекты освобождаются с помощью одноименного глобального оператора. Разрешается также объявить и оператор delete() без new(): объекты будут создаваться с помощью одноименного глобального оператора. Однако обычно эти операторы реализуются одновременно, как в примере выше, поскольку разработчику класса, как правило, нужны оба.
</p>
<p>Они являются статическими членами класса, даже если программист явно не объявит их таковыми, и подчиняются обычным ограничениями для подобных функций-членов: им не передается указатель this, а следовательно, напрямую они могут получить доступ только к статическим членам. (См. обсуждение статических функций-членов в разделе 13.5.) Причина, по которой эти операторы делаются статическими, заключается в том, что они вызываются либо перед конструированием объекта класса (new()), либо после его уничтожения (delete()).
</p>
<p>Выделение памяти с помощью оператора new(), например:
</p>

<div class="lang-cpp"><![CDATA[Screen *ptr = new Screen( 10, 20 );]]></div>

<p>эквивалентно последовательному выполнению таких инструкций:
</p>
<div class="lang-cpp"><![CDATA[// Псевдокод на C++
ptr = Screen::operator new( sizeof( Screen ) );
Screen::Screen( ptr, 10, 20 );]]></div>
<p>Иными словами, сначала вызывается определенный в классе оператор new(), чтобы выделить память для объекта, а затем этот объект инициализируется конструктором. Если new() неудачно завершает работу, то возбуждается исключение типа bad_alloc и конструктор не вызывается.
</p>
<p>Освобождение памяти с помощью оператора delete(), например:
</p>
<div class="lang-cpp"><![CDATA[delete ptr;]]></div>
<p>эквивалентно последовательному выполнению таких инструкций:
</p>
<div class="lang-cpp"><![CDATA[// Псевдокод на C++
Screen::~Screen( ptr );
Screen::operator delete( ptr, sizeof( *ptr ) );]]></div>
<p>Таким образом, при уничтожении объекта сначала вызывается деструктор класса, а затем определенный в классе оператор delete() для освобождения памяти. Если значение ptr равно 0, то ни деструктор, ни delete() не вызываются.
</p>

</section>

<section id="operator_overloaded_newdelete">
<title>Операторы new[ ] и delete [ ]</title>

<p>Оператор new(), определенный в предыдущем подразделе, вызывается только при выделении памяти для единичного объекта. Так, в данной инструкции вызывается new() класса Screen:
</p>
<div class="lang-cpp"><![CDATA[// вызывается Screen::operator new()
Screen *ps = new Screen( 24, 80 );]]></div>
<p>тогда как ниже вызывается глобальный оператор new[]() для выделения из хипа памяти под массив объектов типа Screen:
</p>
<div class="lang-cpp"><![CDATA[// вызывается Screen::operator new[]()
Screen *psa = new Screen[10];]]></div>
<p>В классе можно объявить также операторы new[]() и delete[]() для работы с массивами.
</p>
<p>Оператор-член new[]() должен возвращать значение типа void* и принимать в качестве первого параметра значение типа size_t. Вот его объявление для Screen:
</p>
<div class="lang-cpp"><![CDATA[class Screen {
public:
   void *operator new[]( size_t );
   // ...
};]]></div>
<p>Когда с помощью new создается массив объектов типа класса, компилятор проверяет, определен ли в классе оператор new[](). Если да, то для выделения памяти под массив вызывается именно он, в противном случае – глобальный new[](). В следующей инструкции в хипе создается массив из десяти объектов Screen:
</p>
<div class="lang-cpp"><![CDATA[Screen *ps = new Screen[10];]]></div>
<p>В этом классе есть оператор new[](), поэтому он и вызывается для выделения памяти. Его параметр size_t автоматически инициализируется значением, равным объему памяти в байтах, необходимому для размещения десяти объектов Screen.
</p>
<p>Даже если в классе имеется оператор-член new[](), программист может вызвать для создания массива глобальный new[](), воспользовавшись оператором разрешения глобальной области видимости:
</p>
<div class="lang-cpp"><![CDATA[Screen *ps = ::new Screen[10];]]></div>

<p>Оператор delete(), являющийся членом класса, должен иметь тип void, а в качестве первого параметра принимать void*. Вот как выглядит его объявление для Screen:
</p>
<div class="lang-cpp"><![CDATA[class Screen {
public:
   void operator delete[]( void * );
};]]></div>
<p>Чтобы удалить массив объектов класса, delete должен вызываться следующим образом:
</p>
<div class="lang-cpp"><![CDATA[delete[] ps;]]></div>
<p>Когда операндом delete является указатель на объект типа класса, компилятор проверяет, определен ли в этом классе оператор delete[](). Если да, то для освобождения памяти вызывается именно он, в противном случае – его глобальная версия. Параметр типа void* автоматически инициализируется значением адреса начала области памяти, в которой размещен массив.
</p>
<p>Даже если в классе имеется оператор-член delete[](), программист может вызвать глобальный delete[](), воспользовавшись оператором разрешения глобальной области видимости:
</p>
<div class="lang-cpp"><![CDATA[::delete[] ps;]]></div>
<p>Добавление операторов new[]() или delete[]() в класс или удаление их оттуда не отражаются на пользовательском коде: вызовы как глобальных операторов, так и операторов-членов выглядят одинаково.
</p>
<p>При создании массива сначала вызывается new[]() для выделения необходимой памяти, а затем каждый элемент инициализируется с помощью конструктора по умолчанию. Если у класса есть хотя бы один конструктор, но нет конструктора по умолчанию, то вызов оператора new[]() считается ошибкой. Не существует синтаксической конструкции для задания инициализаторов элементов массива или аргументов конструктора класса при создании массива подобным образом.
</p>
<p>При уничтожении массива сначала вызывается деструктор класса для уничтожения элементов, а затем оператор delete[]() – для освобождения всей памяти. При этом важно использовать правильный синтаксис. Если в инструкции
</p>
<div class="lang-cpp"><![CDATA[delete ps;]]></div>
<p>ps указывает на массив объектов класса, то отсутствие квадратных скобок приведет к вызову деструктора лишь для первого элемента, хотя память будет освобождена полностью.
</p>
<p>У оператора-члена delete[]() может быть не один, а два параметра, при этом второй должен иметь тип size_t:
</p>
<div class="lang-cpp"><![CDATA[class Screen {
public:
   // заменяет
   // void operator delete[]( void* );
   void operator delete[]( void*, size_t );
};]]></div>

<p>Если второй параметр присутствует, то компилятор автоматически инициализирует его значением, равным объему отведенной под массив памяти в байтах.
</p>

</section>

<section id="operator_overloaded_placement_newdelete">
<title>Оператор размещения new() и оператор delete()</title>

<p>Оператор-член new() может быть перегружен при условии, что все объявления имеют разные списки параметров. Первый параметр должен иметь тип size_t:
</p>

<div class="lang-cpp"><![CDATA[class Screen {
public:
   void *operator new( size_t );
   void *operator new( size_t, Screen * );
   // ...
};]]></div>
<p>Остальные параметры инициализируются аргументами размещения, заданными при вызове new:
</p>
<div class="lang-cpp"><![CDATA[void func( Screen *start ) {
   Screen *ps = new (start) Screen;
   // ...
}]]></div>
<p>Та часть выражения, которая находится после ключевого слова new и заключена в круглые скобки, представляет аргументы размещения. В примере выше вызывается оператор new(), принимающий два параметра. Первый автоматически инициализируется значением, равным размеру класса Screen в байтах, а второй – значением аргумента размещения start.
</p>
<p>Можно также перегружать и оператор-член delete(). Однако такой оператор никогда не вызывается из выражения delete. Перегруженный delete() неявно вызывается компилятором, если конструктор, вызванный при выполнении оператора new (это не опечатка, мы действительно имеем в виду new), возбуждает исключение. Рассмотрим использование delete() более внимательно.
</p>
<p>Последовательность действий при вычислении выражения
</p>
<div class="lang-cpp"><![CDATA[Screen *ps = new ( start ) Screen;]]></div>

<p>такова:</p>

<ol><li>Вызывается определенный в классе оператор new(size_t, Screen*).</li>
<li>Вызывается конструктор по умолчанию класса Screen для инициализации созданного объекта.</li></ol>
<p>Переменная ps инициализируется адресом нового объекта Screen.
</p>
<p>Предположим, что оператор класса new(size_t, Screen*) выделяет память с помощью глобального new(). Как разработчик может гарантировать, что память будет освобождена, если вызванный на шаге 2 конструктор возбуждает исключение? Чтобы защитить пользовательский код от утечки памяти, следует предоставить перегруженный оператор delete(), который вызывается только в подобной ситуации.
</p>
<p>Если в классе имеется перегруженный оператор с параметрами, типы которых соответствуют типам параметров new(), то компилятор автоматически вызывает его для освобождения памяти. Предположим, есть следующее выражение с оператором размещения new:
</p>
<div class="lang-cpp"><![CDATA[Screen *ps = new (start) Screen;]]></div>
<p>Если конструктор по умолчанию класса Screen возбуждает исключение, то компилятор ищет delete() в области видимости Screen. Чтобы такой оператор был найден, типы его параметров должны соответствовать типам параметров вызванного new(). Поскольку первый параметр new() всегда имеет тип size_t, а оператора delete() – void*, то первые параметры при сравнении не учитываются. Компилятор ищет в классе Screen оператор delete() следующего вида:
</p>
<div class="lang-cpp"><![CDATA[void operator delete( void*, Screen* );]]></div>
<p>Если такой оператор будет найден, то он вызывается для освобождения памяти в случае, когда new() возбуждает исключение. (Иначе – не вызывается.)
</p>
<p>Разработчик класса принимает решение, предоставлять ли delete(), соответствующий некоторому new(), в зависимости от того, выделяет ли этот оператор new() память самостоятельно или пользуется уже выделенной. В первом случае delete() необходимо включить для освобождения памяти, если конструктор возбудит исключение; иначе в нем нет необходимости.
</p>
<p>Можно также перегрузить оператор размещения new[]() и оператор delete[]() для массивов:
</p>
<div class="lang-cpp"><![CDATA[class Screen {
public:
   void *operator new[]( size_t );
   void *operator new[]( size_t, Screen* );
   void operator delete[]( void*, size_t );
   void operator delete[]( void*, Screen* );
   // ...
};]]></div>
<p>Оператор new[]() используется в случае, когда в выражении, содержащем new для распределения массива, заданы соответствующие аргументы размещения:
</p>
<div class="lang-cpp"><![CDATA[void func( Screen *start ) {
   // вызывается Screen::operator new[]( size_t, Screen* )
   Screen *ps = new (start) Screen[10];
   // ...
}]]></div>
<p>Если при работе оператора new конструктор возбуждает исключение, то автоматически вызывается соответствующий delete[]().
</p>

<p>Упражнение 15.9:
Объясните, какие из приведенных инициализаций ошибочны:
</p>
<div class="lang-cpp"><![CDATA[class iStack {
public:
   iStack( int capacity )
         : _stack( capacity ), _top( 0 ) {}
   // ...
private:
   int _top;
   vector<int> _stack;
};
(a) iStack *ps = new iStack(20);
(b) iStack *ps2 = new const iStack(15);
(c) iStack *ps3 = new iStack[ 100 ];
]]></div>

<p>Упражнение 15.10
</p>
<p>Что происходит в следующих выражениях, содержащих new и delete?
</p>

<div class="lang-cpp"><![CDATA[class Exercise {
public:
   Exercise();
   ~Exercise();
};

Exercise *pe = new Exercise[20];
delete[] ps;]]></div>
<p>Измените эти выражения так, чтобы вызывались глобальные операторы new() и delete().
</p>

<p>Упражнение 15.11:
Объясните, зачем разработчик класса должен предоставлять оператор delete().
</p>

</section>

</chapter>
