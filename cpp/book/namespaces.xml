<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="xhtml.xsl"?>

<chapter xmlns="http://www.example.com/postrisc"
 id="namespaces"
 description="Пространства имен"
>
<title>Пространства имен</title>

<preface>
</preface>

<section id="namespace_definition">
<title>Определения пространства имен А</title>

<p>По умолчанию любой объект, функция, тип или шаблон, объявленный в глобальной 
  области видимости, также называемой <em>областью видимости глобального пространства 
  имен</em>, вводит <em>глобальную сущность</em>. Каждая такая сущность обязана 
  иметь уникальное имя. Например, функция и объект не могут быть одноименными, 
  даже если они объявлены в разных исходных файлах.
</p>
<p>
  Таким образом, используя в своей программе некоторую библиотеку, мы должны быть 
  уверены, что имена глобальных сущностей нашей программы не совпадают с именами 
  из библиотеки. Это нелегко, если мы работаем с библиотеками разных производителей, 
  где определено много глобальных имен. Собирая программу с такими библиотеками, 
  нельзя гарантировать, что имена глобальных сущностей не будут вступать в конфликт. 
</p>
<p>
  Обойти эту проблему, названную <em>проблемой засорения области видимости глобального 
  пространства имен</em>, можно посредством очень длинных имен. Часто в качестве 
  их префикса употребляется определенная последовательность символов. Например:
</p>

<div class="lang-cpp"><![CDATA[
class cplusplus_primer_matrix { ... };
void inverse(cplusplus_primer_matrix&);
]]></div>

<p>Однако у этого решения есть недостаток. Программа, написанная на С++, может 
  содержать множество глобальных классов, функций и шаблонов, видимых в любой 
  точке кода. Работать со слишком длинными идентификаторами для программистов 
  утомительно.
</p>
<p>
  Пространства имен помогают справиться с проблемой засорения более удобным способом. 
  Автор библиотеки может задать собственное пространство и таким образом вынести 
  используемые в библиотеке имена из глобальной области видимости:
</p>

<div class="lang-cpp"><![CDATA[
namespace cplusplus_primer {
   class matrix { /*...*/ };
   void inverse(matrix&);
}
]]></div>

<p>cplusplus_primer является <em>пользовательским пространством имен </em>(в отличие 
  от глобального пространства, которое неявно подразумевается и существует в любой 
  программе).
</p>
<p>
  Каждое такое пространство представляет собой отдельную область видимости. Оно 
  может содержать вложенные определения пространств имен, а также объявления или 
  определения функций, объектов, шаблонов и типов. Все сущности, объявленные внутри 
  некоторого пространства имен, называются его членами. Каждое имя в пользовательском 
  пространстве, как и в глобальном, должно быть уникальным в пределах этого пространства.
</p>
<p>
  Однако в разных пользовательских пространствах могут встречаться члены с одинаковыми 
  именами.
</p>
<p>
  Имя члена пространства имен автоматически дополняется, или <em>квалифицируется</em>, 
  именем этого пространства. Например, имя класса matrix, объявленное в пространстве 
  cplusplus_primer, становится cplusplus_primer::matrix, а имя функции inverse() 
  превращается в 
</p>

<div class="lang-cpp"><![CDATA[cplusplus_primer::inverse().]]></div>

<p>Члены cplusplus_primer могут использоваться в программе с помощью спецификации имени:
</p>

<div class="lang-cpp"><![CDATA[
void func(cplusplus_primer::matrix& m) {
   // ...
   cplusplus_primer::inverse(m);
   return m;
}]]></div>

<p>Если в другом пользовательском пространстве имен (скажем, DisneyFeatureAnimation) 
  также существует класс matrix и функция inverse() и мы хотим использовать этот 
  класс вместо объявленного в пространстве cplusplus_primer, то функцию func() 
  нужно модифицировать следующим образом:
</p>

<div class="lang-cpp"><![CDATA[
void func(DisneyFeatureAnimation::matrix& m) {
   // ...
   DisneyFeatureAnimation::inverse(m);
   return m;
}]]></div>

<p>Конечно, каждый раз указывать специфицированные имена типа
</p>

<div class="lang-cpp"><![CDATA[namespace_name::member_name]]></div>

<p>неудобно. Поэтому существуют механизмы, позволяющие облегчить использование 
  пространств имен в программах. Это <em>псевдонимы пространств имен, using-объявления 
  и using-директивы</em>. (Мы рассмотрим их в разделе 8.6.)
</p>

</section>

<section id="namespace_define">
<title>Определения пространства имен</title>

<p>Определение пользовательского пространства имен начинается с ключевого слова 
  namespace, за которым следует идентификатор. Он должен быть уникальным в той 
  области видимости, в которой определяется данное пространство; наличие другой 
  сущности с тем же именем является ошибкой. Конечно, это не означает, что проблема 
  засорения глобального пространства решена полностью, но существенно помогает 
  в ее решении.
</p>
<p>
  За идентификатором пространства имен следует блок в фигурных скобках, содержащий 
  различные объявления. Любое объявление, допустимое в области видимости глобального 
  пространства, может встречаться и в пользовательском: классы, переменные (вместе 
  с инициализацией), функции (вместе со своими определениями), шаблоны.
</p>
<p>
  Помещая объявление в пользовательское пространство, мы не меняем его семантики. 
  Единственное отличие состоит в том, что имена, вводимые такими объявлениями, 
  включают в себя имя пространства, внутри которого они объявлены. Например:
</p>
<div class="lang-cpp"><![CDATA[
namespace cplusplus_primer {
   class matrix { /* ... */ };
   void inverse(matrix&);
   matrix operator+(const matrix& ml, const matrix& m2) { /* ... */ }
   const double pi = 3.1416;
}
]]></div>

<p>Именем класса, объявленного в пространстве cplusplus_primer, будет
</p>

<div class="lang-cpp"><![CDATA[cplusplus_primer::matrix]]></div>

<p>Именем функции
</p>
<div class="lang-cpp"><![CDATA[cplusplus_primer::inverse()]]></div>
<p>Именем константы</p>

<div class="lang-cpp"><![CDATA[cplusplus_primer::pi]]></div>
<p>Имя класса, функции или константы расширяется именем пространства, в котором 
  они объявлены. Такие имена называют квалифицированными.
</p>
<p>
  Определение пространства имен не обязательно должно быть непрерывным. Например, 
  предыдущее пространство могло быть определено таким образом:
</p>

<div class="lang-cpp"><![CDATA[
namespace cplusplus_primer {
   class matrix { /* ... */ };
   const double pi = 3.1416;
}

namespace cplusplus_primer {
  void inverse(matrix&);
  matrix operator+(const matrix& ml, const matrix& m2) { /* ... */ }
}
]]></div>

<p>Два приведенных примера эквивалентны: оба задают пространство имен cplusplus_primer, 
  содержащее класс matrix, функцию inverse(), константу pi и operator+(). Определение 
  пространства имен может состоять из нескольких соединенных частей.
</p>
<p>
  Последовательность
</p>
<div class="lang-cpp"><![CDATA[namespace namespace_name {]]></div>
<p>задает новое пространство, если имя namespace_name не совпадает с одним из 
  ранее объявленных. В противном случае новые объявления добавляются в старое 
  пространство.
</p>
<p>
  Возможность разбить пространство имен на несколько частей помогает при организации 
  библиотеки. Ее исходный код легко разделить на интерфейсную часть и реализацию. 
  Например:
</p>

<div class="lang-cpp"><![CDATA[
// Эта часть пространства имен
// определяет интерфейс библиотеки

namespace cplusplus_primer {
  class matrix { /* ... */ };
  const double pi = 3.1416;
  matrix operator+(const matrix& ml, const matrix& m2 ;
  void inverse (matrix &);
}

// Эта часть пространства имен
// определяет реализацию библиотеки

namespace cplusplus_primer {
  void inverse(matrix& m) { /* ... */ }
  matrix operator+(const matrix& ml, const matrix& m2) { /* ... */ }
}
]]></div>

<p>Первая часть пространства имен содержит объявления и определения, служащие 
  интерфейсом библиотеки: определения типов, констант, объявления функций. Во 
  второй части находятся детали реализации, то есть определения функций.
</p>
<p>
  Еще более полезной для организации исходного кода библиотеки является возможность 
  разделить определение одного пространства имен на несколько файлов: эти определения 
  также объединяются. Наша библиотека может быть устроена следующим образом:
</p>

<div class="lang-cpp"><![CDATA[
// ---- primer.h ----
namespace cplusplus_primer {
   class matrix { /*... */ };
   const double pi = 3.1416;
   matrix operator+(const matrix& m1, const matrix& m2);
   void inverse( matrix&);
}

// ---- primer.C ----
#include "primer.h"
namespace cplusplus_primer {
  void inverse(matrix & m) { /* ... */ }
  matrix operator+ (const matrix& m1, const matrix& m2) { /* ... */ }
}
]]></div>

<p>Программа, использующая эту библиотеку, выглядит так:
</p>

<div class="lang-cpp"><![CDATA[
// ---- user.C ----
// определение интерфейса библиотеки
#include "primer.h"
void func(cplusplus_primer::matrix& m) {
  //...
  cplusplus_primer: :inverse( m );
  return m;
}
]]></div>

<p>Подобная организация программы обеспечивает модульность библиотеки, необходимую 
  для сокрытия реализации от пользователей, в то же время позволяя без ошибок 
  скомпилировать и связать файлы primer.C и user.C в одну программу.
</p>

</section>

<section id="namespace_operator">
<title>Оператор разрешения области видимости</title>

<p>Имя члена пользовательского пространства дополняется поставленным спереди именем 
  этого пространства и оператором разрешения области видимости (::). Использование 
  неквалифицированного члена, например matrix, является ошибкой. Компилятор не 
  знает, к какому объявлению относится это имя:
</p>

<div class="lang-cpp"><![CDATA[// определение интерфейса библиотеки
#include "primer.h"]]></div>

<div class="lang-cpp"><![CDATA[
// ошибка: нет объявления для matrix
void func( matrix& m);
]]></div>

<p>Объявление члена пространства имен скрыто в своем пространстве. Если мы не 
  укажем компилятору, где именно искать объявление, он произведет поиск только 
  в текущей области видимости и в областях, включающих текущую. Допустим, если 
  переписать предыдущую программу так:
</p>

<div class="lang-cpp"><![CDATA[
// определение интерфейса библиотеки
#include "primer.h"

class matrix { /* пользовательское определение */ };
// правильно: глобальный тип matrix найден
void func(matrix& m);
]]></div>

<p>то определение класса matrix компилятор находит в глобальной области видимости 
  и программа компилируется без ошибок. Поскольку объявление matrix как члена 
  пространства имен cplusplus_primer скрыто в этом пространстве, оно не конфликтует 
  с классом, объявленным в глобальной области видимости.
</p>
<p>
  Именно поэтому мы говорим, что пространства имен решают проблему засорения глобального 
  пространства: имена их членов невидимы, если имя пространства не указано явно, 
  с помощью оператора разрешения области видимости. Существуют и другие механизмы, 
  позволяющие сделать объявление члена пространства имен видимым вне его. Это 
  using-объявления и using-директивы. Мы рассмотрим их в следующем разделе.
</p>
<p>
  Отметим, что оператор области видимости может быть использован и для того, чтобы 
  сослаться на элемент глобального пространства имен. Поскольку это пространство 
  не имеет имени, запись
</p>

<div class="lang-cpp"><![CDATA[::member_name]]></div>

<p>относится к его элементу. Такой способ полезен для указания членов глобального 
  пространства, если их имена оказываются скрыты именами, объявленными во вложенных 
  локальных областях видимости.
</p>
<p>
  Следующий пример демонстрирует использование оператора области видимости для 
  обращения к скрытому члену глобального пространства имен. Функция вычисляет 
  последовательность чисел Фибоначчи. В программе два определения переменной max. 
  Глобальная переменная указывает максимальное значение элемента последовательности, 
  при превышении которого вычисление прекращается, а локальная – желаемую длину 
  последовательности при данном вызове функции. (Напоминаем, что параметры функции 
  относятся к ее локальной области видимости.) Внутри функции должны быть доступны 
  обе переменных. Однако неквалифицированное имя max ссылается на локальное объявление 
  этой переменной. Чтобы получить глобальную переменную, нужно использовать оператор 
  разрешения области видимости ::max. Вот текст программы:
</p>

<div class="lang-cpp"><![CDATA[
#include <iostream>
const int max = 65000;
const int lineLength = 12;

void fibonacci(int max) {
   if ( max < 2 ) return;
    cout << "0 1 ";
   int v1 = 0, v2 = 1, cur;
   for ( int ix = 3; ix <= max; ++ix ) {
      cur = v1 + v2;
      if ( cur > ::max ) break;
      cout << cur << " ";
      vl = v2;
      v2 = cur;
      if (ix % "lineLength == 0) cout << end"!;
   }
}]]></div>

<p>Так выглядит функция main(), вызывающая fibonacci():
</p>

<div class="lang-cpp"><![CDATA[#include <iostream&gt;
void fibonacci( int );
int main() {
   cout << "Числа Фибоначчи: 16\n";
   fibonacci( 16 );
   return 0;
}]]></div>

<p>Результат работы программы:
</p>

<div class="lang-cpp"><![CDATA[Числа Фибоначчи: 16
0 1 1 2 3 5 8 13 21 34 55 89
144 233 377 610
]]></div>

</section>

<section id="namespace_embed">
<title>Вложенные пространства имен</title>

<p>Мы уже упоминали, что пользовательские пространства имен могут быть вложенными. 
  Такие пространства применяются для дальнейшего структурирования кода нашей библиотеки. 
</p>

<div class="lang-cpp"><![CDATA[
// ---- primer.h ----
namespace cplusplus_primer {
    // первое вложенное пространство имен:
    // матричная часть библиотеки
    namespace MatrixLib {
        class matrix { /* ... */ };
        const double pi = 3.1416;
        matrix operators+ (const matrix& ml, const matrix& m2 );
        void inverse( matrix&);
        // ...
    }
    // второе вложенное пространство имен:
    // зоологическая часть библиотеки
    namespace AnimalLib {
        class ZooAnimal { /* ... */ };
        class Bear : public ZooAnimal { /* ... */ };
        class Raccoon : public Bear { /* ... */ };
        // ...
    }
}
]]></div>

<p>Пространство имен cplusplus_primer содержит два вложенных: MatrixLib и AnimalLib.
</p>
<p>
  cplusplus_primer предотвращает конфликт между именами из нашей библиотеки и 
  именами из глобального пространства вызывающей программы. Вложенность позволяет 
  делить библиотеку на части, в которых сгруппированы связанные друг с другом 
  объявления и определения. MatrixLib содержит сущности, имеющие отношение к классу 
  matrix, а AnimalLib – к классу ZooAnimal.
</p>
<p>
  Объявление члена вложенного пространства скрыто в этом пространстве. Имя такого 
  члена автоматически дополняется поставленными спереди именами самого внешнего 
  и вложенного пространств.
</p>

<p>Например, класс, объявленный во вложенном пространстве MatrixLib, имеет имя</p>
<p>cplusplus_primer::MatrixLib::matrix</p>
<p>а функция</p>
<p>cplusplus_primer::MatrixLib::inverse</p>
<p>
  Программа, использующая члены вложенного пространства cplusplus_primer::MatrixLib, 
  выглядит так:
</p>

<div class="lang-cpp"><![CDATA[
#include "primer.h"
// да, это ужасно...
// скоро мы рассмотрим механизмы, облегчающие
// использование членов пространств имен!
void func(cplusplus_primer::MatrixLib::matrix& m) {
  // ...
  cplusplus_primer::MatrixLib::inverse(m);
  return m;
}
]]></div>

<p>Вложенное пространство имен является вложенной областью видимости внутри пространства, 
  содержащего его. В процессе разрешения имен вложенные пространства ведут себя 
  так же, как вложенные блоки. Когда некоторое имя употребляется в пространстве 
  имен, поиск его объявление проводится во всех объемлющих пространствах. В следующем 
  примере разрешение имени Type происходит в таком порядке: сначала ищем его в 
  пространстве имен MatrixLib, затем в cplusplus_primer и наконец в глобальной 
  области видимости:
</p>

<div class="lang-cpp"><![CDATA[
typedef double Type;
namespace cplusplus_primer {
    typedef int Type; // скрывает ::Type
    namespace MatrixLib {
        int val;
        // Type: объявление найдено в cplusplus_primer
        int func(Type t) {
            double val; // скрывает MatrixLib::val
            val = ...;
        }
        // ...
    }
}]]></div>
<p>Если некоторая сущность объявляется во вложенном пространстве имен, она скрывает 
  объявление одноименной сущности из объемлющего пространства.
</p>
<p>
  В предыдущем примере имя Type из глобальной области видимости скрыто объявлением 
  Type в пространстве cplusplus_primer. При разрешении имени Type, упоминаемого 
  в MatrixLib, оно будет найдено в cplusplus_primer, поэтому у функции func() 
  параметр имеет тип int.
</p>
<p>
  Аналогично сущность, объявленная в пространстве имен, скрывается одноименной 
  сущностью из вложенной локальной области видимости. В предыдущем примере имя 
  val из MatrixLib скрыто новым объявлением val. При разрешении имени val внутри 
  func() будет найдено его объявление в локальной области видимости, и потому 
  присваивание в func() относится именно к локальной переменной. 
</p>

</section>

<section id="namespace_member">
<title>Определение члена пространства имен</title>

<p>Мы видели, что определение члена пространства имен может появиться внутри определения 
  самого пространства. Например, класс matrix и константа pi появляются внутри 
  вложенного пространства имен MatrixLib, а определения функций operator+() и 
  inverse() приводятся где-то в другом месте текста программы:
</p>

<div class="lang-cpp"><![CDATA[
// ---- primer.h ----
namespace cplusplus_primer {
    // первое вложенное пространство имен:
    // матричная часть библиотеки
    namespace MatrixLib {
        class matrix { /* ... */ };
        const double pi = 3.1416;
        matrix operators+ ( const matrix& ml, const matrix& m2);
        void inverse( matrix&);
        // ...
    }
}
]]></div>

<p>Член пространства имен можно определить и вне соответствующего пространства. 
  В таком случае имя члена должно быть квалифицировано именами пространств, к 
  которым он принадлежит. Например, если определение функции operator+() помещено 
  в глобальную область видимости, то оно должно выглядеть следующим образом:
</p>

<div class="lang-cpp"><![CDATA[
// ---- primer.c ----
#include "primer.h"

// определение в глобальной области видимости
cplusplus_primer::MatrixLib::matrix
cplusplus_primer::MatrixLib::operator+
( const matrix& ml, const matrix& m2 )
{ /* ... */ }
]]></div>

<p>Имя operator+() квалифицировано в данном случае именами пространств cplusplus_primer 
  и MatrixLib. Однако обратите внимание на тип matrix в списке параметров operator+(): 
  употреблено неквалифицированное имя. Как такое может быть?
</p>

<p>
  В определении функции operator+() можно использовать неквалифицированные имена 
  для членов своего пространства, поскольку определение принадлежит к его области 
  видимости. При разрешении имен внутри функции operator+() используется MatrixLib. 
  Заметим, однако, что в типе возвращаемого значения все же нужно указывать квалифицированное 
  имя, поскольку он расположен вне области видимости, заданной определением функции:
</p>

<div class="lang-cpp"><![CDATA[cplusplus_primer::MatrixLib::operator+]]></div>
<p>В определении operator+() неквалифицированные имена могут встречаться в любом 
  объявлении или выражении внутри списка параметров или тела функции. Например, 
  локальное объявление внутри operator+() способно создать объект класса matrix:
</p>

<div class="lang-cpp"><![CDATA[
// ---- primer.C ----
#include "primer.h"

cplusplus_primer::MatrixLib::matrix
cplusplus_primer::MatrixLib::operator+(const matrix& ml, const matrix& m2) {
    // объявление локальной переменной типа
    // cplusplus_primer::MatrixLib::matrix
    matrix res;
    // вычислим сумму двух объектов matrix
    return res;
}
]]></div>

<p>Хотя члены могут быть определены вне своего пространства имен, такие определения 
  допустимы не в любом месте. Их разрешается помещать только в пространства, объемлющие 
  данное. Например, определение operator+() может появиться в глобальной области 
  видимости, в пространстве имен cplusplus_primer и в пространстве MatrixLib. 
  В последнем случае это выглядит так:
</p>
<div class="lang-cpp"><![CDATA[
// ---- primer.C --
#include "primer.h"

namespace cplusplus_primer {
  MatrixLib::matrix MatrixLib::operator+(const matrix& ml, const matrix& m2)
  { /* ... */ }
}
]]></div>

<p>Член может определяться вне своего пространства только при условии, что ранее 
  он был объявлен внутри. Последнее приведенное определение operator+() было бы 
  ошибочным, если бы ему не предшествовало объявление в файле primer.h:
</p>
<div class="lang-cpp"><![CDATA[
namespace cplusplus_primer {
   namespace MatrixLib {
      class matrix { /*...*/ };
      // следующее объявление не может быть пропущено
      matrix operator+ ( const matrix& ml, const matrix& m2);
      // ...
   }
}
]]></div>

</section>

<section id="namespace_member_poo">
<title>ПОО и члены пространства имен</title>

<p>Как уже было сказано, определение пространства имен может состоять из разрозненных 
  частей и размещаться в разных файлах. Следовательно, член пространства разрешено 
  объявлять во многих файлах. Например:
</p>
<div class="lang-cpp"><![CDATA[
// primer.h
namespace cplusplus_primer {
// ...
   void inverse(matrix&);
}

// usel.c
#include "primer.h"
// объявление cplusplus_primer::inverse() в use1.c

// use2.c
#include "primer.h"
// объявление cplusplus_primer::inverse() в use2.c
]]></div>

<p>Объявление cplusplus::inverse() в primer.h ссылается на одну и ту же функцию 
  в обоих исходных файлах use1.C и use2.C.
</p>
<p>
  Член пространства имен является глобальной сущностью, хотя его имя квалифицировано. 
  Требование ПОО (правило одного определения, см. раздел 8.2) распространяется 
  и на него. Чтобы удовлетворить этому требованию, программы, в которых используются 
  пространства имен, обычно организуют следующим образом:
</p>

<ol>
  <li> Объявления функций и объектов, являющихся членами пространства имен, помещают 
    в заголовочный файл, который включается в каждый исходный файл, где они используются. 
  </li>
  <li> Определения этих членов помещают в исходный файл, содержащий реализацию: 
  </li>
</ol>

<div class="lang-cpp"><![CDATA[
// ---- primer.h ----
namespace cplusplus_primer {
   class matrix { /* ... */ };
   // объявления функций
   extern matrix operator+(const matrix& m1, const matrix& m2);
   extern void inverse(matrix&);

   // объявления объектов
   extern bool error_state;
}

// ---- primer.C ----
#include "primer.h"
namespace cplusplus_primer {
   // определения функций
   void inverse(matrix&)
   { /* ... */ }
   matrix operator+(const matrix& ml, const matrix& m2)
   { /" ... */ }
   // определения объектов
   bool error_state = false;
}
]]></div>

<p>Для объявления объекта без его определения используется ключевое слово extern, 
  как и в случае такого объявления в глобальной области видимости.
</p>

</section>

<section id="namespace_anonimous">
<title>Безымянные пространства имен</title>

<p>Может возникнуть необходимость определить объект, функцию, класс или любую 
  другую сущность так, чтобы она была видимой только в небольшом участке программы. 
  Это еще один способ решения проблемы засорения глобального пространства имен. 
  Поскольку мы уверены, что эта сущность используется ограниченно, можно не тратить 
  время на выдумывание уникального имени. Если мы объявляем объект внутри функции 
  или блока, его имя видимо только в этом блоке. А как сделать некоторую сущность 
  доступной нескольким функциям, но не всей программе?
</p>
<p>
  Предположим, мы хотим реализовать набор функций для сортировки вектора типа 
  double:
</p>

<div class="lang-cpp"><![CDATA[
// ----- SortLib.h -----
void quickSort( double *, double * );
void bubbleSort( double *, double * );
void mergeSort( double *, double * );
void heapSort( double *, double * );]]></div>
<p>Все они используют одну и ту же функцию swap() для того, чтобы менять местами 
  элементы вектора. Однако она не должна быть видна во всей программе, поскольку 
  нужна только четырем названным функциям. Локализуем ее в файле SortLib.C. Приведенный 
  код не дает желаемого результата. Как вы думаете, почему?
</p>

<div class="lang-cpp"><![CDATA[
// ----- SortLib.C -----
void swap( double *dl, double *d2 ) { /* ... */ }

// только эти функции используют swap()
void quickSort( double *d1, double *d2 ) { /* ... */ }
void bubbleSort( double *d1, double *d2 ) { /* ... */ }
void mergeSort( double *d1, double *d2 ) { /* ... */ }
void heapSort( double *d1, double *d2 ) { /* ... */ }
]]></div>

<p>Хотя функция swap() определена в файле SortLib.C и не появляется в заголовочном 
  файле SortLib.h, где содержится описание интерфейса библиотеки сортировки, она 
  объявлена в глобальной области видимости. Следовательно, это имя является глобальным, 
  при этом сохраняется возможность конфликта с другими именами.
</p>
<p>
  Язык С++ предоставляет возможность использования безымянного пространства имен 
  для объявления сущности, локальной по отношению к файлу. Определение такого 
  пространства начинается ключевым словом namespace. Очевидно, что никакого имени 
  за этим словом нет, а сразу же идет блок в фигурных скобках, содержащий различные 
  объявления. Например:
</p>

<div class="lang-cpp"><![CDATA[
// ----- SortLib.c -----
namespace {
   void swap( double *dl, double *d2 ) { /* ... */ }
} 
// определения функций сортировки не изменяются
]]></div>

<p>Функция swap() видна только в файле SortLib.C. Если в другом файле в безымянном 
  пространстве имен содержится определение swap(), то это другая функция. Наличие 
  двух функций swap() не является ошибкой, поскольку они различны. Безымянные 
  пространства имен отличаются от прочих: определение такого пространства локально 
  для одного файла и не может размещаться в нескольких.
</p>
<p>
  Имя swap() может употребляться в неквалифицированной форме в файле SortLib.C 
  после определения безымянного пространства. Оператор разрешения области видимости 
  для ссылки на его члены не нужен.
</p>

<div class="lang-cpp"><![CDATA[
void quickSort(double *d1, double *d2) {
   // ...
   double* elem = d1;
   // ...
   // ссылка на член безымянного пространства имен swap()
   swap( d1, elem );
   // ...
}
]]></div>

<p>Члены безымянного пространства имен относятся к сущностям программы. Поэтому 
  функция swap() может быть вызвана во время выполнения. Однако имена этих членов 
  видны только внутри одного файла.

  До того как в стандарте С++ появилось понятие пространства имен, наиболее удачным 
  решением проблемы локализации было использование ключевого слова static, унаследованного 
  из С. Член безымянного пространства имеет свойства, аналогичные глобальной сущности, 
  объявленной как static. В языке С такая сущность невидима вне файла, в котором 
  объявлена. Например, текст из SortLib.C можно переписать на С, сохранив свойства 
  swap():
</p>
<div class="lang-cpp"><![CDATA[// SortLib.C
// swap() невидима для других файлов программы
static void swap( double *d1, double *d2 ) { /* ... */ }
// определения функций сортировки такие же, как и раньше]]></div>

<p>Во многих программах на С++ используются объявления с ключевым словом static. 
  Предполагается, что они должны быть заменены безымянными пространствами имен 
  по мере того, как все большее число компиляторов начнет поддерживать это понятие.
</p>

<p>Упражнение 8.11:
Зачем нужно определять собственное пространство имен в программе?
</p>

<p>Упражнение 8.12:
Имеется следующее объявление operator*(), члена вложенного пространства имен <q>cplusplus_primer::MatrixLib</q>:
</p>

<div class="lang-cpp"><![CDATA[
namespace cplusplus_primer {
   namespace MatrixLib {
      class matrix { /*...*/ };
      matrix operator* (const matrix&, const matrix&);
      // ...
   }
}
]]></div>

<p>Как определить эту функцию в глобальной области видимости? Напишите только прототип.
</p>

<p>Упражнение 8.13:
Объясните, зачем нужны безымянные пространства имен.
</p>

</section>

<section id="namespace_usage">
<title>Использование членов пространства имен</title>

<p>Использование квалифицированных имен при каждом обращении к членам пространств 
  может стать обременительным, особенно если имена пространств достаточно длинны. 
  Если бы удалось сделать их короче, то такие имена проще было бы читать и набивать. 
  Однако употребление коротких имен увеличивает риск их совпадения с другими, 
  поэтому желательно, чтобы в библиотеках применялись пространства с длинными 
  именами.
</p>
<p>
  К счастью, существуют механизмы, облегчающие использование членов пространств 
  имен в программах. <em>Псевдонимы пространства имен</em>, <em>using-объявления 
  и using-директивы </em>помогают преодолеть неудобства работы с очень длинными 
  именами.
</p>

</section>

<section id="namespace_aliases">
<title>Псевдонимы пространства имен</title>

<p>Псевдоним пространства имен используется для задания короткого синонима имени 
  пространства. Например, длинное имя
</p>

<p>namespace International_Business_Machines</p>
<p>{ /* ... */ }</p>
<p>может быть ассоциировано с более коротким синонимом:</p>

<div class="lang-cpp"><![CDATA[namespace IBM = International_Business_Machines;]]></div>

<p>Объявление псевдонима начинается ключевым словом namespace, за которым следует 
  короткий псевдоним, а за ним – знак равенства и исходное полное имя пространства. 
  Если полное имя не соответствует никакому известному пространству, это ошибка.
</p>
<p>
  Псевдоним может относиться и к вложенному пространству имен. Вспомним слишком 
  длинное определение функции func() выше:
</p>

<div class="lang-cpp"><![CDATA[
#include "primer.h"
// трудно читать!
void func(cplusplus_primer::MatrixLib::matrix& m) {
  // ...
  cplusplLis_primer::MatrixLib::inverse( m );
  return m;
}
]]></div>

<p>Разрешается задать псевдоним для обозначения вложенного cplusplLis_primer::MatrixLib, 
  сделав определение функции более удобным для восприятия:
</p>

<div class="lang-cpp"><![CDATA[
#include "primer.h"
// более короткий псевдоним
namespace mlib = cplusplus_primer::MatrixLib;

// читать проще!
void func(mlib::matrix &m ) {
  // ...
  mlib::inverse( m );
  return m;
}
]]></div>

<p>Одно пространство имен может иметь несколько взаимозаменяемых псевдонимов. 
  Например, если псевдоним Lib ссылается на cplusplus_primer, то определение функции 
  func() может выглядеть и так:
</p>
<div class="lang-cpp"><![CDATA[
// псевдоним alias относится к пространству имен cplusplus_primer
namespace alias = Lib;

void func(cplusplus_primer::matrix& m) {
  // ...
  alias::inverse( m );
  return m;
}
]]></div>

</section>

<section id="namespace_using">
<title>Using-объявления</title>

<p>Имеется механизм, позволяющий обращаться к членам пространства имен, используя 
  их имена без квалификатора, т.е. без префикса namespace_name::. Для этого применяются 
  using-объявления.

  Using-объявление начинается ключевым словом using, за которым следует квалифицированное 
  имя члена пространства. Например:
</p>
<div class="lang-cpp"><![CDATA[namespace cplusplus_primer {
   namespace MatrixLib {
      class matrix { /* ... */ };
      // ...
   }
}

// using-объявление для члена matrix
using cplusplus_primer::MatrixLib::matrix;]]></div>
<p>Using-объявление вводит имя в ту область видимости, в которой оно использовано. 
  Так, предыдущее using-объявление делает имя matrix глобально видимым.

  После того как это объявление встретилось в программе, использование имени matrix 
  в глобальной области видимости или во вложенных в нее областях относится к этому 
  члену пространства имен. Пусть далее идет следующее объявление:
</p>

<div class="lang-cpp"><![CDATA[void func(matrix& m);]]></div>

<p>Оно вводит функцию func() с параметром типа cplusplus_primer:: MatrixLib::matrix.
</p>
<p>
  Using-объявление ведет себя подобно любому другому объявлению: оно имеет область 
  видимости, и имя, введенное им, можно употреблять начиная с места объявления 
  и до конца области видимости. Using-объявление может использоваться в глобальной 
  области видимости, равно как и в области видимости любого пространства имен. 
  Оно употребляется и в локальной области. Имя, вводимое using-объявлением, как 
  и любым другим, имеет следующие характеристики:
</p>

<ul>
  <li>оно должно быть уникальным в своей области видимости;</li>
  <li> оно скрывает одноименную сущность во внешней области;</li>
  <li> оно скрывается объявлением одноименной сущности во вложенной области.</li>
</ul>

<p>Например:</p>

<div class="lang-cpp"><![CDATA[
namespace blip {
    int bi = 16, bj = 15, bk = 23;
    // прочие объявления
}
int bj = 0;
void manip() {
    using blip::bi; // bi в функции manip() ссылается на blip::bi
    ++bi;           // blip::bi == 17
    using blip::bj; // скрывает глобальную bj
                    // bj в функции manip()ссылается на blip::bj
    ++bj;           // blip::bj == 16
    int bk;         // объявление локальной bk
    using blip::bk; // ошибка: повторное определение bk в manip()
}
int wrongInit = bk; // ошибка: bk невидима
                    // надо использовать blip::bk
]]></div>

<p>Using-объявления в функции manip() позволяют ссылаться на членов пространства 
  blib с помощью неквалифицированных имен. Такие объявления не видны вне manip(), 
  и неквалифицированные имена могут применяться только внутри этой функции. Вне 
  ее необходимо употреблять квалифицированные имена.
</p>
<p>
  Using-объявление упрощает использование членов пространства имен. Оно вводит 
  только одно имя. Using-объявление может находиться в определенной области видимости, 
  и, значит, мы способны точно указать, в каком месте программы те или иные члены 
  разрешается употреблять без дополнительной квалификации.
</p>
<p>
  В следующем подразделе мы расскажем, как ввести в определенную область видимости 
  все члены некоторого пространства имен. 
</p>

</section>

<section id="namespace_using_direct">
<title>Using-директивы</title>

<p>Пространства имен появились в стандартном С++. Предыдущие версии С++ их не 
  поддерживали, и, следовательно, поставляемые библиотеки не помещали глобальные 
  объявления в пространства имен. Множество программ на С++ было написано еще 
  до того, как компиляторы стали поддерживать такую опцию. Заключая содержимое 
  библиотеки в пространство имен, мы можем испортить старое приложение, использующее 
  ее предыдущие версии: все имена из этой библиотеки становятся квалифицированными, 
  т.е. должны включать имя пространства вместе с оператором разрешения области 
  видимости. Те приложения, в которых эти имена употребляются в неквалифицированной 
  форме, перестают компилироваться.
</p>
<p>
  Сделать видимыми имена из библиотеки, используемой в нашей программе, можно 
  с помощью using-объявления. Предположим, что файл primer.h содержит интерфейс 
  новой версии библиотеки, в котором глобальные объявления помещены в пространство 
  имен cplusplus_primer. Нужно заставить нашу программу работать с новой библиотекой. 
  Два using-объявления сделают видимыми имена класса matrix и функции inverse() 
  из пространства cplusplus_primer:
</p>

<div class="lang-cpp"><![CDATA[
#include "primer.h"
using cplusplus_primer::matrix;
using cplusplus_primer::inverse;

// using-объявления позволяют использовать
// имена matrix и inverse без спецификации
void func(matrix& m) {
  // ...
  inverse( m );
  return m;
}
]]></div>

<p>Но если библиотека достаточно велика и приложение часто использует имена из 
  нее, то для подгонки имеющегося кода к новой библиотеке может потребоваться 
  много using-объявлений. Добавлять их все только для того, чтобы старый код скомпилировался 
  и заработал, утомительно и чревато ошибками. Решить эту проблему помогают using-директивы, 
  облегчающие переход на новую версию библиотеки, где впервые стали применяться 
  пространства имен.

  Using-директива начинается ключевым словом using, за которым следует ключевое 
  слово namespace, а затем имя некоторого пространства имен. Это имя должно ссылаться 
  на определенное ранее пространство, иначе компилятор выдаст ошибку. Using-директива 
  позволяет сделать все имена из этого пространства видимыми в неквалифицированной 
  форме.

  Например, предыдущий фрагмент кода может быть переписан так:
</p>

<div class="lang-cpp"><![CDATA[
#include "pnmer.h"

// using-директива: все члены cplusplus_primer
// становятся видимыми
using namespace cplusplus_primer;

// имена matrix и inverse можно использовать без спецификации
void func(matrix& m) {
  // ...
  inverse( m );
  return m;
}
]]></div>

<p>Using-директива делает имена членов пространства имен видимыми за его пределами, 
  в том месте, где она использована. Например, приведенная using-директива создает 
  иллюзию того, что все члены cplusplus_primer объявлены в глобальной области 
  видимости перед определением func(). При этом члены пространства имен не получают 
  локальных псевдонимов, а как бы перемещаются в новую область видимости. Код
</p>
<div class="lang-cpp"><![CDATA[namespace A {
   int i, j;
}]]></div>
<p>выглядит как
</p>
<div class="lang-cpp"><![CDATA[int i, J;]]></div>
<p>для фрагмента программы, содержащего в области видимости следующую using-директиву:

  using namespace A;

  Рассмотрим пример, позволяющий подчеркнуть разницу между using-объявлением (которое 
  сохраняет пространство имен, но создает ассоциированные с его членами локальные 
  синонимы) и using-директивой (которая полностью удаляет границы пространства 
  имен).
</p>

<div class="lang-cpp"><![CDATA[
namespace blip {
    int bi = 16, bj = 15, bk = 23;
    // прочие объявления
}
int bj = 0;
void manip() {
    using namespace blip; // using-директива -
                          // коллизия имен ::bj and blip::bj
                          // обнаруживается только при
                          // использовании bj
    ++bi;                 // blip::bi == 17
    ++bj;                 // ошибка: неоднозначность
                          // глобальная bj или blip::bj?
    ++::bj;               // правильно: глобальная bj == 1
    ++blip::bj;           // правильно: blip::bj == 16
    int bk = 97;	         // локальная bk скрывает blip::bk
    ++bk;	               // локальная bk == 98
}
]]></div>

<p>Во-первых, using-директивы имеют область видимости. Такая директива в функции 
  manip() относится только к блоку этой функции. Для manip() члены пространства 
  имен blip выглядят так, как будто они объявлены в глобальной области видимости, 
  а следовательно, можно использовать их неквалифицированные имена. Вне этой функции 
  необходимо употреблять квалифицированные.
</p>
<p>
  Во-вторых, ошибки неоднозначности, вызванные применением using-директивы, обнаруживают 
  себя при реальном обращении к такому имени, а не при встрече в тексте самой 
  этой директивы. Например, переменная bj, член пространства blib, выглядит для 
  manip() как объявленная в глобальной области видимости, вне blip. Однако в глобальной 
  области уже есть такая переменная. Возникает неоднозначность имени bj в функции 
  manip(): оно относится и к глобальной переменной, и к члену пространства blip. 
  Ошибка проявляется только при упоминании bj в функции manip(). Если бы это имя 
  вообще не использовалось в manip(), коллизия не проявилась бы.
</p>
<p>
  В-третьих, using-директива не затрагивает употребление квалифицированных имен. 
  Когда в manip() упоминается ::bj, имеется в виду переменная из глобальной области 
  видимости, а blip::bj обозначает переменную из пространства имен blip.
</p>
<p>
  И наконец члены пространства blip выглядят для функции manip() так, как будто 
  они объявлены в глобальной области видимости. Это означает, что локальные объявления 
  внутри manip() могут скрывать имена членов пространства blip. Локальная переменная 
  bk скрывает blip::bk. Ссылка на bk внутри manip() не является неоднозначной 
  – речь идет о локальной переменной.
</p>
<p>
  Using-директивы использовать очень просто: стоит написать одну такую директиву, 
  и все члены пространства имен сразу становятся видимыми. Однако чрезмерное увлечение 
  ими возвращает нас к старой проблеме засорения глобального пространства имен:
</p>

<div class="lang-cpp"><![CDATA[
namespace cplusplus_primer {
   class matrix { };
   // прочие вещи ...
}
namespace DisneyFeatureAnimation {
   class matrix { };
   // здесь тоже ...

   using namespace cplusplus_primer;
   using namespace DisneyFeatureAnimation;

   matrix m; //ошибка, неоднозначность:
   // cplusplus_primer::matrix или DisneyFeatureAnimation::matrix?
]]></div>

<p>Ошибки неоднозначности, вызываемые using-директивой, обнаруживаются только 
  в момент использования. В данном случае – при употреблении имени matrix. Такая 
  ошибка, найденная не сразу, может стать сюрпризом: заголовочные файлы не менялись 
  и никаких новых объявлений в программу добавлено не было. Ошибка появилась после 
  того, как мы решили воспользоваться новыми средствами из библиотеки.
</p>
<p>
  Using-директивы очень полезны при переводе приложений на новые версии библиотек, 
  использующие пространства имен. Однако употребление большого числа using-директив 
  возвращает нас к проблеме засорения глобального пространства имен. Эту проблему 
  можно свести к минимуму, если заменить using-директивы более селективными using-объявлениями. 
  Ошибки неоднозначности, вызываемые ими, обнаруживаются в момент объявления. 
  Мы рекомендуем пользоваться using-объявлениями, а не using-директивами, чтобы 
  избежать засорения глобального пространства имен в своей программе.
</p>

</section>

<section id="namespace_std">
<title>Стандартное пространство имен std</title>

<p>Все компоненты стандартной библиотеки С++ находятся в пространстве имен std. 
  Каждая функция, объект и шаблон класса, объявленные в стандартном заголовочном 
  файле, таком, как &lt;vector&gt; или &lt;iostream&gt;, принадлежат к этому пространству.

  Если все компоненты библиотеки объявлены в std, то какая ошибка допущена в данном 
  примере:
</p>
<div class="lang-cpp"><![CDATA[
#include <vector>
#include <string>
#include <iterator>

int main() {
   // привязка istream_iterator к стандартному вводу
   istream_iterator<string> infile( cin );

   // istream_iterator, отмечающий end-of-stream
   istream_iterator<string> eos;

   // инициализация svec элементами, считываемыми из cin
   vector<string> svec( infile, eos );
   // ...
}
]]></div>

<p>Правильно, этот фрагмент кода не компилируется, потому что члены пространства 
  имен std должны использоваться с указанием их специфицированных имен. Для того 
  чтобы исправить положение, мы можем выбрать один из следующих способов:
</p>

<ul>
  <li> заменить имена членов пространства std в этом примере соответствующими 
    специфицированными именами;</li>
  <li>применить using-объявления, чтобы сделать видимыми используемые члены пространства 
    std;</li>
  <li> употребить using-директиву, сделав видимыми все члены пространства std.</li>
</ul>

<p>Членами пространства имен std в этом примере являются: шаблон класса istream_iterator, 
  стандартный входной поток cin, класс string и шаблон класса vector.
</p>
<p>
  Простейшее решение – добавить using-директиву после директивы препроцессора 
  #include:</p>
<p>
  using namespace std;</p>
<p>
  В данном примере using-директива делает все члены пространства std видимыми. 
  Однако не все они нам нужны. Предпочтительнее пользоваться using-объявлениями, 
  чтобы уменьшить вероятность коллизии имен при последующем добавлении в программу 
  глобальных объявлений.
</p>
<p>
  Using-объявления, необходимые для компиляции этого примера, таковы:
</p>

<div class="lang-cpp"><![CDATA[
using std::istream_iterator;
using std::string;
using std::cin;
using std::vector;
]]></div>

<p>Но куда их поместить? Если программа состоит из большого количества файлов, 
  можно для удобства создать заголовочный файл, содержащий все эти using-объявления, 
  и включать его в исходные файлы вслед за заголовочными файлами стандартной библиотеки.
</p>
<p>
  В нашей книге мы не употребляли using-объявлений. Это сделано, во-первых, для 
  того, чтобы сократить размер кода, а во-вторых, потому, что большинство примеров 
  компилировались в реализации С++, не поддерживающей пространства имен. Подразумевается, 
  что using-объявления указаны для всех членов пространства имен std, используемых 
  в примерах.
</p>

<p>Упражнение 8.14:
Поясните разницу между using-объявлениями и using-директивами.
</p>

<p>Упражнение 8.15:
Напишите все необходимые using-объявления для примера из раздела 6.14.
</p>

<p>Упражнение 8.16:
Для следующего фрагмента кода, каковы будут значения объявлений и выражений,
если поместить using-объявления для всех членов пространства имен Exercise в точку //1? В точку //2?
А если вместо using-объявлений использовать using-директиву?
</p>

<div class="lang-cpp"><![CDATA[
namespace Exercise {
   int ivar = 0;
   double dvar = 0;
   const int limit = 1000;
}
int ivar = 0;

//1
void manip() {
//2
  double dvar = 3.1416;
  int iobj = limit + 1;
  ++ivar;
  ++::ivar;
}]]></div>

</section>
</chapter>
